<html>

<head>
<title>CockpitMgr for OpenVMS - Oracle Rdb Toolset - Users Guide</title>
</head>

<body>

<center>
<h2>    
<font face="helvetica, arial, sans-serif" color="#330099">
CockpitMgr for OpenVMS<br>
Oracle Rdb Toolset<br>
Users Guide
</font> 
</h2>
</center>
<br>

<b>CPTRDB_USERS_GUIDE.HTML</b><br><br>

Created:  17-apr-2013, Luc Allemeersch<br>
Modified: 06-nov-2019, Luc Allemeersch<br>

<a name="Chapter 1"></a>
<h3>    
<font face="helvetica, arial, sans-serif" color="#330099">
§ -- 1 -- Contents
</font>
</h3>

<a href="#Chapter 2">§ -- 2 -- Introduction</a><br>
<a href="#Chapter 3">§ -- 3 -- The Author</a><br>
<a href="#Chapter 4">§ -- 4 -- License And Support</a><br>
<a href="#Chapter 5">§ -- 5 -- Development Environment</a><br><br>

<a href="#Chapter 6">§ -- 6 -- Restore The Kit</a><br>
<a href="#Chapter 6.1">§ -- 6.1 -- First Full And/Or Cumulative Partial Update Kit Installation</a><br>
<a href="#Chapter 6.2">§ -- 6.2 -- Full Kit New Version Upgrade Installation</a><br><br>

<a href="#Chapter 7">§ -- 7 -- Kit Updates Log</a><br>
<a href="#Chapter 8">§ -- 8 -- Configuration And Parameter File</a><br>
<a href="#Chapter 9">§ -- 9 -- Reference Files</a><br>
<a href="#Chapter 10">§ -- 10 -- CockpitMgr for OpenVMS Oracle Rdb Events</a><br>
<a href="#Chapter 11">§ -- 11 -- Clear CockpitMgr Event Messages</a><br>
<a href="#Chapter 12">§ -- 12 -- SQL Attach Utility Procedure</a><br>
<a href="#Chapter 13">§ -- 13 -- Mail Utility Files</a><br><br>

<a href="#Chapter 14">§ -- 14 -- Minimum Setup Requirements</a><br>
<a href="#Chapter 14.1">§ -- 14.1 -- Getting Started</a><br><br>

<a href="#Chapter 15">§ -- 15 -- Create A Demonstration And Test Environment</a><br>
<a href="#Chapter 16">§ -- 16 -- Database Backup</a><br>
<a href="#Chapter 17">§ -- 17 -- AIJ Journal Backup</a><br>
<a href="#Chapter 18">§ -- 18 -- List And Check Database Backup Files</a><br>
<a href="#Chapter 19">§ -- 19 -- List And Check AIJ Backup Files</a><br>
<a href="#Chapter 20">§ -- 20 -- List And Check Batch Entries</a><br>
<a href="#Chapter 21">§ -- 21 -- List And Check Live AIJ Files</a><br>
<a href="#Chapter 22">§ -- 22 -- Cleanup Log And Output Files</a><br>
<a href="#Chapter 23">§ -- 23 -- Quick Interactive Check</a><br>
<a href="#Chapter 24">§ -- 24 -- Collect RMU/Show Statistics Stall And Deadlock Messages</a><br>
<a href="#Chapter 25">§ -- 25 -- Collect And Format RMU/Show Statistics Binary Output Data</a><br>
<a href="#Chapter 26">§ -- 26 -- List And Check RMU/Show Statistics Processes And Files</a><br>
<a href="#Chapter 27">§ -- 27 -- List And Check Open Databases</a><br>
<a href="#Chapter 28">§ -- 28 -- Monitor And Manage Storage Area Extents</a><br>
<a href="#Chapter 29">§ -- 29 -- Truncate Snapshots Online</a><br>
<a href="#Chapter 30">§ -- 30 -- Detect And Summarize Bugcheck Dump Files</a><br>
<a href="#Chapter 31">§ -- 31 -- List And Detect Excessive Stall Counts Per Hour</a><br>
<a href="#Chapter 32">§ -- 32 -- List And Detect Excessive Deadlock Counts Per Hour</a><br>
<a href="#Chapter 33">§ -- 33 -- List And Detect Excessive Stall Times</a><br>
<a href="#Chapter 34">§ -- 34 -- Placement Via Hashed Index And Vertical/Horizontal Partitioning</a><br>
<a href="#Chapter 35">§ -- 35 -- Collect And Store RMU/Analyze Data</a><br>
<a href="#Chapter 36">§ -- 36 -- List RMU/Analyze Data</a><br>
<a href="#Chapter 37">§ -- 37 -- List Database Objects</a><br><br>

<a href="#Chapter 38">§ -- 38 -- Tune Indices To Queries</a><br>
<a href="#Chapter 38.1">§ -- 38.1 -- Identify Potential Problem Areas</a><br>
<a href="#Chapter 38.2">§ -- 38.2 -- Index Design Guidelines</a><br>
<a href="#Chapter 38.3">§ -- 38.3 -- Index Node Sizes</a><br>
<a href="#Chapter 38.4">§ -- 38.4 -- Logical Area Thresholds</a><br>
<a href="#Chapter 38.5">§ -- 38.5 -- Scanning Space Management SPAM Pages</a><br>
<a href="#Chapter 38.6">§ -- 38.6 -- Procedures Usage</a><br>
<a href="#Chapter 38.7">§ -- 38.7 -- Collect Optimizer Statistics</a><br>
<a href="#Chapter 38.8">§ -- 38.8 -- Database Key Scope And RMU/Reclaim</a><br><br>

<a href="#Chapter 39">§ -- 39 -- Database Restore And Recover</a><br>
<a href="#Chapter 40">§ -- 40 -- Verify Indices, Storage Areas And Constraints</a><br>
<a href="#Chapter 41">§ -- 41 -- Handle List Of Byte Varying Datatypes</a><br>
<a href="#Chapter 42">§ -- 42 -- Unload Data From AIJ Journal Files</a><br>
<a href="#Chapter 43">§ -- 43 -- Remote Access Over TCP/IP</a><br>
<a href="#Chapter 44">§ -- 44 -- Encrypt And Decrypt Data</a><br>
<a href="#Chapter 45">§ -- 45 -- Restart JDBC Thin Servers</a><br>
<a href="#Chapter 46">§ -- 46 -- List And Check JDBC Processes</a><br>
<a href="#Chapter 47">§ -- 47 -- List And Check JDBC Log And Trace Files</a><br>
<a href="#Chapter 48">§ -- 48 -- Extract And List JDBC Thin Server Clients</a><br>
<a href="#Chapter 49">§ -- 49 -- Cleanup JDBC Thin Server Log, Output, Trace And Restart Log Files</a><br>
<a href="#Chapter 50">§ -- 50 -- Realy Simple Java JDBC Programs</a><br><br>

<a href="#Chapter 51">§ -- 51 -- Replicate Data Using The JCC Logminer Loader</a><br><br>

<a href="#Chapter 52">§ -- 52 -- Manage JCC Logminer Loader Sessions</a><br>
<a href="#Chapter 52.1">§ -- 52.1 -- Reopen Logfiles Daily</a><br>
<a href="#Chapter 52.2">§ -- 52.2 -- Rename Logfiles</a><br>
<a href="#Chapter 52.3">§ -- 52.3 -- Shutdown Loader Sessions</a><br>
<a href="#Chapter 52.4">§ -- 52.4 -- Run Statistics Sessions</a><br>
<a href="#Chapter 52.5">§ -- 52.5 -- List And Check Processes And Logfiles</a><br>
<a href="#Chapter 52.6">§ -- 52.6 -- List And Check Statistics Sessions And Logfiles</a><br>
<a href="#Chapter 52.7">§ -- 52.7 -- List And Check Heartbeat Timestamps From CTL Logfiles</a><br>
<a href="#Chapter 52.8">§ -- 52.8 -- List And Check Heartbeat AERCP Checkpoints From LML Logfiles</a><br>
<a href="#Chapter 52.9">§ -- 52.9 -- Replicate Data Using The Data Pump Mechanism</a><br>
<a href="#Chapter 52.10">§ -- 52.10 -- Format Char(20) Originating Dbkeys</a><br>
<a href="#Chapter 52.11">§ -- 52.11 -- Dump Target Checkpoints</a><br>
<a href="#Chapter 52.12">§ -- 52.12 -- How To Exclude Deletes From Replication</a><br><br>

<a href="#Chapter 53">§ -- 53 -- List Data From A Oracle RDBMS Database</a><br><br>

<a href="#Chapter 54">§ -- 54 -- Create, Manage And Test OCI And SQL/Services Protocol Services</a><br>
<a href="#Chapter 54.1">§ -- 54.1 -- Show Services Summary</a><br>
<a href="#Chapter 54.2">§ -- 54.2 -- Show Services Full</a><br>
<a href="#Chapter 54.3">§ -- 54.3 -- Create/Start/Shutdown/Alter/Drop Services</a><br>
<a href="#Chapter 54.4">§ -- 54.4 -- OCI Protocol Services Configuration Files</a><br>
<a href="#Chapter 54.5">§ -- 54.5 -- Test A SQL/Services Protocol Service From A C Program</a><br><br>

<a href="#Chapter 55">§ -- 55 -- List And Check OCI And SQL/Services Protocol Services</a><br>
<a href="#Chapter 56">§ -- 56 -- Implement Row Cache</a><br>
<a href="#Chapter 57">§ -- 57 -- Implement Hot Standby</a><br><br>

<a href="#Chapter 58">§ -- 58 -- Database Lock Trees</a><br>
<a href="#Chapter 58.1">§ -- 58.1 -- $ MONITOR [D]LOCK</a><br>
<a href="#Chapter 58.2">§ -- 58.2 -- $ MASTERLOCK/DATABASE</a><br>
<a href="#Chapter 58.3">§ -- 58.3 -- LOCKDIRWT</a><br>
<a href="#Chapter 58.4">§ -- 58.4 -- LOCKRMWT</a><br>
<a href="#Chapter 58.5">§ -- 58.5 -- PE1</a><br>
<a href="#Chapter 58.6">§ -- 58.6 -- DEADLOCK_WAIT</a><br>
<a href="#Chapter 58.7">§ -- 58.7 -- RDMS$BIND_DEADLOCK_WAIT</a><br>
<a href="#Chapter 58.8">§ -- 58.8 -- Rdb Database Lock Resource Name</a><br><br>

<a href="#Chapter 59">§ -- 59 -- Apply Complex Logic To Generate SQL Or Data</a><br>
<a href="#Chapter 60">§ -- 60 -- Basic SQL Functionality From A External Procedure Or Subprogram</a><br>
<a href="#Chapter 61">§ -- 61 -- Bulk Delete From A C Program</a><br>
<a href="#Chapter 62">§ -- 62 -- Using Dynamic SQL</a><br>
<a href="#Chapter 63">§ -- 63 -- Using Oracle Trace For Rdb</a><br>
<a href="#Chapter 64">§ -- 64 -- Miscellaneous Utilities</a><br>
<a href="#Chapter 65">§ -- 65 -- Database And Output Files Formats</a><br>
<a href="#Chapter 66">§ -- 66 -- End CPTRDB Users Guide</a><br><br>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 2 -- Introduction
</font>
</h3>

<p> 
The Oracle Rdb Toolset of CockpitMgr for OpenVMS consists of a series
of ready to use procedures, developed by a experienced database administrator,
and now made available to fellow colleagues and the Rdb community at large. 
The procedures are general in nature and can easily be adapted to any
environment with very limited changes and editing. Monitoring procedures
are implemented using CockpitMgr events and mail messages. All procedures
are cluster aware and can be dispatched on any node in a OpenVMS cluster,
using dedicated batch queues. Many have interactive and automated batch mode
variants. They collect information on a series of nodes and/or databases in 
batch and compile the returned data into a single output file.
It is recommended to implement the recurring action and monitoring routines
stepwise one by one, become familiar with the processing and output, until 
a full featured environment is active. 
Only standard Rdb interfaces, DCL and C are used, and all formatting
of output files is done using SQL. A complete independent demonstration and test
environment is included. Started in april 2013, the release of the toolset is 
a ongoing effort and more procedures will be added over time as they 
qualify for public distribution. 
</p>

<p>
This free software is a addon to the from EuroVMS.com or previously HP Corp. 
licensed product CockpitMgr for OpenVMS although the dependency on CockpitMgr 
is limited to the single statement POKE/AGENT[/SOLUTION]. Many procedures only
require the minimum directories and logicals to be defined. Exception 
conditions are always signalled twice, using CockpitMgr events displayed in 
the CockpitMgr Event Console and mail messages.
</p>

<p>
The toolset is available to loyal and active members of the Rdb community
and the release of the full and update kits is announced on the
Oracle Rdb List Server, hosted on www.jcc.com .
</p>

The kit can be downloaded from<br>
<a href="https://github.com/LucAllemeersch/OpenVMS-Oracle-Rdb-Toolset">
https://github.com/LucAllemeersch/OpenVMS-Oracle-Rdb-Toolset</a><br>

<p>
<b>CPTRDB_COCKPITMGR_DATA_SHEET.PDF</b><br>
  Provides a condensed introduction to the CockpitMgr for OpenVMS product.
</p>

For feedback, remarks and questions on the toolset, contact 
<a href="mailto:luc.allemeersch@infrabel.be">luc.allemeersch@infrabel.be</a><br>
As of january 2020 send mail to
<a href="mailto:luc.allemeersch@eurovms.com">luc.allemeersch@eurovms.com</a><br>
<br>

For more information on CockpitMgr for OpenVMS, contact 
<a href="mailto:johan.michiels@eurovms.com">johan.michiels@eurovms.com</a>
or visit <a href="http://www.eurovms.com">www.eurovms.com</a><br><br>

For more information on Oracle Rdb, visit <a href="http://www.oracle.com/rdb">www.oracle.com/rdb</a><br>
For more information on JCC Logminer Loader, visit <a href="http://www.jcc.com">www.jcc.com</a><br>
For more information on the Oracle Rdb List Server, visit <a href="http://www.jcc.com">www.jcc.com</a><br>
For more information on OpenVMS, visit <a href="http://www.vmssoftware.com">www.vmssoftware.com</a><br><br>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 3"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 3 -- The Author
</font>
</h3>

<p>
Luc Allemeersch started his daily professional life with databases in
october 1985 at Burroughs Corp. in the presales support of the DMSII
hierarchical database and the LINC II development environment on the 'A Series'
range of systems.
After the merger of Burroughs Corp. and Sperry Corp. to create Unisys, he
joined Digital Equipment Corp. Brussels in february 1987, within the software
support group for PDP-11 systems and the RSX-11M-PLUS operating system. 
In january 1988 his support job focus changed to VAX Rdb/VMS, and has
remained so ever since. In december 1994 he was 'transfered', with the sale 
of the product, to Oracle Corp. where  he continued his Rdb support role. 
In may 1998 he left Oracle to become database administrator at Delight 
Information Systems, a online reservation application provider for the 
travel and leisure industry within the Thomas Cook Group, and first production
implementation site of CockpitMgr for OpenVMS. 
Due to the rundown (and finally closure) of this company, he moved to the 
NMBS/SNCB Group (Belgian Rail) in september 2008, where he upto december 2019
takes care of Rdb within the infrastructure management company Infrabel, 
serving the sales and ticketing department of the group.
</p>

<p>
Luc Allemeersch holds a master degree in agricultural engineering
(major plant production and protection, 1977) and completed master level
studies in computer science (major programming, 1984) both from the
'Katholieke Universiteit Leuven' (KUL), Belgium.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 4"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 4 -- License And Support
</font>
</h3>

Copyright © 2013 - 2019 Luc Allemeersch<br>

<p>
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see 
<a href="http://www.gnu.org/licenses">http://www.gnu.org/licenses</a>
</p>

<p>
<b>CPTRDB_GNU_GENERAL_PUBLIC_LICENSE.TXT</b><br>
  Contains a copy of the GNU GENERAL PUBLIC LICENSE that defines the terms
  and conditions for all use of the toolset.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 5"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 5 -- Development Environment
</font>
</h3>

<p>
The current version of the Oracle Rdb Toolset is being developed 
on HP Itanium processor servers using:
</p>

Oracle Rdb V7.2-520 (Update 3)<br>
Oracle Rdb V7.2-550<br>
Oracle Rdb V7.2-560<br>
Oracle Rdb V7.2-570<br>
Oracle Rdb V7.3-100<br>
Oracle Rdb V7.3-110<br>
Oracle Rdb V7.3-120 (Update 1)<br>
Oracle Rdb V7.3-120 (Update 2)<br>
Oracle Rdb V7.3-130<br>
Oracle Rdb V7.3-130 (Update 1)<br>
Oracle Rdb V7.3-200<br>
Oracle Rdb V7.3-200 (Update 1)<br>
Oracle Rdb V7.3-200 (Update 2)<br>
Oracle Rdb V7.3-210<br>
Oracle Rdb V7.3-210 (Update 2)<br>
Oracle Rdb V7.3-210 (Update 3)<br>
Oracle Rdb V7.3-300 (Update 1)<br>
Oracle Rdb V7.3-300 (Update 2)<br>
Oracle Rdb V7.3-310 (Update 1)<br>
Oracle Rdb JDBC V7.3-202:20130501<br>
Oracle Rdb JDBC V7.3-310:20140826<br>
Oracle Rdb JDBC V7.3-323:20141224<br>
Oracle Rdb JDBC V7.3-402:20150626<br>
Oracle Rdb JDBC V7.3-410:20160222<br>
Oracle Rdb JDBC V7.3-503:20170830<br>
Oracle Rdb JDBC V7.3-510:20180227<br>
Oracle Rdb JDBC V7.3-520:20190408<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-110<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-200<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-210<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-220<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-230<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-240<br>
Oracle SQL/Services and OCI Services For Oracle Rdb V7.4-000<br>
Oracle Trace For Rdb V7.2-03<br>
CockpitMgr for OpenVMS V7.10<br>
CockpitMgr for OpenVMS V7.11<br>
HP C V7.2-001<br>
HP Bliss V1.12-072<br>
JCC Logminer Loader V3.2.2<br>
JCC Logminer Loader V3.4.4<br>
JCC Logminer Loader V3.5.0<br>
JCC Logminer Loader V3.5.1<br>
JCC Logminer Loader V3.6.0<br>
JCC Logminer Loader V3.6.1<br>
OpenVMS Oracle Client V10.2.0.2.0<br>
OpenVMS Oracle Client V11.2.0.4.0<br>
OpenVMS JAVA V1.5.0-7<br>
OpenVMS JAVA V1.6.0-5<br>
HP OpenVMS IA64 V8.4<br>
Info-ZIP Zip V3.0<br>
Info-ZIP UnZip V6.0<br>
TlViz V2.1-0<br>
Mozilla Firefox V-Latest<br>

<p>
<hr>
The products used in this toolset require valid licenses from their 
respective owners Oracle Corp., JCC Consulting Inc., HP Corp., 
VMS Software Inc. and EuroVMS bvba.
<hr>
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 6"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 6 -- Restore The Kit
</font>
</h3>

<b>CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.ZIP</b><br>
<b>CPTRDB_CHANGES_YYYYMMDD_DDMMMHHMMSS.ZIP</b>

<a name="Chapter 6.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 6.1 -- First Full And/Or Cumulative Partial Update Kit Installation
</font>
</h3>

<p>
The Oracle Rdb Toolset full kit is shipped as a on OpenVMS zipped archive,
named CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.ZIP containing
CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.A (OpenVMS backup save set), the user guides
CPTRDB_USERS_GUIDE.[TXT|HTML], and the installation procedures
CPTRDB_TOOLSET_KITINSTAL_%.COM, CPTRDB_TOOLSET_[STOP|START]_GEN.COM and
CPTRDB_TOOLSET_SUBMIT_KITINSTAL.COM .
</p>

<p>
The kit has to be restored on a cluster wide mounted disk, in a directory 
called CPT$RDB, which is the toolset home directory where all source files 
live. Many output file categories have dedicated directories.
</p>

<p>
By convention, all source files filenames start with "CPTRDB_" or "JCCLML_".
Toolset log and output filenames never start with these prefixes. 
JCC Logminer Loader log and output filenames have specific conventions,
starting with "LML_", "JCC_RUN_", "DTL_".
</p>

Usage:<br>

<pre>
$ UNZIP CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.ZIP
$ CREATE/DIR/OWNER={toolset_user} {dev}:[CPT$RDB]
$ DEFINE/SYSTEM/EXEC CPT$RDB {dev}:[CPT$RDB]
$ BACKUP CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.A/SAVE CPT$RDB:
$ COPY CPTRDB_USERS_GUIDE.*, CPTRDB_TOOLSET_*.COM CPT$RDB:
</pre>

<p>
The Oracle Rdb Toolset cumulative partial update kit is shipped as a on
OpenVMS zipped archive, named CPTRDB_CHANGES_YYYYMMDD_DDMMMHHMMSS.ZIP containing
CPTRDB_CHANGES_YYYYMMDD_DDMMMHHMMSS.A (OpenVMS backup save set) and the user
guides CPTRDB_USERS_GUIDE.[TXT|HTML].
</p>

<p>
The cumulative partial update kit contains all the changes since the latest
full kit.
</p>

<p>
Unzip the cumulative partial update kit and restore the OpenVMS backup saveset
into the CPT$RDB_CHANGES (or other) directory for evaluation of the impact on
your environment, before copying the new source files into the runtime active
directory CPT$RDB.
</p>
 
Usage:<br>

<pre>
$ UNZIP CPTRDB_CHANGES_YYYYMMDD_DDMMMHHMMSS.ZIP
$ BACKUP CPTRDB_CHANGES_YYYYMMDD_DDMMMHHMMSS.A/SAVE CPT$RDB_CHANGES:
$ COPY CPTRDB_USERS_GUIDE.* CPT$RDB_CHANGES:
</pre>

<p>
The changes are documented in the chapter 
<a href="#Chapter 7">§ -- 7 -- Kit Updates Log</a> of the users guide.
</p>

<p>
All source files in the kits have a version number of one ";1".
</p>

<p>
The template configuration and reference files .REF, as well as the signature
file CPTRDB_SIGNATURE.TXT in the kits, have been
renamed using the procedure CPTRDB_RENAME_CDT.COM to their creation date and
time {name}_{node}_yyyymmdd.REF_ddmmmhhmmss, in order not to intervene
in the runtime active environments.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 6.2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 6.2 -- Full Kit New Version Upgrade Installation
</font>
</h3>

<p>
<b>CPTRDB_TOOLSET_STOP_GEN.COM</b><br>
<b>CPTRDB_TOOLSET_START_GEN.COM</b><br>
<b>CPTRDB_TOOLSET_KITINSTAL_1.COM</b><br>
<b>CPTRDB_TOOLSET_KITINSTAL_2.COM</b><br>
<b>CPTRDB_TOOLSET_KITINSTAL_3.COM</b><br>
<b>CPTRDB_TOOLSET_SUBMIT_KITINSTAL.COM</b>
</p>

<p>
Execute in sequence the CPTRDB_TOOLSET_KITINSTAL_%.COM procedures in this
chapter to instal a new version of the full kit.
</p>

<p>
All procedures expect the kit to be unzipped into the CPT$RDB_DATA: 
directory.<br>
All output files are created in the CPT$RDB_DATA: directory.<br>
The current reference and signature files in the CPT$RDB: directory are 
preserved.<br>
All procedures assume to be executed on the same calendar day.
</p>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_TOOLSET_STOP_GEN.COM</b><br>
  Called from CPTRDB_TOOLSET_KITINSTAL_1.COM
</p>

<p>
  Generate a command file to stop all toolset processes and batch jobs
  in the CPT$RDB_BATCH_{node} queues, listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES
</p>

<pre>
CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES|L15S29|[USERS.ALLEMEERSCH.CPT$RDB]|
CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES|L15S28|[USERS.ALLEMEERSCH.CPT$RDB]|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_BATCH_ENTRIES
! 2 Node/Queue
! 3 Source filespecs directory (sub)string
</pre>

<p>
  The output is based on the actual entries in the queues.
</p>

  Output sample:<br>

<pre>
$!
$! Generated by CPTRDB On Node L15S29 At 27-SEP-2016 10:46:08.70
$!
$ set nover
$ set noon
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$!
$ say := write sys$output
$!
$ show process
$ say " "
$!
$ @sys$share:rdb$setver 7.3
$ say " "
$!
$! -- Stop RMU/Show Statistics processes --
$ @CPT$RDB:CPTRDB_STOP_STATS Y
$!
$! -- Stop SQL/Services processes --
$ @CPT$RDB:CPTRDB_SHUTDOWN_SQLSRV
$!
$! -- Stop JCC Logminer Loader sessions and statistics --
$ @CPT$RDB:JCCLML_SHUTDOWN_ALL
$!
$! -- Stop Hot Standy replication --
$ @CPT$RDB:CPTRDB_REPLICATE_AFTER_STOP
$!
$! -- Stop batch entries --
$!
$! -- 1 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_JCC_RUN_CTL-CPTRDB_LML
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM;1
$! Entry 391
$! Executing
$! Already stopped
$!
$! -- 2 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_JCC_RUN_DTL
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_DTL.COM;1
$! /param=("CPTRDB_LML", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 420
$! Executing
$! Already stopped
$!
$! -- 3 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_SHOW_STAT_LOGS
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_LOGS.COM;2
$! /param=("CPTRDB_DB_1", -
$!         "7.3", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 993
$! Executing
$! Already stopped
$!
$! -- 4 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_SHOW_STAT_DATA
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_DATA.COM;2
$! /param=("CPTRDB_DB_1", -
$!         "7.3", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 23
$! Executing
$! Already stopped
$!
$! -- 5 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_LML_SHOW_HEARTBEAT_CONT
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_HEARTBEAT_CONT.COM;1
$! Entry 711
$! Holding until 27-SEP-2016 10:46:36.18
$ delete/entry = 711
$!
$! -- 6 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_LML_SHOW_AERCP_CONT
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_AERCP_CONT.COM;1
$! Entry 713
$! Holding until 27-SEP-2016 10:46:36.57
$ delete/entry = 713
$!
$! -- 7 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_BACKUP_AIJ_ALL
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BACKUP_AIJ_ALL.COM;1
$! Entry 791
$! Holding until 27-SEP-2016 11:07:10.44
$ delete/entry = 791
$!
...
$! -- 32 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_ANA_DBS_WEEKLY
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_ANA_DBS_WEEKLY.COM;1
$! Entry 874
$! Holding until  3-OCT-2016 04:00:00.00
$ delete/entry = 874
$!
$ set on
$ set nover
$ exit
</pre>

<p>
<b>CPTRDB_TOOLSET_START_GEN.COM</b><br>
  Called from CPTRDB_TOOLSET_KITINSTAL_1.COM
</p>

<p>
  Generate a command file to start all toolset processes and batch jobs
  in the CPT$RDB_BATCH_{node} queues, listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES
</p>

<pre>
CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES|L15S29|[USERS.ALLEMEERSCH.CPT$RDB]|
CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES|L15S28|[USERS.ALLEMEERSCH.CPT$RDB]|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_BATCH_ENTRIES
! 2 Node/Queue
! 3 Source filespecs directory (sub)string
</pre>

<p>
  The output is based on the actual entries in the queues.<br>

  It is recommended to preserve the generated command file as a precautional
  measure for later reference, in case queue and/or job information may be
  lost due to some problem or incident.<br>

  The condensed version of this command file is generated by the procedure
  CPTRDB_SUBMIT_ALL_QUEUE_GEN.COM
</p>

  Output sample:<br>

<pre>
$!
$! Generated by CPTRDB On Node L15S29 At 27-SEP-2016 10:46:18.62
$!
$ set nover
$ set noon
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$!
$ say := write sys$output
$!
$ show process
$ say " "
$!
$ @sys$share:rdb$setver 7.3
$ say " "
$!
$! -- Start RMU/Show Statistics processes --
$ @CPT$RDB:CPTRDB_SHOW_STAT_LOGS_ALL
$!
$ @CPT$RDB:CPTRDB_SHOW_STAT_DATA_ALL
$!
$! -- Start SQL/Services processes --
$ @CPT$RDB:CPTRDB_START_SQLSRV
$!
$! -- Start JCC Logminer Loader sessions and statistics --
$ @CPT$RDB:JCCLML_JCC_RUN_CTL_ALL
$!
$ @CPT$RDB:JCCLML_JCC_RUN_DTL_ALL
$!
$! -- Start Hot Standy replication --
$ @CPT$RDB:CPTRDB_REPLICATE_AFTER_START
$!
$! -- Start batch entries --
$!
$! -- 1 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_JCC_RUN_CTL-CPTRDB_LML
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM;1
$! Entry 391
$! Executing
$!
$! Already started
$!
$! -- 2 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_JCC_RUN_DTL
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_DTL.COM;1
$! /param=("CPTRDB_LML", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 420
$! Executing
$!
$! Already started
$!
$! -- 3 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_SHOW_STAT_LOGS
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_LOGS.COM;2
$! /param=("CPTRDB_DB_1", -
$!         "7.3", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 993
$! Executing
$!
$! Already started
$!
$! -- 4 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_SHOW_STAT_DATA
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_DATA.COM;2
$! /param=("CPTRDB_DB_1", -
$!         "7.3", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "", -
$!         "")
$! Entry 23
$! Executing
$!
$! Already started
$!
$! -- 5 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_LML_SHOW_HEARTBEAT_CONT
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_HEARTBEAT_CONT.COM;1
$! Entry 711
$! Holding until 27-SEP-2016 10:46:36.18
$!
$ submit/notify/noprint -
  /queue=CPT$RDB_BATCH_L15S29 -
  /user=RDBMON -
  /name=JCCLML_LML_SHOW_HEARTBEAT_CONT -
  /after="27-SEP-2016 10:46:36.18" -
  /log=CPT$RDB_JCCLML_MGR:LML_SHOW_HEARTBEAT_CONT_L15S29_20160927.LOG_27SEP104636 -
       _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_HEARTBEAT_CONT
$!
$! -- 6 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! JCCLML_LML_SHOW_AERCP_CONT
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_AERCP_CONT.COM;1
$! Entry 713
$! Holding until 27-SEP-2016 10:46:36.57
$!
$ submit/notify/noprint -
  /queue=CPT$RDB_BATCH_L15S29 -
  /user=RDBMON -
  /name=JCCLML_LML_SHOW_AERCP_CONT -
  /after="27-SEP-2016 10:46:36.57" -
  /log=CPT$RDB_JCCLML_MGR:LML_SHOW_AERCP_CONT_L15S29_20160927.LOG_27SEP104636 -
       _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_AERCP_CONT
$!
$! -- 7 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_BACKUP_AIJ_ALL
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BACKUP_AIJ_ALL.COM;1
$! Entry 791
$! Holding until 27-SEP-2016 11:07:10.44
$!
$ submit/notify/noprint -
  /queue=CPT$RDB_BATCH_L15S29 -
  /user=RDBMON -
  /name=CPTRDB_BACKUP_AIJ_ALL -
  /after="27-SEP-2016 11:07:10.44" -
  /log=CPT$RDB_LOGS:BACKUP_AIJ_ALL_L15S29_20160927.LOG_27SEP110710 -
       _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BACKUP_AIJ_ALL
$!
...
$! -- 32 --
$! CPT$RDB_BATCH_L15S29
$! RDBMON
$! CPTRDB_ANA_DBS_WEEKLY
$! _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_ANA_DBS_WEEKLY.COM;1
$! Entry 874
$! Holding until  3-OCT-2016 04:00:00.00
$!
$ submit/notify/noprint -
  /queue=CPT$RDB_BATCH_L15S29 -
  /user=RDBMON -
  /name=CPTRDB_ANA_DBS_WEEKLY -
  /after=" 3-OCT-2016 04:00:00.00" -
  /log=CPT$RDB_LOGS:ANA_DBS_WEEKLY_L15S29_20161003.LOG_03OCT040000 -
       _DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_ANA_DBS_WEEKLY
$!
$ set on
$ set nover
$ exit
</pre>

<p>
<b>CPTRDB_TOOLSET_KITINSTAL_1.COM</b><br>
Calls<br> 
CPTRDB_TOOLSET_STOP_GEN.COM<br>
CPTRDB_TOOLSET_START_GEN.COM
</p>

Phase 1<br>
  
<pre>
-- Check for minimum logicals --
-- Check for configuration file --
-- Set output filespecs node and timestamps --
-- Backup the current CPT$RDB directory --
-- Backup the current .REF and signature files --
-- Generate the SUBMIT ALL command file --
-- Generate the STOP command file --
-- Generate the START command file --
-- List the files in CPT$RDB_DATA: --
</pre>
  
  Started using:<br>

<pre>
$ set def CPT$RDB_DATA:
$ @cptrdb_toolset_submit_kitinstal {node} CPTRDB_TOOLSET_KITINSTAL_1
</pre>

<p>
<b>CPTRDB_TOOLSET_KITINSTAL_2.COM</b>
</p>

Phase 2<br>
  
<pre>
-- Set output filespecs node and timestamps --
-- Execute the STOP command file --
-- Delete the current kit --
-- List the remaining files in CPT$RDB: --
-- List the files in CPT$RDB_DATA: --
</pre>

Started using:<br>

<pre>
$ set def CPT$RDB_DATA:
$ @cptrdb_toolset_submit_kitinstal {node} CPTRDB_TOOLSET_KITINSTAL_2
</pre>

<p>
<b>CPTRDB_TOOLSET_KITINSTAL_3.COM</b>
</p>

Phase 3<br>
  
<pre>
-- Set output filespecs node and timestamps --
-- Restore the new kit --
-- Execute the START command file --
-- Check the batch entries reference file --
-- List the files in CPT$RDB_DATA: --
</pre>

Started using:<br>

<pre>
$ set def CPT$RDB_DATA:
$ @cptrdb_toolset_submit_kitinstal {node} CPTRDB_TOOLSET_KITINSTAL_3
</pre>

<p>
Usage summary:<br>
The three separate execution steps allow the verification of the intermediate 
results.
</p>

<pre>
$ UNZIP -d CPT$RDB_DATA CPTRDB_KIT_YYYYMMDD_DDMMMHHMMSS.ZIP
$ set def CPT$RDB_DATA:
$ @CPTRDB_TOOLSET_SUBMIT_KITINSTAL {node} CPTRDB_TOOLSET_KITINSTAL_1
$ @CPTRDB_TOOLSET_SUBMIT_KITINSTAL {node} CPTRDB_TOOLSET_KITINSTAL_2
$ @CPTRDB_TOOLSET_SUBMIT_KITINSTAL {node} CPTRDB_TOOLSET_KITINSTAL_3
</pre>

<p>
Adapt the batch entries reference file CPTRDB_[BATCH|SHOW]_ENTRIES.REF to the 
new version one ";1" filespecs.
</p>

<p>
 Sample filespecs in the CPT$RDB_DATA: directory after the installation:
</p>

<pre>
Directory CPT$RDB_ROOT:[DATA]

BACKUP_CPT$RDB_L15S29_20191007.BCK_07OCT131705;1
BACKUP_CPT$RDB_REF_L15S29_20191007.BCK_07OCT131705;1
CPTRDB_KIT_20191004_04OCT121913.A;1
CPTRDB_TOOLSET_KITINSTAL_1.COM;1
CPTRDB_TOOLSET_KITINSTAL_2.COM;1
CPTRDB_TOOLSET_KITINSTAL_3.COM;1
CPTRDB_TOOLSET_START_GEN.COM;1
CPTRDB_TOOLSET_STOP_GEN.COM;1
CPTRDB_TOOLSET_SUBMIT_KITINSTAL.COM;1
CPTRDB_USERS_GUIDE.HTML;1
CPTRDB_USERS_GUIDE.TXT;1
SUBMIT_ALL_QUEUE_L15S29_20191007.COM_07OCT131706;1
TOOLSET_KITINSTAL_1_L15S29_20191007.LOG_07OCT131705;1
TOOLSET_KITINSTAL_2_L15S29_20191007.LOG_07OCT132139;1
TOOLSET_KITINSTAL_3_L15S29_20191007.LOG_07OCT133658;1
TOOLSET_START_L15S29_20191007.COM_07OCT;1
TOOLSET_START_L15S29_20191007.LOG_07OCT133658;1
TOOLSET_STOP_L15S29_20191007.COM_07OCT;1
TOOLSET_STOP_L15S29_20191007.LOG_07OCT132140;1

Total of 19 files.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 7"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 7 -- Kit Updates Log
</font>
</h3>

<p>
This chapter lists the full and cumulative partial update kits in
chronological order per release.<br>

The changes per release and source file are documented here.
</p>

<p>
<b>CPTRDB_KIT_20151229_29DEC153524.A</b><br>
Full kit<br>
First Public Release
</p>

<p>
<b>CPTRDB_CHANGES_20160121_21JAN114623.A</b><br>
Partial update kit
</p>

<pre>
CPTRDB_AFTER_JOURNAL_ADD.COM (new)
CPTRDB_AFTER_JOURNAL_DROP.COM (new)
CPTRDB_COCKPITMGR_DATA_SHEET.PDF (new)
CPTRDB_INDEX_NODE_SIZES.COM (new)
CPTRDB_USERS_GUIDE.HTML
CPTRDB_USERS_GUIDE.TXT
</pre>

<p>
<b>CPTRDB_CHANGES_20160215_15FEB153602.A</b><br>
Cumulative Partial update kit
</p>

<pre>
CPTRDB_AFTER_JOURNAL_ADD.COM
CPTRDB_AFTER_JOURNAL_ALLOCATION.COM (new)
CPTRDB_AFTER_JOURNAL_DROP.COM
CPTRDB_AFTER_JOURNAL_EDIT_FILENAME.COM (new)
CPTRDB_AFTER_JOURNAL_RESERVE.COM (new)
CPTRDB_AFTER_JOURNAL_SHUTDOWN_TIMEOUT.COM (new)
CPTRDB_COCKPITMGR_DATA_SHEET.PDF
CPTRDB_DAILY.COM
CPTRDB_INDEX_NODE_SIZES.COM
CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM
CPTRDB_SHOW_SQLSRV_FULL_ONE.COM (new)
CPTRDB_USERS_GUIDE.HTML
CPTRDB_USERS_GUIDE.TXT
</pre>

<p>
<b>CPTRDB_CHANGES_20160329_29MAR161659.A</b><br>
Cumulative Partial update kit
</p>

<pre>
CPTRDB_AFTER_JOURNAL_ADD.COM
CPTRDB_AFTER_JOURNAL_ALLOCATION.COM
CPTRDB_AFTER_JOURNAL_DROP.COM
CPTRDB_AFTER_JOURNAL_EDIT_FILENAME.COM
CPTRDB_AFTER_JOURNAL_RESERVE.COM
CPTRDB_AFTER_JOURNAL_SHUTDOWN_TIMEOUT.COM
CPTRDB_BLR_TO_SQL_CONVERT.COM (new)
CPTRDB_BLR_TO_SQL_LIST.COM (new)
CPTRDB_BLR_TO_SQL_PARAMS.TXT (new)
CPTRDB_COCKPITMGR_DATA_SHEET.PDF
CPTRDB_DAILY.COM
CPTRDB_EPC_BLR_CONVERTER.EXE (new)
CPTRDB_EPC_DEMO.COM (new)
CPTRDB_EPC_DEMO_SELECTION.OPT (new)
CPTRDB_INDEX_NODE_SIZES.COM
CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM
CPTRDB_SHOW_SQLSRV_FULL_ONE.COM
CPTRDB_USERS_GUIDE.HTML
CPTRDB_USERS_GUIDE.TXT
RDBX_GLOBALS.CUSTOM (new)
RDBX_VMS_GLOBALS.INI (new)
</pre>

<p>
<b>CPTRDB_KIT_20160616_16JUN151742.A</b><br>
Full Kit
</p>

New files in this release:<br>

<pre>
(Kit installation)
CPTRDB_TOOLSET_KITINSTAL.COM
CPTRDB_TOOLSET_START_GEN.COM
CPTRDB_TOOLSET_STOP_GEN.COM

(Extract JDBC clients)
CPTRDB_SRVTRC_CLIENTS_73402.COM
CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM

(Analyze stall logs other than 'waiting for')
CPTRDB_STALL_RW_CNTS.COM
CPTRDB_STALL_RW_CNTS.RRD
CPTRDB_STALL_RW_CNTS_ALL.COM
CPTRDB_STALL_RW_CNTS_GO.COM
CPTRDB_STALL_RW_TIMES.COM
CPTRDB_STALL_RW_TIMES.RRD
CPTRDB_STALL_RW_TIMES_ALL.COM
CPTRDB_STALL_RW_TIMES_GO.COM
CPTRDB_POKE_CLEAR_STALL_RW_CNTS_EXCEED.COM
CPTRDB_POKE_CLEAR_STALL_RW_TIMES_EXCEED.COM

(Stop RMU/Show Statistics processes)
CPTRDB_STOP_STATS.COM
CPTRDB_STOP_STATS_BATCH.COM
</pre>

Renamed files:<br>

<pre>
(Run JCC Logminer Loader statistics)
From:
JCCLML_LML_RUN_STATS.COM
JCCLML_LML_RUN_STATS_ALL.COM
JCCLML_LML_RUN_STATS_GO.COM  

To:
JCCLML_JCC_RUN_DTL.COM
JCCLML_JCC_RUN_DTL_ALL.COM
JCCLML_JCC_RUN_DTL_GO.COM
</pre>

Procedures that now require entries in the configuration file:<br>

<pre>
JCCLML_JCC_RUN_CTL_ALL.COM
JCCLML_JCC_RUN_DTL_ALL.COM
JCCLML_SHUTDOWN_ALL.COM
</pre>

<p>
The reference files supplied with the kit have the format
{name}_{node}_yyyymmdd.REF_ddmmmhhmmss, renamed using the procedure
CPTRDB_RENAME_CDT.COM
</p>

<p>
The users guides CPTRDB_USERS_GUIDE.[TXT|HTML] and the kitinstal procedures
CPTRDB_TOOLSET_*.COM are NOT included in the {kitid}.A OpenVMS backup saveset,
and are only present in the {kitid}.ZIP zipped archive.
</p>

<p>
<b>CPTRDB_CHANGES_20161019_19OCT120119.A</b><br>
Partial Update Kit
</p>

<p>
Users Guide chapter changes:
</p>

<pre>
CPTRDB_USERS_GUIDE.TXT
CPTRDB_USERS_GUIDE.HTML

§ -- 14 -- Minimum Setup Requirements
§ -- 14.1 -- Getting Started
§ -- 38.7 -- Collect Optimizer Statistics
</pre>

<p>
New procedures:
</p>

<pre>
CPTRDB_SUBMIT_ALL_REF_GEN.COM
CPTRDB_SUBMIT_ALL_QUEUE_GEN.COM
(Generate a SUBMIT job statements summary, based on the entries in the 
configuration file or the execution queues) 

CPTRDB_AFTER_JOURNAL_DROP_GEN.COM
(Generate a command file to drop latent emergency live AIJ files)

CPTRDB_COLLECT_STAT_BATCH.COM
CPTRDB_COLLECT_STAT_WEEKLY.COM
(Collect optimizer statistics at regular intervals)
</pre>

<p>
Modified procedures:
</p>

<pre>
CPTRDB_SUBMIT.COM
CPTRDB_SUBMIT_SYSTEM.COM
JCCLML_SUBMIT.COM
(Add parameter /AFTER={date time})
(Do not pass {node} to procedure)

CPTRDB_SHOW_STAT_LOGS_GO.COM
CPTRDB_SHOW_STAT_LOGS.COM
CPTRDB_SHOW_STAT_DATA_GO.COM
CPTRDB_SHOW_STAT_DATA.COM
(Do not pass reschedule node)
(Reschedule on executor node)

CPTRDB_ALTER_DATABASE.COM
(Add fast commit settings)

CPTRDB_DAILY.COM
(Adapt SET [NO]ON)
(Add JOBS PENDING)
(Adapt SRVTRC_CLIENTS search)

CPTRDB_SALES_PER_MINUTE.COM
(List three data items on the same timeline)

CPTRDB_SHOW_AIJ_BCK_BATCH.COM
(Do not list dates and sizes for .AIJ_BCK files)

CPTRDB_SRVTRC_CLIENTS_73202.COM
CPTRDB_SRVTRC_CLIENTS_73202_ONE.COM
CPTRDB_SRVTRC_CLIENTS_73402.COM
CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM
CPTRDB_SRVTRC_CLIENTS_ALL.COM
(Adapt parameter order and output files format to serverid/nodeid/refdate)
(Adapt search and list out of sequence Rdb stream id's)

CPTRDB_CREATE_DIRECTORIES.COM
CPTRDB_DEFINE_LOGICALS.COM
(Exit on minimum directories and logicals)

CPTRDB_TOOLSET_KITINSTAL.COM
(Remove unzip)
(Exit after first pass)

CPTRDB_TOOLSET_STOP_GEN.COM
(List parameters)
(Call cptrdb_stop_stats)
(Add cancel on exit)

CPTRDB_TOOLSET_START_GEN.COM
(List parameters)
(Add cancel on exit)

CPTRDB_CLEANUP_LOGS_DAILY.COM
(Add CPTRDB_COLLECT)
</pre>

<p>
Procedures that now require entries in the configuration file:
</p>

<pre>
CPTRDB_SHOW_DATA_AREAS.COM
CPTRDB_SHOW_SNAPSHOT_AREAS.COM
(List data or snapshot storage area file sizes for a series of databases)
</pre>

<p>
Sample configuration file:
</p>

<pre>
CPTRDB_CONFIGURATION_L15S29_20161017.REF_17OCT160248
</pre>

<p>
<b>CPTRDB_CHANGES_20170412_12APR105319.A</b><br>
Cumulative Partial Update Kit
</p>

<p>
Users Guide chapter changes:
</p>

<pre>
CPTRDB_USERS_GUIDE.TXT
CPTRDB_USERS_GUIDE.HTML

§ -- 38.4 -- Logical Area Thresholds
(Rewrite)
§ -- 38.8 -- Database Key Scope And RMU/Reclaim
(New)
</pre>

<p>
New procedures:
</p>

<pre>
CPTRDB_RECLAIM_AREA.COM
(RMU/Reclaim one or more storage areas)

CPTRDB_CVT_FROM_HEX.COM
CPTRDB_CVT_FROM_HEX_BUILD.COM
CPTRDB_CVT_FROM_HEX_SIGNED_INT.C
CPTRDB_CVT_FROM_HEX_SIGNED_INT.EXE
CPTRDB_CVT_FROM_HEX_SIGNED_INT.OBJ
CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.C
CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.EXE
CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.OBJ

CPTRDB_CVT_TO_HEX.COM
CPTRDB_CVT_TO_HEX_BUILD.COM
CPTRDB_CVT_TO_HEX_SIGNED_INT.C
CPTRDB_CVT_TO_HEX_SIGNED_INT.EXE
CPTRDB_CVT_TO_HEX_SIGNED_INT.OBJ
CPTRDB_CVT_TO_HEX_UNSIGNED_INT.C
CPTRDB_CVT_TO_HEX_UNSIGNED_INT.EXE
CPTRDB_CVT_TO_HEX_UNSIGNED_INT.OBJ

(Convert CHAR and (un)signed INTEGER ascii strings to and from hexadecimal	
strings.) 
(In § -- 64 -- Miscellaneous Utilities)
</pre>

<p>
Modified procedures:
</p>

<pre>
CPTRDB_BACKUP_AIJ.COM
(Add logical rdm$bind_aijbck_checkpoint_timeout)

CPTRDB_SHOW_AIJ_BCK.COM
(Add optional parameters /since /before, date vms)
CPTRDB_SHOW_AIJ_BCK_BATCH.COM
CPTRDB_SHOW_AIJ_BCK_DAILY.COM

CPTRDB_SHOW_ONE_PAGE.COM
(Add search on node size)
</pre>

<p>
<b>CPTRDB_CHANGES_20170705_05JUL154304.A</b><br>
Cumulative Partial Update Kit
</p>

<p>
Modified procedures:
</p>

<pre>
CPTRDB_CVT_FROM_HEX.COM
CPTRDB_CVT_FROM_HEX_BUILD.COM
CPTRDB_CVT_TO_HEX.COM
CPTRDB_CVT_TO_HEX_BUILD.COM
(Add datatypes TIMESTAMP and BIGINT)
(In § -- 64 -- Miscellaneous Utilities)

CPTRDB_DAILY.COM
(Adapt list *.mime*)
(Add TODAY to "SHOW AIJ BCK ALL")
</pre>

<p>
New procedures:
</p>

<pre>
CPTRDB_CVT_FROM_HEX_TIMESTAMP.C
CPTRDB_CVT_FROM_HEX_TIMESTAMP.EXE
CPTRDB_CVT_FROM_HEX_TIMESTAMP.OBJ
(Add datatype TIMESTAMP)

CPTRDB_CVT_TO_HEX_TIMESTAMP.C
CPTRDB_CVT_TO_HEX_TIMESTAMP.EXE
CPTRDB_CVT_TO_HEX_TIMESTAMP.OBJ
(Add datatype TIMESTAMP)

CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.C
CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.EXE
CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.OBJ
CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.C
CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.EXE
CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.OBJ
(Add datatype BIGINT)

CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.C
CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.EXE
CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.OBJ
CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.C
CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.EXE
CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.OBJ
(Add datatype BIGINT)

CPTRDB_BUGCHECK_PROCESS.COM
CPTRDB_BUGCHECK_PROCESS_GO.COM
(Force a bugcheckdump)
</pre>

<p>
<b>CPTRDB_KIT_20171228_28DEC143047.A</b><br>
Full Kit
</p>

<p>
New Procedures:
</p>

<pre>
CPTRDB_TOOLSET_KITINSTAL_1.COM
CPTRDB_TOOLSET_KITINSTAL_2.COM
CPTRDB_TOOLSET_KITINSTAL_3.COM
CPTRDB_TOOLSET_SUBMIT_KITINSTAL.COM
(Full kit new version upgrade installation)
</pre>

<pre>
CPTRDB_SET_SERVER_LOGS.COM
CPTRDB_RESET_SERVER_LOGS.COM
(Set/Reset per database server processes logfiles output filespecs)
(Now implemented for the toolset databases)
</pre>

<pre>
CPTRDB_SHOW_AIJ_BCK_NOEXP.COM
CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM
CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM
CPTRDB_POKE_CLEAR_AIJ_NOT_EXP_BACKUPS.COM
(List not expired AIJ backup files)
</pre>

<p>
Modified Procedures:
</p>

<pre>
CPTRDB_CREATE_DB.COM
(Call CPTRDB_SET_SERVER_LOGS.COM)

CPTRDB_CREATE_DB_AIJ.COM
(Remove RMU/Set Server/Output)

CPTRDB_CLEANUP_LOGS_DAILY.COM
(Clean CPT$RDB_SRV_LOGS: directory)
(Add clean SHOW_AIJ_BCK_NOEXP)

CPTRDB_DAILY.COM
(Add search SHOW_AIJ_BCK_NOEXP)

CPTRDB_RESTART_JDBC.COM
CPTRDB_JAVA_JDBC_BUILD.COM
CPTRDB_JAVA_JDBC_RUN.COM
CPTRDB_SHOW_THIN_CLIENTS_BATCH.COM
(Adapt to JDBC V73503 and versioned JAVA V6 .JAR files in java$classpath)

CPTRDB_SRVTRC_CLIENTS_73402.COM
CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM
(Add compatible V73503 comment)

JCCLML_LML_CREATE_FILTER_DB.COM
(Define logical JCCLML_FILTER_DB)

CPTRDB_SHOW_AIJ_BCK.COM
CPTRDB_SHOW_AIJ_BCK_DAILY.COM
(Make P1 /since mandatory)
(Add /since /before to output file header)
CPTRDB_SHOW_AIJ_BCK_BATCH.COM
(Handle no AIJ backup files found)

CPTRDB_RDM$BUGCHECK_IGNORE_FLAGS.COM
(Document more flags)
</pre>

<p>
<b>CPTRDB_CHANGES_20180420_20APR143123.A</b><br>
Partial Update Kit
</p>

<p>
Running On New Versions
</p>

<pre>
Oracle Rdb          V7.3-210 Update 3
Oracle Rdb JDBC     V7.3-510
JCC Logminer Loader V3.5.1
</pre>

<p>
New Procedures:
</p>

<pre>
CPTRDB_SHOW_ENTRIES_BATCH.COM
CPTRDB_SHOW_ENTRIES.COM
CPTRDB_SHOW_ENTRIES.REF
CPTRDB_SHOW_ENTRIES_DAILY.COM
CPTRDB_POKE_CLEAR_SHOW_ENTRIES_DIFF.COM
(List and check batch entries for multipe nodes, users, queues and source directories)

CPTRDB_SHOW_DOMAINS.COM
(List all domains and their usage)

JCCLML_CPTRDB_CONFIGURATION.REF
(Template configuration file for a JCC Logminer Loader ONLY environment)

JCCLML_CPTRDB_DAILY.COM;
(Interactive check for a JCC Logminer Loader ONLY environment
</pre>

<p>
Modified Procedures:
</p>

<pre>
CPTRDB_CLEANUP_LOGS_DAILY.COM
(Add CPTRDB_SHOW_ENTRIES)

CPTRDB_DAILY.COM
(Add CPTRDB_SHOW_ENTRIES)
(Call CPTRDB_SHOW_AIJ_BCK /since /before)

CPTRDB_SRVTRC_CLIENTS_ALL.COM
CPTRDB_SRVTRC_CLIENTS_73402.COM
CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM
(Add comment compatible JDBC V73510)

CPTRDB_BATCH_ENTRIES_DAILY.COM
(Avoid .tmp_ref delete if using same directory for 'tmpdir' and 'defdir')

CPTRDB_SHOW_AIJ_BCK_DAILY.COM
CPTRDB_SHOW_DBS_OPEN_DAILY.COM
CPTRDB_SHOW_DB_BCK_DAILY.COM
CPTRDB_SHOW_JDBC_LOGS_DAILY.COM
CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM
CPTRDB_SHOW_SQLSRV_DAILY.COM
CPTRDB_SHOW_STATS_DAILY.COM
JCCLML_LML_SHOW_AERCP_CONT.COM
JCCLML_LML_SHOW_HEARTBEAT_CONT.COM
JCCLML_LML_SHOW_PROCESS_DAILY.COM
JCCLML_LML_SHOW_STATS_DAILY.COM
(Avoid .tmp_ref delete if using same directory for 'tmpdir' and 'outdir')

JCCLML_FILTER_DB_LOGICALS.COM
(Add DEFINE JCCLML_FILTER_DB database)

JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM
JCCLML_JCC_RUN_DTL.COM
JCCLML_LML_DATA_PUMP_CPTRDB_LML.COM
JCCLML_LML_DUMP_CHECKPOINT_OCI.COM
JCCLML_LML_DUMP_CHECKPOINT_RDB.COM
JCCLML_LML_REOPEN_LOGS.COM
JCCLML_SHUTDOWN.COM
(Add "$ @jcc_tool_com:jcc_lml_user s" in preparation for multiversion V3.6)
</pre>

<p>
<b>CPTRDB_CHANGES_20181024_24OCT142127.A</b><br>
Cumulative Partial Update Kit
</p>

<p>
Running On New Version:
</p>

<pre>
Oracle Rdb V7.3-300 Update 1
</pre>

<p>
New Procedures:
</p>

<pre>
CPTRDB_JDBC_TRC_LIST_CLIENTS.COM
CPTRDB_JDBC_TRC_LIST_SQL.COM
CPTRDB_JDBC_TRC_LIST_TIME.COM
CPTRDB_JDBC_TRC_LIST_TRANS.COM
(Analyze Rdb JDBC level 0X40000400 'server actions' trace files)

CPTRDB_ALL_DATATYPES_CREATE.COM
(Recreate the ALL_DATATYPES table with datatypes [VAR]BINARY)
</pre>

<p>
Modified Procedures:
</p>

<pre>
CPTRDB_COCKPITMGR_DATA_SHEET.PDF
(Refer to www.EuroVMS.com)

CPTRDB_BACKUP_DB_ALL.COM
(Use char(13) dbidlog in say logfile one database)

CPTRDB_BATCH_ENTRIES.COM
CPTRDB_BATCH_ENTRIES_DAILY.COM
(Mark as deprecated)

CPTRDB_DAILY.COM
(Add check on COLLECT_STAT)
(Adapt deadlocks/stalls check)
(Add cpt$rdb_jdbc_thindir:*.mime*)

CPTRDB_POKE_CLEAR_AIJ_NOT_EXP_BACKUPS.COM
(Adapt /SOLUTION text)

CPTRDB_SHOW_EXTENTS_BATCH.COM
CPTRDB_SHOW_EXTENTS.COM
CPTRDB_SHOW_EXTENTS_DAILY.COM
(Add nodeid to renamed .SIZE, .DIFF files)
(Adapt per database return file parameter)
(Add debugging statements as comment)

CPTRDB_SHOW_STATS.COM
CPTRDB_SHOW_STATS_DAILY.COM
CPTRDB_STOP_STATS.COM
(Correct node name mixup if listing multiple nodes)

CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM
CPTRDB_SHOW_STATS_BATCH.COM
CPTRDB_SHOW_STATS_DAILY.COM
CPTRDB_STOP_STATS_BATCH.COM
JCCLML_LML_SHOW_PROCESS_DAILY.COM
JCCLML_LML_SHOW_STATS_DAILY.COM
(Add process states RWINS, RWCLU to identify process line)

CPTRDB_ALL_DATATYPES_INSERT.COM
CPTRDB_SHOW_TABLES.COM
(Add datatypes [VAR]BINARY, Adapt RAW(nn) )

CPTRDB_STALL_RW_CNTS.COM
CPTRDB_STALL_RW_TIMES.COM
(Add more not 'waiting for' stall messages)

CPTRDB_CONFIGURATION_L15S29_20181024.REF_24OCT122907
CPTRDB_SHOW_ENTRIES_L15S29_20181024.REF_24OCT123146
(Renamed template toolset configuration and ENTRIES reference files)
</pre>

<p>
<b>CPTRDB_CHANGES_20190130_30JAN144135.A</b><br>
Cumulative Partial Update Kit
</p>

<p>
Running On New Versions:
</p>

<pre>
OpenVMS Oracle Client V11.2.0.4.0
</pre>

<p>
New Procedures:
</p>

<pre>
JCCLML_DUMP_CHECKPOINT_BATCH.COM
JCCLML_DUMP_CHECKPOINT.COM
JCCLML_LML_DUMP_CHECKPOINT_CON.COM
JCCLML_DUMP_CHECKPOINT_L15S29_20181129.REF_29NOV124536 (Renamed reference file)
CPTRDB_POKE_CLEAR_JCCLML_CHECKPT_DIFF.COM
(List and inspect checkpoint realtime delays in target databases)
(Chapter 52.11)

JCCLML_LML_CLEANUP_LOGS_DAILY.COM
(Catchall cleanup in JCCLML only environment)
</pre>

<p>
Modified Procedures:
</p>

<pre>
CPTRDB_DAILY.COM
JCCLML_CPTRDB_DAILY.COM (Use CPT$RDB locations)
(Add JCCLML_DUMP_CHECKPOINT)

CPTRDB_CLEANUP_LOGS_DAILY.COM
(Add LML_DUMP_CHECKPOINT)

JCCLML_LML_DUMP_CHECKPOINT_OCI.COM
JCCLML_LML_DUMP_CHECKPOINT_RDB.COM
(Mark as deprecated)

CPTRDB_SHOW_USERS.COM
(Correct "No active users")

JCCLML_LML_SHOW_STATS_DAILY.COM
(Remove compress in create .tmp_ref, loader names < char(11) )

CPTRDB_CONFIGURATION_L15S29_20190118.REF_18JAN163051
JCCLML_CPTRDB_CONFIGURATION_L15S29_2019.REF_17JAN162359
(Add JCCLML_DUMP_CHECKPOINT)
(Renamed toolset configuration and parameter files)

CPTRDB_SHOW_ENTRIES_L15S29_20181207.REF_07DEC120227
(Renamed CPTRDB_SHOW_ENTRIES reference file)
</pre>

<p>
<b>CPTRDB_KIT_20191004_04OCT121913.A</b><br>
Full Kit
</p>

<p>
Running On New Versions:
</p>

<pre>
Oracle Rdb V7.3-300 Update 2
Oracle Rdb V7.3-310 Update 1

Oracle Rdb JDBC V7.3-520

Oracle SQL/Services and OCI Services For Oracle Rdb V7.3-240
Oracle SQL/Services and OCI Services For Oracle Rdb V7.4-000

JCC Logminer Loader V3.6.0
JCC Logminer Loader V3.6.1
</pre>

<p>
New Procedures:
</p>

<pre>
JCCLML_DUMP_CHECKPOINT_ONE.COM
(Dump checkpoint for one loader session)

CPTRDB_CALENDAR_GEN.COM
(Generate a calendar file between two dates)

CPTRDB_UNLOAD_GEN.COM
(Generate RMU/Unload statements for all user tables)

CPTRDB_LOAD_GEN.COM
(Generate RMU/Load statements for all user tables)

JCCLML_JCC_RUN_LML.COM
(Adapt the process name of the LML process)
</pre>

<p>
Modified Procedures:
</p>

<pre>
JCCLML_DUMP_CHECKPOINT.COM
(List expected loaders)

JCCLML_DUMP_CHECKPOINT_BATCH.COM
  (Handle timestamp in the future/negative delta time)
JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM
JCCLML_JCC_RUN_DTL.COM
JCCLML_LML_DATA_PUMP_CPTRDB_LML.COM
JCCLML_LML_DUMP_CHECKPOINT_CON.COM
JCCLML_LML_DUMP_CHECKPOINT_OCI.COM
JCCLML_LML_DUMP_CHECKPOINT_RDB.COM
JCCLML_LML_REOPEN_LOGS.COM
JCCLML_SHUTDOWN.COM
(Adapt to JCCLML V361 multiversion)

JCCLML_RENAME_LOGFILES.COM
(Add SET NOON)

JCCLML_FILTER_DB_LOGICALS.COM
JCCLML_LML_CREATE_FILTER_DB.COM
(Define logical JCCLML_FILTER_DB_ROOT)

CPTRDB_DAILY.COM
JCCLML_CPTRDB_DAILY.COM
(Adapt search on checkpoint delay for timestamp in the future)

CPTRDB_CREATE_MASTR_DB_AIJ.COM
(Call CPTRDB_SET_SERVER_LOGS.COM)

CPTRDB_SRVTRC_CLIENTS_73402.COM
CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM
CPTRDB_SRVTRC_CLIENTS_ALL.COM
(Add comment compatible JDBC V73520)

CPTRDB_JDBC_TRC_LIST_CLIENTS.COM
CPTRDB_JDBC_TRC_LIST_SQL.COM
CPTRDB_JDBC_TRC_LIST_TIME.COM
CPTRDB_JDBC_TRC_LIST_TRANS.COM
(Adapt to JDBC V73520 trace file format)

CPTRDB_TOOLSET_KITINSTAL_1.COM
CPTRDB_TOOLSET_KITINSTAL_2.COM
CPTRDB_TOOLSET_KITINSTAL_3.COM
CPTRDB_TOOLSET_START_GEN.COM
CPTRDB_TOOLSET_STOP_GEN.COM
CPTRDB_TOOLSET_SUBMIT_KITINSTAL.COM
(Code review)
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 8"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 8 -- Configuration And Parameter File
</font>
</h3>

<b>CPTRDB_CONFIGURATION.REF</b><br>

<p>
In order to achieve the longterm goal of completely eliminating any
hardcoded settings and parameters (grouped at the beginning of a procedure)
a configuration and parameter file is provided. 

Along with this change the use of the output directories
CPT$RDB_[TMP|LOGS|LISTS|DATA|JCCLML_MGR] is being introduced.

The individual lines of the configuration file, based on keywords, 
determine which nodes, Rdb versions and databases, participate in 
which toolset operations.

The file also provides runtime parameters for a number of procedures,
as well as (re)scheduling input data.
</p>

The keywords are:<br>
CPT$RDB_DATABASE, database related data<br>
CPT$RDB_NODE,     node related data<br>
CPT$RDB_JOB,      job related data<br>
CPT$RDB_PARAM,    procedure runtime parameters<br>

<p>
The semantics are listed per (group of) line(s) within the file and
in the individual chapters of the users guide.

The toolset automated procedures runtime determine their individual actions by
reading this file.

Comments lines start with char(1) '!' in the first column.

Adapt the actions in the configuration file to your environment as each 
feature is being implemented. Use the procedure CPTRDB_RENAME_CDT.COM to 
rename a file to its creation timestamp and save a specific version of the 
configuration file.

The template configuration file CPTRDB_CONFIGURATION_TEMPLATE.REF can also
be used as a starting point. Refer to the chapter 
<a href="#Chapter 14.1">§ -- 14.1 -- Getting Started</a> for more details.
</p>

Configuration file entry sample:<br>

<pre>
! -- Run database backup
CPT$RDB_DATABASE|CPTRDB_BACKUP_DB|CPTRDB_DB_1|7.3|L15S29|
CPT$RDB_DATABASE|CPTRDB_BACKUP_DB|CPTRDB_MASTR_DB|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_BACKUP_DB
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

<p>
Procedures reading the configuration file CPTRDB_CONFIGURATION.REF :
</p>

<pre>
  CPTRDB_ALTER_SQLSRV.COM
  CPTRDB_ANA_DBS_WEEKLY.COM
  CPTRDB_BACKUP_AIJ.COM
  CPTRDB_BACKUP_AIJ_ALL.COM
  CPTRDB_BACKUP_DB.COM
  CPTRDB_BACKUP_DB_ALL.COM
  CPTRDB_BATCH_ENTRIES.COM
  CPTRDB_BATCH_ENTRIES_DAILY.COM
  CPTRDB_CLEANUP_JDBC_LOGS.COM
  CPTRDB_CLEANUP_JDBC_LOGS_ALL.COM
  CPTRDB_CLEANUP_LOGS_DAILY.COM
  CPTRDB_COLLECT_STAT_WEEKLY.COM
  CPTRDB_CREATE_SQLSRV.COM
  CPTRDB_DDLCK_CNTS_ALL.COM
  CPTRDB_DROP_SQLSRV.COM
  CPTRDB_RESTART_JDBC.COM
  CPTRDB_RESTART_JDBC_ALL.COM
  CPTRDB_SHOW_AIJ_BCK.COM
  CPTRDB_SHOW_AIJ_BCK_BATCH.COM
  CPTRDB_SHOW_AIJ_BCK_DAILY.COM
  CPTRDB_SHOW_AIJ_BCK_NOEXP.COM
  CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM
  CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM
  CPTRDB_SHOW_AIJ_LIVE.COM
  CPTRDB_SHOW_AIJ_LIVE_DAILY.COM
  CPTRDB_SHOW_BUGCHECK.COM
  CPTRDB_SHOW_BUGCHECK_DAILY.COM
  CPTRDB_SHOW_DATA_AREAS.COM
  CPTRDB_SHOW_DBS_OPEN.COM
  CPTRDB_SHOW_DBS_OPEN_BATCH.COM
  CPTRDB_SHOW_DBS_OPEN_DAILY.COM
  CPTRDB_SHOW_DB_BCK.COM
  CPTRDB_SHOW_DB_BCK_BATCH.COM
  CPTRDB_SHOW_DB_BCK_DAILY.COM
  CPTRDB_SHOW_ENTRIES.COM
  CPTRDB_SHOW_ENTRIES_DAILY.COM
  CPTRDB_SHOW_EXTENTS.COM
  CPTRDB_SHOW_EXTENTS_DAILY.COM
  CPTRDB_SHOW_JDBC_LOGS.COM
  CPTRDB_SHOW_JDBC_LOGS_BATCH.COM
  CPTRDB_SHOW_JDBC_LOGS_DAILY.COM
  CPTRDB_SHOW_JDBC_PROCESS.COM
  CPTRDB_SHOW_JDBC_PROCESS_BATCH.COM
  CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM
  CPTRDB_SHOW_SNAPSHOT_AREAS.COM
  CPTRDB_SHOW_SQLSRV_DAILY.COM
  CPTRDB_SHOW_SQLSRV_FULL.COM
  CPTRDB_SHOW_SQLSRV_SUMMARY.COM
  CPTRDB_SHOW_STATS.COM
  CPTRDB_SHOW_STATS_BATCH.COM
  CPTRDB_SHOW_STATS_DAILY.COM
  CPTRDB_SHOW_STAT_DATA_ALL.COM
  CPTRDB_SHOW_STAT_LOGS_ALL.COM
  CPTRDB_SHOW_THIN_CLIENTS_BATCH.COM
  CPTRDB_SHUTDOWN_SQLSRV.COM
  CPTRDB_SRVTRC_CLIENTS_73202.COM
  CPTRDB_SRVTRC_CLIENTS_73402.COM
  CPTRDB_SRVTRC_CLIENTS_ALL.COM
  CPTRDB_STALL_CNTS_ALL.COM
  CPTRDB_STALL_RW_CNTS_ALL.COM
  CPTRDB_STALL_RW_TIMES_ALL.COM
  CPTRDB_STALL_TIMES_ALL.COM
  CPTRDB_START_SQLSRV.COM
  CPTRDB_STOP_STATS.COM
  CPTRDB_STOP_STATS_BATCH.COM
  CPTRDB_SUBMIT_ALL_QUEUE_GEN.COM
  CPTRDB_SUBMIT_ALL_REF_GEN.COM
  CPTRDB_THINSRV$STARTUP.COM
  CPTRDB_TOOLSET_START_GEN.COM
  CPTRDB_TOOLSET_STOP_GEN.COM
  CPTRDB_TRNC_SNAPS_ALL.COM
  CPTRDB_TRNC_SNAPS_STOP.COM

  JCCLML_DUMP_CHECKPOINT.COM
  JCCLML_DUMP_CHECKPOINT_BATCH.COM
  JCCLML_DUMP_CHECKPOINT_ONE.COM
  JCCLML_JCC_RUN_CTL_ALL.COM
  JCCLML_JCC_RUN_DTL_ALL.COM
  JCCLML_LML_CLEANUP_LOGS_DAILY.COM
  JCCLML_LML_DUMP_CHECKPOINT_CON.COM
  JCCLML_LML_REOPEN_LOGS_ALL.COM
  JCCLML_LML_SHOW_AERCP_CONT.COM
  JCCLML_LML_SHOW_HEARTBEAT_CONT.COM
  JCCLML_LML_SHOW_PROCESS_DAILY.COM
  JCCLML_LML_SHOW_STATS_DAILY.COM
  JCCLML_SHOW_AERCP.COM
  JCCLML_SHOW_AERCP_BATCH.COM
  JCCLML_SHOW_HEARTBEAT.COM
  JCCLML_SHOW_HEARTBEAT_BATCH.COM
  JCCLML_SHOW_PROCESS.COM
  JCCLML_SHOW_STATS.COM
  JCCLML_SHUTDOWN_ALL.COM
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 9"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 9 -- Reference Files
</font>
</h3>

<b>
CPTRDB_BATCH_ENTRIES.REF<br>
CPTRDB_SHOW_AIJ_BCK.REF<br>
CPTRDB_SHOW_DBS_OPEN.REF<br>
CPTRDB_SHOW_DB_BCK.REF<br>
CPTRDB_SHOW_ENTRIES.REF<br>
CPTRDB_SHOW_JDBC_LOGS.REF<br>
CPTRDB_SHOW_JDBC_PROCESS.REF<br>
CPTRDB_SHOW_SQLSRV.REF<br>
CPTRDB_SHOW_STATS.REF<br><br>

JCCLML_DUMP_CHECKPOINT.REF<br>
JCCLML_SHOW_AERCP.REF<br>
JCCLML_SHOW_HEARTBEAT.REF<br>
JCCLML_SHOW_PROCESS.REF<br>
JCCLML_SHOW_STATS.REF<br>
</b>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The reference files contain the fixed 'expected' output data of repeating
check and monitoring procedures. On each run, an extract of the actual output
data is compared to the reference file. If a mismatch is detected, a mail 
and CockpitMgr event message are sent. This double notification across the
toolset, also for procedures where no reference file is involved, should assure
that no exception conditions are overlooked.

The reference files can easily be constructed from the output of the interactive
variant of a procedure, or from the very first run results.

The .TMP_REF files in CPT$RDB_LISTS: created by the CPTRDB*_DAILY or 
JCCLML*_CON[T] jobs contain the actual most recent (un)valid built reference 
file.

To test an exception condition and force a CockpitMgr event and notification
mail, add a junk textline to the reference file and rerun the procedure. 
</p>

Reference file sample:<br>
CPTRDB_SHOW_AIJ_BCK.REF<br>
(List distinct today's AIJ backup files)<br>

<pre>
On Node L15S29
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
CPTRDB_DB_1_L15S29
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
CPTRDB_MASTR_L15S29
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 10"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 10 -- CockpitMgr for OpenVMS Oracle Rdb Events
</font>
</h3>

<p>
This chapter lists the Oracle Rdb events displayed by the CockpitMgr Event 
Console.
</p>

<p>
The event names created by the toolset start with "CPTRDB_", while the
events created on standard Rdb opcom messages and captured, matched, displayed 
and cleared by CockpitMgr, start with "RDB_".
</p>

<p>
The databases must have the setting "NOTIFY ENABLED", activated using:
</p>

<pre>
SQL> ALTER DATABASE FILENAME {dbid}
     NOTIFY ENABLED ( ALERT OPERATOR CENTRAL + CLUSTER );
</pre>

<p>
Event names and their scan profile matching strings, generated by CockpitMgr 
on standard Oracle Rdb opcom messages:  
</p>

<pre>
  RDB_AIJ_BackupCompleted      "AIJ backup operation completed*"
  RDB_AIJ_BackupStarted        "AIJ backup operation started*"
  RDB_AIJ_EMERGENCY            "Created emergency AIJ journal*"
  RDB_AIJ_MANUAL_BACKUP_FAILED "AIJ manual backup operation failed"
  RDB_AIJ_NEW                  "New AIJ journal must be added*"
  RDB_AIJ_NOTIF_ACT            "after-image journal operator notification has been activated*"
  RDB_AIJ_OPEN_ERROR           "Error opening AIJ *"
  RDB_AIJ_Opening              "Opening *.AIJ;*"
  RDB_AIJ_SHUTDOWN             "After-image journaling is being shutdown with hard data loss*"
  RDB_AIJ_SHUTDOWN_REASON      "AIJ shutdown reason: journal has been possibly deleted or moved*"
  RDB_AIJ_SwitchOverComplete   "After-image journal switch-over complete*"
  RDB_AIJ_SwitchOverInProgress "After-image journal * switch-over in progress*"
  RDB_ALS_FAILED2              "Oracle Rdb * AIJ Log Server process failed for database*"
  RDB_ALS_STOP                 "AIJ Log Server (ALS) terminated"
  RDB_ALS_ServerFailed         "AIJ Log Server server failed.*"
  RDB_ALS_Started              "AIJ Log Server (ALS) started"
  RDB_BugCheck                 "Process * generating bugcheck dump file"
  RDB_CANTREADDBS              "-RDMS-F-CANTREADDBS*"
  RDB_LAST_AIJ_FULL            "Last active AIJ journal is * full"
  RDB_LAST_UNMOD_AIJ           "Last unmodified AIJ journal has been selected*"
  RDB_LCS_START                "AIJ Log Catch-Up Server started*"
  RDB_LCS_STOP                 "AIJ Log Catch-Up Server terminated*"
  RDB_LONG_LASTING_TRANSACTION "Process * exceeded *-second transaction duration*"
  RDB_LRS_START                "AIJ Log Roll-Forward Server started*"
  RDB_LRS_STOP                 "AIJ Log Roll-Forward Server terminated*"
  RDB_MONITOR_START            "Oracle Rdb monitor * started*"
  RDB_MonitorShutdown          "Shutting down the Oracle Rdb monitor*"
  RDB_NOMORE_AIJ               "No more available AIJ journals*"
  RDB_PAGE_CORRUPT             "Page *:* added to Corrupt Page Table by process *"
  RDB_RCS_START                "Row Cache Server started*"
  RDB_StallExceeded            "Process * exceeded * second stall: *"
  RDB_StorageAreaExtending     "Storage area * extending by * disk blocks*"
</pre>

Event names and their event text generated by the Oracle Rdb Toolset:<br>

<pre>
  CPTRDB_AIJ_BackupFailed 
  "CPTRDB - Database {rootid} - AIJ Backup Failed - ddmmmhhmmss"

  CPTRDB_AIJ_BackupsDifferences
  "CPTRDB - AIJ Backups Differences {node} - ddmmmhhmmss"

  CPTRDB_AIJ_LiveExceptions
  "CPTRDB - AIJ Live Exceptions {node} - ddmmmhhmmss"

  CPTRDB_AIJ_NotExpiredBackups
  "CPTRDB - AIJ Not Expired Backups {node} - ddmmmhhmmss"

  CPTRDB_BatchEntriesDifferences
  "CPTRDB - Batch Entries Differences {node} - ddmmmhhmmss"

  CPTRDB_BugcheckDumpsFound
  "CPTRDB - Bugcheck Dumps Found {node} - ddmmmhhmmss"

  CPTRDB_DB_BackupFailed
  "CPTRDB - Database {rootid} - DB Backup Failed - ddmmmhhmmss"

  CPTRDB_DB_BackupStarted
  "CPTRDB - Database {rootid} - DB Backup Started - ddmmmhhmmss"

  CPTRDB_DB_BackupsDifferences
  "CPTRDB - Database Backups Differences {node} - ddmmmhhmmss"

  CPTRDB_DB_RecoverFailed
  "CPTRDB - Database {rootid} - Recover Failed - ddmmmhhmmss"

  CPTRDB_DB_RecoverStarted
  "CPTRDB - Database {rootid} - Recover Started - ddmmmhhmmss"

  CPTRDB_DB_RestoreFailed
  "CPTRDB - Database {rootid} - Restore Failed - ddmmmhhmmss"

  CPTRDB_DB_RestoreStarted
  "CPTRDB - Database {rootid} - Restore Started - ddmmmhhmmss"

  CPTRDB_DeadlockCntsExceeded
  "CPTRDB - Deadlock Cnts Exceeded {dbid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_ExtentsFound
  "CPTRDB - Extents Found {node} - ddmmmhhmmss"

  CPTRDB_JCCLML_AercpDiff
  "CPTRDB - JCCLML Aercp Diff {node} - ddmmmhhmmss"

  CPTRDB_JCCLML_CheckpointDiff
  "CPTRDB - JCCLML Checkpoint Diff {node} - ddmmmhhmmss"

  CPTRDB_JCCLML_HeartbeatDiff
  "CPTRDB - JCCLML Heartbeat Diff {node} - ddmmmhhmmss"

  CPTRDB_JCCLML_ProcessDiff
  "CPTRDB - JCCLML Process Diff {node} - ddmmmhhmmss"

  CPTRDB_JCCLML_StatsDiff
  "CPTRDB - JCCLML Stats Diff {node} - ddmmmhhmmss"

  CPTRDB_JDBC_LogfilesDifferences
  "CPTRDB - JDBC Logfiles Differences {node} - ddmmmhhmmss"

  CPTRDB_JDBC_ProcessDifferences
  "CPTRDB - JDBC Process Differences {node} - ddmmmhhmmss"

  CPTRDB_JDBC_RestartStarted
  "CPTRDB - JDBC Restart Started {node} - ddmmmhhmmss"

  CPTRDB_OpenDatabasesDifferences
  "CPTRDB - Open Databases Differences {node} - ddmmmhhmmss"

  CPTRDB_ShowEntriesDifferences
  "CPTRDB - Show Entries Differences {node} - ddmmmhhmmss"

  CPTRDB_SQLSRV_Differences
  "CPTRDB - SQLSRV Differences {node} - ddmmmhhmmss"

  CPTRDB_SRVTRC_NoClients
  "CPTRDB - SRVTRC No Clients {servid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_StallCntsExceeded
  "CPTRDB - Stall Cnts Exceeded {dbid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_StallRwCntsExceeded
  "CPTRDB - Stall R/W Cnts Exceeded {dbid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_StallRwTimesExceeded
  "CPTRDB - Stall R/W Times Exceeded {dbid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_StallTimesExceeded
  "CPTRDB - Stall Times Exceeded {dbid} {node} yyyymmdd - ddmmmhhmmss"

  CPTRDB_StatisticsDifferences
  "CPTRDB - Statistics Differences {node} - ddmmmhhmmss"

  CPTRDB_TruncSnapsStopped
  "CPTRDB - Database {rootid} - Trunc Snaps Stopped - ddmmmhhmmss"
</pre>

Mail subjects issued by the Oracle Rdb Toolset:<br>

<pre>
  "CPTRDB - AIJ Backup Failed {dbid} {nodeid} yyyymmdd"
  "CPTRDB - AIJ Backups Diff {nodeid} yyyymmdd"
  "CPTRDB - AIJ Live Exceptions {nodeid} yyyymmdd"
  "CPTRDB - AIJ Not Expired Backups {nodeid} yyyymmdd"
  "CPTRDB - Batch Entries Diff {nodeid} yyyymmdd"
  "CPTRDB - Bugcheck Dumps Found {nodeid} yyyymmdd"
  "CPTRDB - DB Backup Failed {dbid} {nodeid} yyyymmdd"
  "CPTRDB - DB Backups Diff {nodeid} yyyymmdd"
  "CPTRDB - DB Recover Failed {dbid} {nodeid} yyyymmdd"
  "CPTRDB - DB Restore Failed {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Deadlock Cnts Exceeded {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Extents Found {nodeid} yyyymmdd"
  "CPTRDB - JCCLML AERCP Diff {nodeid} yyyymmdd"
  "CPTRDB - JCCLML Checkpoint Diff {nodeid} yyyymmdd"
  "CPTRDB - JCCLML Heartbeat Diff {nodeid} yyyymmdd"
  "CPTRDB - JCCLML Process Diff {nodeid} yyyymmdd"
  "CPTRDB - JCCLML Stats Diff {nodeid} yyyymmdd"
  "CPTRDB - JDBC Logfiles Diff {nodeid} yyyymmdd"
  "CPTRDB - JDBC Processes Diff {nodeid} yyyymmdd"
  "CPTRDB - Open Databases Diff {nodeid} yyyymmdd"
  "CPTRDB - Show Entries Diff {nodeid} yyyymmdd"
  "CPTRDB - SQLSRV Diff {nodeid} yyyymmdd"
  "CPTRDB - SRVTRC No Clients {servid} {nodeid} yyyymmdd"
  "CPTRDB - Stall Cnts Exceeded {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Stall R/W Cnts Exceeded {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Stall R/W Times Exceeded {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Stall Times Exceeded {dbid} {nodeid} yyyymmdd"
  "CPTRDB - Statistics Diff {nodeid} yyyymmdd"
  "CPTRDB - Trunc Snaps Stopped {dbid} {nodeid} yyyymmdd"
</pre>

<p>
The dependency of the toolset on CockpitMgr is limited to the single
statement POKE/AGENT[/SOLUTION] which is used in the procedures listed 
below. Note that exception conditions are always signalled twice using
CockpitMgr events displayed in the event console and mail messages. 
</p>

Toolset procedures using POKE/AGENT:<br>

<pre>
  CPTRDB_BACKUP_AIJ.COM
  CPTRDB_BACKUP_DB.COM
  CPTRDB_BATCH_ENTRIES_DAILY.COM
  CPTRDB_DDLCK_CNTS.COM
  CPTRDB_POKE_CLEAR_AIJ_BACKUPS_DIFF.COM
  CPTRDB_POKE_CLEAR_AIJ_BACKUP_FAILED.COM
  CPTRDB_POKE_CLEAR_AIJ_LIVE_EXCEPTIONS.COM
  CPTRDB_POKE_CLEAR_AIJ_NOT_EXP_BACKUPS.COM
  CPTRDB_POKE_CLEAR_BATCH_ENTRIES_DIFF.COM
  CPTRDB_POKE_CLEAR_BUGCHECK_DUMPS_FOUND.COM
  CPTRDB_POKE_CLEAR_DB_BACKUPS_DIFF.COM
  CPTRDB_POKE_CLEAR_DB_BACKUP_FAILED.COM
  CPTRDB_POKE_CLEAR_DB_BACKUP_STARTED.COM
  CPTRDB_POKE_CLEAR_DB_RECOVER_FAILED.COM
  CPTRDB_POKE_CLEAR_DB_RECOVER_STARTED.COM
  CPTRDB_POKE_CLEAR_DB_RESTORE_FAILED.COM
  CPTRDB_POKE_CLEAR_DB_RESTORE_STARTED.COM
  CPTRDB_POKE_CLEAR_DDLCK_CNTS_EXCEEDED.COM
  CPTRDB_POKE_CLEAR_EXTENTS_FOUND.COM
  CPTRDB_POKE_CLEAR_JCCLML_AERCP_DIFF.COM
  CPTRDB_POKE_CLEAR_JCCLML_CHECKPT_DIFF.COM
  CPTRDB_POKE_CLEAR_JCCLML_HEARTBEAT_DIFF.COM
  CPTRDB_POKE_CLEAR_JCCLML_PROCESS_DIFF.COM
  CPTRDB_POKE_CLEAR_JCCLML_STATS_DIFF.COM
  CPTRDB_POKE_CLEAR_JDBC_LOGFILES_DIFF.COM
  CPTRDB_POKE_CLEAR_JDBC_PROCESS_DIFF.COM
  CPTRDB_POKE_CLEAR_JDBC_RESTART_STARTED.COM
  CPTRDB_POKE_CLEAR_OPEN_DATABASES_DIFF.COM
  CPTRDB_POKE_CLEAR_SHOW_ENTRIES_DIFF.COM
  CPTRDB_POKE_CLEAR_SQLSRV_DIFF.COM
  CPTRDB_POKE_CLEAR_SRVTRC_NO_CLIENTS.COM
  CPTRDB_POKE_CLEAR_STALL_CNTS_EXCEEDED.COM
  CPTRDB_POKE_CLEAR_STALL_RW_CNTS_EXCEED.COM
  CPTRDB_POKE_CLEAR_STALL_RW_TIMES_EXCEED.COM
  CPTRDB_POKE_CLEAR_STALL_TIMES_EXCEEDED.COM
  CPTRDB_POKE_CLEAR_STATISTICS_DIFF.COM
  CPTRDB_POKE_CLEAR_TRUNC_SNAPS_STOPPED.COM
  CPTRDB_RECOVER_DATABASE.COM
  CPTRDB_RESTART_JDBC.COM
  CPTRDB_RESTORE_DATABASE.COM
  CPTRDB_SHOW_AIJ_BCK_DAILY.COM
  CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM
  CPTRDB_SHOW_AIJ_LIVE_DAILY.COM
  CPTRDB_SHOW_BUGCHECK_DAILY.COM
  CPTRDB_SHOW_DBS_OPEN_DAILY.COM
  CPTRDB_SHOW_DB_BCK_DAILY.COM
  CPTRDB_SHOW_ENTRIES_DAILY.COM
  CPTRDB_SHOW_EXTENTS_DAILY.COM
  CPTRDB_SHOW_JDBC_LOGS_DAILY.COM
  CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM
  CPTRDB_SHOW_SQLSRV_DAILY.COM
  CPTRDB_SHOW_STATS_DAILY.COM
  CPTRDB_SRVTRC_CLIENTS_73202.COM
  CPTRDB_SRVTRC_CLIENTS_73402.COM
  CPTRDB_STALL_CNTS.COM
  CPTRDB_STALL_RW_CNTS.COM
  CPTRDB_STALL_RW_TIMES.COM
  CPTRDB_STALL_TIMES.COM
  CPTRDB_TRNC_SNAPS_STOP.COM
  JCCLML_LML_DUMP_CHECKPOINT_CON.COM
  JCCLML_LML_SHOW_AERCP_CONT.COM
  JCCLML_LML_SHOW_HEARTBEAT_CONT.COM
  JCCLML_LML_SHOW_PROCESS_DAILY.COM
  JCCLML_LML_SHOW_STATS_DAILY.COM
</pre>

<a href="#Chapter 1">To Top</a>

<a name="Chapter 11"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 11 -- Clear CockpitMgr Event Messages
</font>
</h3>

<b>
CPTRDB_POKE_CLEAR_AIJ_BACKUPS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_AIJ_BACKUP_FAILED.COM<br>
CPTRDB_POKE_CLEAR_AIJ_LIVE_EXCEPTIONS.COM<br>
CPTRDB_POKE_CLEAR_AIJ_NOT_EXP_BACKUPS.COM<br>
CPTRDB_POKE_CLEAR_BATCH_ENTRIES_DIFF.COM<br>
CPTRDB_POKE_CLEAR_BUGCHECK_DUMPS_FOUND.COM<br>
CPTRDB_POKE_CLEAR_DB_BACKUPS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_DB_BACKUP_FAILED.COM<br>
CPTRDB_POKE_CLEAR_DB_BACKUP_STARTED.COM<br>
CPTRDB_POKE_CLEAR_DB_RECOVER_FAILED.COM<br>
CPTRDB_POKE_CLEAR_DB_RECOVER_STARTED.COM<br>
CPTRDB_POKE_CLEAR_DB_RESTORE_FAILED.COM<br>
CPTRDB_POKE_CLEAR_DB_RESTORE_STARTED.COM<br>
CPTRDB_POKE_CLEAR_DDLCK_CNTS_EXCEEDED.COM<br>
CPTRDB_POKE_CLEAR_EXTENTS_FOUND.COM<br>
CPTRDB_POKE_CLEAR_JCCLML_AERCP_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JCCLML_CHECKPT_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JCCLML_HEARTBEAT_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JCCLML_PROCESS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JCCLML_STATS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JDBC_LOGFILES_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JDBC_PROCESS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_JDBC_RESTART_STARTED.COM<br>
CPTRDB_POKE_CLEAR_OPEN_DATABASES_DIFF.COM<br>
CPTRDB_POKE_CLEAR_SHOW_ENTRIES_DIFF.COM<br>
CPTRDB_POKE_CLEAR_SQLSRV_DIFF.COM<br>
CPTRDB_POKE_CLEAR_SRVTRC_NO_CLIENTS.COM<br>
CPTRDB_POKE_CLEAR_STALL_CNTS_EXCEEDED.COM<br>
CPTRDB_POKE_CLEAR_STALL_RW_CNTS_EXCEED.COM<br>
CPTRDB_POKE_CLEAR_STALL_RW_TIMES_EXCEED.COM<br>
CPTRDB_POKE_CLEAR_STALL_TIMES_EXCEEDED.COM<br>
CPTRDB_POKE_CLEAR_STATISTICS_DIFF.COM<br>
CPTRDB_POKE_CLEAR_TRUNC_SNAPS_STOPPED.COM<br>
</b>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
  These procedures allow to clear individual CockpitMgr event messages raised
  by the toolset. The event text contains a timestamp ddmmmhhmmss to
  be able to determine if an event is initial or repeating, by
  comparing the event date and time to the text timestamp. 
  The clear has to be executed on the same node that raised the event.<br>

  As of V7.8-040 of CockpitMgr for OpenVMS, all events of a specific class
  on a single node can be cleared using
</p>

<pre>
$ POKE/AGENT/INIT/CLASS=[{class_name}|"OracleRdb"]
</pre>

<p>
  CockpitMgr events, created using POKE/AGENT, are default refreshed in the event console
  every minute. New events, cleared within the same refresh interval, are
  ignored. In order to assure that events created by the toolset are visible
  and receive a proper clear, some procedures wait for more than one
  minute before the execution of the actual clear POKE/AGENT/SOLUTION.
  In this way, procedures with a elapsed time less than one minute, are 
  guaranteed to have their event creation and clear in a different refresh 
  interval and will always be visible.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 12"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 12 -- SQL Attach Utility Procedure
</font>
</h3>

<b>CPTRDB_ATTACH.COM</b><br>
<b>CPTRDB_SQLINI.SQL</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
  Define a read only sql$database environment for a given database using
  CPTRDB_SQLINI.SQL
</p>

Usage:<br>

<pre>
$ SQL := $SQL$
$ @CPTRDB_ATTACH {dbid}
$ SQL
SQL> select rdb$file_name from rdb$database;
</pre>
   
<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 13"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 13 -- Mail Utility Files
</font>
</h3>

<p>
<b>CPTRDB_SIGNATURE.TXT</b><br>
  Provides a mail body text.<br>
  Adapt this file to your personal contact data.
</p>

<p>
<b>CPTRDB_MIME$INIT.EVE</b><br>
  Enables a mail body using the OpenVMS MIME utility.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 14"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 14 -- Minimum Setup Requirements
</font>
</h3>

<b>CPTRDB_CREATE_DIRECTORIES.COM</b><br>
<b>CPTRDB_DEFINE_LOGICALS.COM</b><br>
<b>CPTRDB_INITIALIZE_QUEUE.COM</b><br>
<b>CPTRDB_SUBMIT.COM</b><br><br>

<b>CPTRDB_GET_DCL_DATA.SQL</b><br>
<b>CPTRDB_LIB_TIMER.SQL</b><br><br>

<b>CPTRDB_SHOW_DBKEY.C</b><br>
<b>CPTRDB_SHOW_DBKEY.EXE</b><br>
<b>CPTRDB_SHOW_DBKEY.OBJ</b><br>
<b>CPTRDB_SHOW_DBKEY.SQL</b><br>
<b>CPTRDB_SHOW_DBKEY_BUILD.COM</b><br><br>

<b>SQL$SAMPLE:INFO_TABLES</b><br>
<b>SYS$SHARE:SQL_FUNCTIONS[72|73]</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
Even in a minimum configuration, the toolset requires a number of directories,
logicals and batch queue(s) to be defined.  
</p>

<p>
Each database that participates in the toolset, has to contain the Rdb
information tables as wel as a number of functions and procedures.
</p>

<p>
The minimum required directories, logicals and batch queue(s) are:
</p>

<pre>
CPT$RDB
CPT$RDB_ROOT
CPT$RDB_TMP
CPT$RDB_LOGS
CPT$RDB_LISTS
CPT$RDB_DATA
CPT$RDB_CHANGES
CPT$RDB_BATCH_{node}
</pre>

<p>
All procedures are handling a double indirection for the directory locations,
using DCL symbols and logicals, grouped in a parameter block as below, upfront
the procedure code. Default the CPT$RDB* logicals are being used. In this way
the active directories can be easily modified and adapted to the current
runtime environment.
</p>

<pre>
$!-------------------------
$ defdir = "CPT$RDB:"
$ tmpdir = "CPT$RDB_TMP:"
$ logdir = "CPT$RDB_LOGS:"
$ outdir = "CPT$RDB_LISTS:"
$ datdir = "CPT$RDB_DATA:"
$!-------------------------
</pre>

<p>
<b>CPTRDB_CREATE_DIRECTORIES.COM</b><br>
  Create the toolset directories.
</p>

<p>
  Parameters: Adapt the DCL symbols USERID, ROOT_DIR, OUTDEV
</p>

<pre>
$!------------------------------------------------------
$! -- Toolset user
$ userid          = "RDBMON"
$!
$! -- Toolset home
$ root_dir        = "DISK$USERS:[ALLEMEERSCH.CPT$RDB"
$ def_dir         = "''root_dir']"
$ logs_dir        = "''root_dir'.LOGS]"
$ lists_dir       = "''root_dir'.LISTS]"
$ tmp_dir         = "''root_dir'.TMP]"
$ data_dir        = "''root_dir'.DATA]"
$ changes_dir     = "''root_dir'.CHANGES]"
$!
$! -- End minimum required symbols
$!
$ lml_logs_dir    = "''root_dir'.LML_LOGS]"
$!
$! -- Output files device
$ outdev          = "DISK$DATA_29:"
$!
$! -- Adapt to existing jdbc environment
$ jdbc_logdir     = "SYS$COMMON:[RDB$JDBC.LOGS]"
$ jdbc_trcdir     = "''outdev'[JDBC_TRACE_FILES]"
$ jdbc_trcdirdone = "''outdev'[JDBC_TRACE_FILES.DONE]"
$ jdbc_thindir    = "DISK$USERS:[ORACLE.RDB$PROCS.THIN]"
$!------------------------------------------------------
</pre>

<p>
  Execute the procedure upto:
</p>

<pre>
$!---------------------------------------
$! -- End minimum required directories --
$!---------------------------------------
$ exit
</pre>

<p>
<b>CPTRDB_DEFINE_LOGICALS.COM</b><br>
  Define the toolset logicals.
</p>

<p>
  Parameters: Adapt the DCL symbols HOME_DIR, ROOT_DIR, OUTDEV, AIJDEV
</p>

<pre>
$!-----------------------------------------------
$! -- Minimum required symbols
$!
$! -- Toolset home
$ home_dir = "DISK$USERS:[ALLEMEERSCH.CPT$RDB]"
$!
$! -- Toolset root, full physical path rooted
$ root_dir = "DSA30:[USERS.ALLEMEERSCH.CPT$RDB.]"
$!-----------------------------------------------
$!
$! -- Output files device
$ outdev   = "DISK$DATA_29:"
$!
$! -- Live AIJ files device, physical disk
$ aijdev   = "DSA29:"
$!
$! -- Adapt to existing jdbc environment
$ jdbc_logdir     = "SYS$COMMON:[RDB$JDBC.LOGS]"
$ jdbc_trcdir     = "''outdev'[JDBC_TRACE_FILES]"
$ jdbc_trcdirdone = "''outdev'[JDBC_TRACE_FILES.DONE]"
$ jdbc_thindir    = "DISK$USERS:[ORACLE.RDB$PROCS.THIN]"
$!------------------------------------------------------
</pre>

<p>
  Execute the procedure upto:
</p>

<pre>
$!------------------------------------
$! -- End minimum required logicals --
$!------------------------------------
$ exit
</pre>

<p>
  The toolset logicals are:
</p>

<pre>
  CPT$RDB                 Toolset home
  CPT$RDB_AIJ             Live AIJ files
  CPT$RDB_AIJ_BCK         AIJ backup files
  CPT$RDB_ANA             Analyze output files
  CPT$RDB_ANA_DB_BCK      Analyze database backup files
  CPT$RDB_CACHES          Row cache backing store files
  CPT$RDB_CHANGES         Partial update kits changes
  CPT$RDB_DATA            Toolset data
  CPT$RDB_DB_BCK          Database backup files
  CPT$RDB_JCCLML_LOGS     JCC Logminer Loader log files
  CPT$RDB_JCCLML_MGR      JCC Logminer Loader management log files 
  CPT$RDB_JDBC_LOGDIR     JDBC logs
  CPT$RDB_JDBC_THINDIR    JDBC clients data
  CPT$RDB_JDBC_TRCDIR     JDBC trace files
  CPT$RDB_JDBC_TRCDIRDONE JDBC trace files after client extraction
  CPT$RDB_LISTS           Toolset output files
  CPT$RDB_LOGS            Toolset log files
  CPT$RDB_PERFT4          Database T4 performance data
  CPT$RDB_ROOT            Toolset home
  CPT$RDB_SIZE            Database size data
  CPT$RDB_SRV_LOGS        Server processes logs 
  CPT$RDB_STALL           Database stall logs
  CPT$RDB_STALL_CNTS      Database stall/deadlock counts, stall times
  CPT$RDB_TMP             Toolset temporay files

  CPTRDB_DB_1             Test and demonstration database
  CPTRDB_DB_2             JCC Logminer Loader target database
  ANA_CPTRDB_DB_1         Analyze database

  JCC_LOGMINER_LOADER_FILTER_DIR  JCC LML filter database directory
  JCC_LOGMINER_LOADER_FILTER_NAME JCC LML filter database filespec name
  JCCLML_FILTER_DB_ROOT           JCC LML filter database root full filespec

  CPTRDB_MASTR_DB         Hot standby, master database
  CPTRDB_STDBY_DB         Hot standby, standby database
</pre>

<p>
  The {dbid} logical, used in this Users Guide, is assumed to point to the
  Rdb database root file filespec, upto and including the .RDB extension.
</p>
 
<pre>
[As of Rdb V7.3-200 the new qualifier /DESCRIPTION of the command 
RMU/SHOW LOGICAL_NAME documents all logicals available within Rdb, grouped 
in the help library SYS$HELP:RMUDISPLAY73.HLB

Usage:

$ RMU/SHOW LOGICAL_NAME/UNDEFINED/DESCRIPTION *zigzag*

"RDMS$DISABLE_ZIGZAG_BOOLEAN" = Undefined

"RDMS$DISABLE_ZIGZAG_MATCH" = Undefined

Disables zigzag key skip on outer and inner match loops. Defining
this logical with the value "1" will disable zigzag key skip on
the outer loop. Defining this logical with the value "2" disables
zigzag key skip on both outer and inner match loops.

This value can also be set by defining the logical name RDMS$SET_
FLAGS or using the SET FLAGS statement with the string 'NOZIGZAG_
MATCH', or 'NOZIGZAG_OUTER'. See the SQL Reference Manual SET
FLAGS Statement for further details.]
</pre>

<p>
<b>CPTRDB_INITIALIZE_QUEUE.COM</b><br>
  Create and start a dedicated batch queue on a specific node, named
  CPT$RDB_BATCH_{node}
</p>

  Usage:<br>

<pre>
$ @CPTRDB_INITIALIZE_QUEUE {node}
</pre>

<p>
<hr>
  All procedures assume a batch queue named CPT$RDB_BATCH_{node} exists
  on each cluster node participating in the toolset.
<hr>
</p>

<p>
<b>CPTRDB_SUBMIT.COM</b><br>
  Submit a toolset job in batch to the queue CPT$RDB_BATCH_{node}
  with the logfile in the CPT$RDB_LOGS directory.
</p>

<pre>
Parameters: P1,   nodename,                      char(6)
            P2,   filename, CPTRDB_{name}[.COM], char(39)
            [P3], /AFTER date time,              [absolute|delta] time

P2 is the filename only, without extension .COM
P3 is optional
The prefix "CPTRDB_" is stripped off from the logfile filename
The logfile format is {name}_{node}_yyyymmdd.log_ddmmmhhmmss
</pre>

Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} [{name}|CPTRDB_CREATE_DB] {date time}
</pre>

<p>
<hr>
The logfile format {name}_{node}_yyyymmdd.log_ddmmmhhmmss is the general 
format for all log and output files across the toolset.
<hr>
</p>

<p>
  The {node} string is for .log logfiles the execution node of the procedure.
  For output files (.lis, .mime, .diff) the {node} string is the reference
  node (execution or other) depending on the semantics of the procedure.
</p>

<p>
  The {yyyymmdd} string is for .log logfiles the execution date of the
  procedure. For output files (.lis, .mime, .diff) the {yyyymmdd} string is
  the reference date (execution or other) depending on the semantics of the
  procedure.
</p>

<p>
  The {ddmmmhhmmss} string is always the file creation timestamp.
</p>

<p>
  JCC Logminer Loader log and output files have specific conventions,
  starting with "LML_", "JCC_RUN_", "DTL_". Refer to the JCC Logminer Loader
  chapters
  <a href="#Chapter 51">§ -- 51 -- Replicate Data Using The JCC Logminer Loader</a>
  and
  <a href="#Chapter 52">§ -- 52 -- Manage JCC Logminer Loader Sessions</a>
  for more details.
</p>

<p>
  Refer to the chapter
  <a href="#Chapter 65">§ -- 65 -- Database And Output Files Formats</a>
  for a complete list of all files handled by the toolset on a specific day.
</p>

<p>
  Note that these filespecs are unique, so the use of the catchall cleaning
  procedure CPTRDB_CLEANUP_LOGS_DAILY.COM is required to contain the volume of
  the output data. Many procedures, but not all, assure their own cleanup
  though.
</p>

<b>CPTRDB_GET_DCL_DATA.SQL</b><br>
<b>CPTRDB_LIB_TIMER.SQL</b><br>
<b>CPTRDB_SHOW_DBKEY.SQL</b><br>
<b>SQL$SAMPLE:INFO_TABLES</b><br>
<b>SYS$SHARE:SQL_FUNCTIONS[72|73]</b><br>

<p>
  Each database that participates in the toolset, has to contain the Rdb
  information tables as wel as a number of functions and procedures.
</p>

<p>
  These objects can be created per database using:
</p>

<pre>
$ SQL := $SQL$
$ @CPT$RDB:CPTRDB_ATTACH {dbid}
$ SQL
SQL>@CPT$RDB:CPTRDB_GET_DCL_DATA
    @CPT$RDB:CPTRDB_LIB_TIMER
    @CPT$RDB:CPTRDB_SHOW_DBKEY
    @SQL$SAMPLE:INFO_TABLES
    COMMIT;
    @SYS$SHARE:SQL_FUNCTIONS[72|73]
    COMMIT;
</pre>

<a href="#Chapter 1">To Top</a>

<a name="Chapter 14.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 14.1 -- Getting Started
</font>
</h3>

<p>
-- For any database without entries in the configuration file --
</p>

<pre>
CPTRDB_SHOW_STORAGE_AREAS.COM
CPTRDB_SHOW_DOMAINS.COM
CPTRDB_SHOW_TABLES.COM
CPTRDB_SHOW_INDICES.COM
CPTRDB_SHOW_AREAS_IDS.COM
CPTRDB_SHOW_USERS.COM
CPTRDB_SHOW_TSN_BLKS.COM
CPTRDB_SHOW_AIJ_LIVE_ONE.COM
CPTRDB_SHOW_AIJ_LIVE_DUMP.COM

CPTRDB_SHOW_ONE_HASH_INDEX.COM
CPTRDB_SHOW_ONE_INDEX_SET.COM
CPTRDB_SHOW_ONE_LOGICAL_AREA.COM
CPTRDB_SHOW_ONE_PAGE.COM
CPTRDB_SHOW_ONE_RECORD_TYPE.COM
CPTRDB_SHOW_ONE_STORAGE_AREA.COM
CPTRDB_SHOW_ONE_STORAGE_MAP.COM
</pre>

<p>
-- With entries in the configuration file required --
</p>

<p>
<b>CPTRDB_CONFIGURATION_TEMPLATE.REF</b><br>
CPTRDB_CONFIGURATION.REF
</p>

<pre>
CPTRDB_SHOW_DBS_OPEN.COM
CPTRDB_SHOW_DBS_OPEN_BATCH.COM
CPTRDB_SHOW_DBS_OPEN_DAILY.COM
CPTRDB_SHOW_DBS_OPEN.REF

CPTRDB_SHOW_AIJ_LIVE.COM
CPTRDB_SHOW_AIJ_LIVE_BATCH.COM
CPTRDB_SHOW_AIJ_LIVE_DAILY.COM

CPTRDB_BATCH_ENTRIES.COM
CPTRDB_BATCH_ENTRIES_DAILY.COM
CPTRDB_BATCH_ENTRIES.REF
</pre>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
  The procedures listed in this chapter provide an excellent entry point for 
  novice users of the toolset to start the access of the (realy smooth) 
  learning curve, once the minimum setup has been created.   
</p>

<p>
  The procedures that do not access the configuration file can be used right
  away as is.
</p>

<p>
  The procedures CPTRDB_SHOW_DBS_OPEN*.COM, CPTRDB_SHOW_AIJ_LIVE*.COM and
  CPTRDB_BATCH_ENTRIES*.COM are a good starting point to become familiar with
  the general behavior of the toolset and processing of the interactive and
  automated actions. They require entries and data in the configuration file 
  and reference file(s).
</p>

<p>
<b>CPTRDB_CONFIGURATION_TEMPLATE.REF</b><br>
CPTRDB_CONFIGURATION.REF
</p>

<p>
  The template configuration file contains the minimum required entries to run
  the procedures:
</p>
  
<pre>
CPTRDB_SHOW_AIJ_LIVE[_DAILY].COM
CPTRDB_SHOW_DBS_OPEN[_DAILY].COM
CPTRDB_BATCH_ENTRIES[_DAILY].COM
</pre>
  
<p>
  Rename and save the configuration file shipped with the kit using
</p>

<pre>
$ @CPTRDB_RENAME_CDT CPTRDB_CONFIGURATION.REF
</pre>
  
<p>
  Copy the template configuration file CPTRDB_CONFIGURATION_TEMPLATE.REF to 
  CPTRDB_CONFIGURATION.REF in order to establish it as the runtime 
  active configuration file and adapt the settings to your environment.
</p>

<pre>
$ COPY CPTRDB_CONFIGURATION_TEMPLATE.REF CPTRDB_CONFIGURATION.REF
$ EDIT CPTRDB_CONFIGURATION.REF
</pre>

<p>
  Interactive usage:
</p>

<pre>
$! -- Using the configuration file --
$ @CPTRDB_SHOW_AIJ_LIVE
$ @CPTRDB_SHOW_DBS_OPEN
$ @CPTRDB_BATCH_ENTRIES
</pre>

<p>
  Start the recurring automated 'DAILY' procedures via:
</p>

<pre>
$! -- Using the configuration file --
$ @CPTRDB_SUBMIT {node} CPTRDB_SHOW_AIJ_LIVE_DAILY
$ @CPTRDB_SUBMIT {node} CPTRDB_SHOW_DBS_OPEN_DAILY
$ @CPTRDB_SUBMIT {node} CPTRDB_BATCH_ENTRIES_DAILY
</pre>

  Refer to the individual chapters below for more information on the procedures
  listed here:<br><br>

  <a href="#Chapter 20">§ -- 20 -- List And Check Batch Entries</a><br>
  <a href="#Chapter 21">§ -- 21 -- List And Check Live AIJ Files</a><br>
  <a href="#Chapter 27">§ -- 27 -- List And Check Open Databases</a><br>
  <a href="#Chapter 37">§ -- 37 -- List Database Objects</a><br><br>

<a href="#Chapter 1">To Top</a>

<a name="Chapter 15"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 15 -- Create A Demonstration And Test Environment
</font>
</h3>

<b>CPTRDB_CREATE_DB.COM</b><br>
<b>CPTRDB_CREATE_DB_TABLES.COM</b><br>
<b>CPTRDB_ALL_DATATYPES_CREATE.COM</b><br>
<b>CPTRDB_ALL_DATATYPES_INSERT.COM</b><br>
<b>CPTRDB_CREATE_DB_AIJ.COM</b><br><br>

<b>CPTRDB_SET_SERVER_LOGS.COM</b><br>
<b>CPTRDB_RESET_SERVER_LOGS.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The procedures listed here, executed in sequence, provide a runtime tutorial
proof of concept environment for all operations included in the toolset.
</p>

<p>
<b>CPTRDB_CREATE_DB.COM</b><br>
  Create and RMU/Open the physical test database named CPTRDB_DB_1.
</p>

<p>
  The database settings chosen correspond to today's best practice
  and reflect the attributes of a modern Rdb database.
</p>

<p>
  Note that as of Rdb V7.2, the maximum buffer size is 128 blocks,
  the maximum page size is 63 blocks and the maximum number of global
  buffers is 1,048,576 (= POWER(2,20)).
  As of Rdb V7.3-100, the maximum buffer size is 256 blocks.
</p>

<p>
  Parameters: adapt the dcl symbols DEV and DBID, device name and db logical
</p>

<pre>
$!----------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_DB_1"
$!----------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_CREATE_DB
</pre>

<p>
  The default Rdb version across the toolset sources is V7.3
</p>

<p>
  The test database is created with all toolset requirements satisfied.
</p>

<p>
<b>CPTRDB_CREATE_DB_TABLES.COM</b><br>
  Create the tables of the test database.
</p>

<p>
  The table TABLE_ALL_DATATYPES demonstrates the wealth of Rdb's datatypes
  as well as a LISTS storage map.
</p>

<p>
  Parameters: Adapt the sql$database logical
</p>

<pre>
$!-------------------------------
$ define sql$database cptrdb_db_1
$!-------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_CREATE_DB_TABLES
</pre>

<p>
<b>CPTRDB_ALL_DATATYPES_CREATE.COM</b><br>
  [Re]Create the [TABLE_]ALL_DATATYPES table for demonstration purposes.<br>
  Add the datatypes BINARY and BINARY VARYING<br>
  The LISTS storage map is adapted before and and after the [DROP|CREATE] TABLE
</p>

<p>
  Parameters: Adapt the sql$database logical
</p>

<pre>
$!-------------------------------
$ define sql$database cptrdb_db_1
$!-------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_ALL_DATATYPES_CREATE
</pre>

<p>
  Some numeric datatypes are converted to signed binary datatypes:
</p>

<pre>
%SQL-I-NO_DECIMAL, DECIMAL_NOSCALE is being converted from DECIMAL to INTEGER.
%SQL-I-NO_DECIMAL, DECIMAL_4 is being converted from DECIMAL to SMALLINT.
%SQL-I-NO_DECIMAL, DECIMAL_9 is being converted from DECIMAL to INTEGER.
%SQL-I-NO_DECIMAL, DECIMAL_18 is being converted from DECIMAL to BIGINT.
%SQL-I-NO_DECIMAL, DECIMAL_19 is being converted from DECIMAL to FLOAT.
%SQL-I-NO_DECIMAL, DECIMAL_4_SCALE is being converted from DECIMAL to SMALLINT.
%SQL-I-NO_DECIMAL, DECIMAL_9_SCALE is being converted from DECIMAL to INTEGER.
%SQL-I-NO_DECIMAL, DECIMAL_18_SCALE is being converted from DECIMAL to BIGINT.
%SQL-I-NO_DECIMAL, DECIMAL_19_SCALE is being converted from DECIMAL to FLOAT.
%SQL-I-NO_NUMERIC, NUMERIC_NOSCALE is being converted from NUMERIC to INTEGER.
%SQL-I-NO_NUMERIC, NUMERIC_4 is being converted from NUMERIC to SMALLINT.
%SQL-I-NO_NUMERIC, NUMERIC_9 is being converted from NUMERIC to INTEGER.
%SQL-I-NO_NUMERIC, NUMERIC_18 is being converted from NUMERIC to BIGINT.
%SQL-I-NO_NUMERIC, NUMERIC_19 is being converted from NUMERIC to FLOAT.
%SQL-I-NO_NUMERIC, NUMERIC_4_SCALE is being converted from NUMERIC to SMALLINT.
%SQL-I-NO_NUMERIC, NUMERIC_9_SCALE is being converted from NUMERIC to INTEGER.
%SQL-I-NO_NUMERIC, NUMERIC_18_SCALE is being converted from NUMERIC to BIGINT.
%SQL-I-NO_NUMERIC, NUMERIC_19_SCALE is being converted from NUMERIC to FLOAT.
%SQL-I-NO_NUMBER, NUMBER_NOSCALE is being converted from NUMBER to FLOAT
%SQL-I-NO_NUMBER, NUMBER_2 is being converted from NUMBER to TINYINT
%SQL-I-NO_NUMBER, NUMBER_4 is being converted from NUMBER to SMALLINT
%SQL-I-NO_NUMBER, NUMBER_9 is being converted from NUMBER to INTEGER
%SQL-I-NO_NUMBER, NUMBER_18 is being converted from NUMBER to BIGINT
%SQL-I-NO_NUMBER, NUMBER_19 is being converted from NUMBER to FLOAT
%SQL-I-NO_NUMBER, NUMBER_2_SCALE is being converted from NUMBER to TINYINT
%SQL-I-NO_NUMBER, NUMBER_4_SCALE is being converted from NUMBER to SMALLINT
%SQL-I-NO_NUMBER, NUMBER_9_SCALE is being converted from NUMBER to INTEGER
%SQL-I-NO_NUMBER, NUMBER_18_SCALE is being converted from NUMBER to BIGINT
%SQL-I-NO_NUMBER, NUMBER_19_SCALE is being converted from NUMBER to FLOAT
%SQL-I-NO_NUMBER, NUMBER_2_NEGSCALE is being converted from NUMBER to TINYINT
%SQL-I-NO_NUMBER, NUMBER_4_NEGSCALE is being converted from NUMBER to SMALLINT
%SQL-I-NO_NUMBER, NUMBER_9_NEGSCALE is being converted from NUMBER to INTEGER
%SQL-I-NO_NUMBER, NUMBER_18_NEGSCALE is being converted from NUMBER to BIGINT
%SQL-I-NO_NUMBER, NUMBER_19_NEGSCALE is being converted from NUMBER to FLOAT
%SQL-I-NO_NUMBER, NUMBER_STAR is being converted from NUMBER to BIGINT
%SQL-I-NO_NUMBER, NUMBER_STAR_SCALE is being converted from NUMBER to BIGINT
%SQL-I-NO_NUMBER, NUMBER_STAR_NEGSCALE is being converted from NUMBER to BIGINT
</pre>

<p>
<b>CPTRDB_ALL_DATATYPES_INSERT.COM</b><br>
  Insert lowercase/positive and uppercase/negative values in the
  TABLE_ALL_DATATYPES table for demonstration purposes.
</p>

<p>
  Parameters: Adapt the sql$database logical
</p>

<pre>
$!-------------------------------
$ define sql$database cptrdb_db_1
$!-------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_ALL_DATATYPES_INSERT
</pre>

<p>
<b>CPTRDB_CREATE_DB_AIJ.COM</b><br>
  Enable AIJ, fast commit and continuous logmining for the test database.<br>
  Perform a initial offline database backup.<br>
  RMU/Open the database on the executor node
</p>

<p>
  Parameters: Adapt symbol DBID and logical DBROOT
</p>

<pre>
$!---------------------------
$ dbid =       "CPTRDB_DB_1"
$ define dbroot cptrdb_db_1
$!---------------------------
</pre>

<p>
  The procedure creates the minimum three live AIJ files, with a default 
  allocation of 500,000 blocks each, a recommended maximum size.
</p>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_CREATE_DB_AIJ
</pre>

<p>
<b>CPTRDB_SET_SERVER_LOGS.COM</b><br>
  Online set the filespecs for the server processes output files as database
  parameters for one database.
</p>

<pre>
Parameters: P1, dbid, varchar(255)
</pre>

<p>
  The procedure deassigns the logicals that overrule these settings.
</p>

<p>
  Note the conflicting semantics of the "clusterwide per database" database
  parameters versus the "node specific all databases" logicals.
  The database administrator will have to make a choice for one of the two
  strategies and apply it to all databases or all nodes.
</p>

<pre>
$ deass/sys/exec RDM$BIND_ABS_LOG_FILE
$ deass/sys/exec RDM$BIND_ALS_OUTPUT_FILE
$ deass/sys/exec RDM$BIND_DBR_LOG_FILE
$ deass/sys/exec RDM$BIND_LCS_OUTPUT_FILE
$ deass/sys/exec RDM$BIND_LRS_OUTPUT_FILE
$ deass/sys/exec RDM$BIND_RCS_LOG_FILE
</pre>

<p>
  The output files are defined as<br>
  {logdir}:{dbid}_{node}_{servertype}_{pid}.log
</p>

<p>
  The {node} string can be replaced by a identifier that designates the
  cluster environment such as CPTRDB/DEV/TEST/PROD ...
</p>

<p>
  Usage:
</p>
 
<pre>
$ @CPTRDB_SET_SERVER_LOGS {dbid}
</pre>

<p>
<b>CPTRDB_RESET_SERVER_LOGS.COM</b><br>
  Online reset the filespecs for the server processes output files as database
  parameters for one database.
</p>

<pre>
Parameters: P1, dbid, varchar(255)
</pre>

<p>
  The procedure reassigns the logicals that overrule these settings.
</p>

<pre>
$ define/sys/exec RDM$BIND_ABS_LOG_FILE    "''logdir_reset'''nodeid'_abs_pid.log"
$ define/sys/exec RDM$BIND_ALS_OUTPUT_FILE "''logdir_reset'''nodeid'_als_pid.log"
$ define/sys/exec RDM$BIND_DBR_LOG_FILE    "''logdir_reset'''nodeid'_dbr_pid.log"
$ define/sys/exec RDM$BIND_LCS_OUTPUT_FILE "''logdir_reset'''nodeid'_lcs_pid.log"
$ define/sys/exec RDM$BIND_LRS_OUTPUT_FILE "''logdir_reset'''nodeid'_lrs_pid.log"
$ define/sys/exec RDM$BIND_RCS_LOG_FILE    "''logdir_reset'''nodeid'_rcs_pid.log"
</pre>

<p>
  The logicals are redefined as<br>
  {logdir}:{node}_{servertype}_{pid}.log
</p>

<p>
  The {node} string can be replaced by a identifier that designates the
  cluster environment such as CPTRDB/DEV/TEST/PROD ...
</p>

<p>
  Usage:
</p>
 
<pre>
$ @CPTRDB_RESET_SERVER_LOGS {dbid}
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 16"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 16 -- Database Backup
</font>
</h3>

<b>CPTRDB_BACKUP_DB_ALL.COM</b> (Calls per database)<br>
<b>CPTRDB_BACKUP_DB.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_BACKUP_DB_ALL.COM</b><br>
  Calls per database CPTRDB_BACKUP_DB.COM<br><br>

  This procedure performs a regular daily online quiet point database backup 
  to disk for a series of databases listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_DATABASE|CPTRDB_BACKUP_DB
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_BACKUP_DB|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_BACKUP_DB
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>
  
<p>
  The reschedule node and reschedule time are retrieved from the configuration
  file, identified by the keywords CPT$RDB_JOB|CPTRDB_BACKUP_DB_ALL
</p>

<pre>
CPT$RDB_JOB|CPTRDB_BACKUP_DB_ALL|L15S29|TOMORROW + 00:35|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_BACKUP_DB_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

  The logfile format is<br>

<pre>
BACKUP_DB_ALL_{node}_yyyymmdd.LOG_ddmmmhhmmss
</pre>

  Logfiles older than 8 days are cleaned.<br>

<p>
<b>CPTRDB_BACKUP_DB.COM</b><br>
  Called per database from CPTRDB_BACKUP_DB_ALL.COM
</p>

<p>
  Execute a online quiet point database backup to disk for one database.
  The runtime parameters are retrieved from the configuration file, identified
  by the keywords CPT$RDB_PARAM|CPTRDB_BACKUP_DB.
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_BACKUP_DB|00|0|30|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_BACKUP_DB
! 2 Scheduled backup hours, hh ";" separated list, hh;hh;hh
! 3 (Number - 1) scheduled backup hours
! 4 Timeout seconds, default 30
! 5 Exception mail address
</pre>

  The logfile format is<br>

<pre>
BACKUP_DB_{dbid}_{node}_yyyymmdd.LOG_ddmmmhhmmss
</pre>

  Logfiles older than 8 days are cleaned.<br><br>

  The backup file format is<br>

<pre>
cpt$rdb_db_bck:{dbid}_{node}_yyyymmdd_hhmm.rbf
</pre>

<p>
  The {dbid} string is truncated to char(13) in the output files 
  .log*, .lis*, .mime* and to char(18) in the database backup file .rbf,
  in order to respect the char(39) limit on filenames for ODS2 disks.
</p>

<pre>
123456789012345678901234567890123456789
123456789012345678_123456_yyyymmdd_hhmm.rbf
backup_db_1234567890123_123456_yyyymmdd.[log|lis|diff|mime]_ddmmmhhmmss
</pre>

  A database backup is executed if<br>

<pre>
   None exists for the current day
Or The current hour is in the list of scheduled hours
   And none exists for the current hour (based on the .rbf filename)
</pre>

<p>
  To force a database backup, rename today's backup file(s) to a subdirectory
  and release the job CPTRDB_BACKUP_DB_ALL.
  If only one of a series of database backups has failed for the current day,
  it can be restarted by 
</p>

<pre>
$ @CPTRDB_POKE_CLEAR_DB_BACKUP_STARTED
$ @CPTRDB_POKE_CLEAR_DB_BACKUP_FAILED
or
$ POKE/AGENT/INIT/CLASS="OracleRdb"

$ SET ENTRY/RELEASE CPTRDB_BACKUP_DB_ALL
</pre>

<p>
  The other backups will exit with "Nothing to do",
  assuming the current hour is not a scheduled hour.
</p>

  Toolset CockpitMgr events:<br>

<pre>
CPTRDB_DB_BackupStarted 
"CPTRDB - Database {root} - DB Backup Started - ddmmmhhmmss"

CPTRDB_DB_BackupFailed
"CPTRDB - Database {root} - DB Backup Failed - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - DB Backup Failed {dbid} {node} yyyymmdd"
</pre>

  Database backup files are cleaned if<br>

<pre>
    The current run is successful
And they are created before the current day
And their expiration date is set to a date before the current day
</pre>

<p>
  Default, after a successful run, the procedure sets the expiration date to 
  the creation date for database backup files created before the current day, 
  so they are cleaned right away. 

  With normal operations, the CPT$RDB_DB_BCK directory contains only one .RBF 
  copy per database, assuming only one scheduled hour.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 17"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 17 -- AIJ Journal Backup
</font>
</h3>

<b>CPTRDB_BACKUP_AIJ_ALL.COM</b> (Calls per database)<br>
<b>CPTRDB_BACKUP_AIJ.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_BACKUP_AIJ_ALL.COM</b><br>
  Calls per database CPTRDB_BACKUP_AIJ.COM
</p>

<p>
  This procedure performs a regular repeating quiet point AIJ backup 
  to disk for a series of databases listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_DATABASE|CPTRDB_BACKUP_AIJ
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_BACKUP_AIJ|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_BACKUP_AIJ
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>
  
<p>
  The reschedule node and reschedule time are retrieved from the configuration
  file, identified by the keywords CPT$RDB_JOB|CPTRDB_BACKUP_AIJ_ALL.<br>
  The job is default rescheduled every 30 minutes, in order to catch in time any
  *Backup Needed* condition, and to be activated at least twice within each
  (scheduled) wallclock hour.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_BACKUP_AIJ_ALL|L15S29|+00:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_BACKUP_AIJ_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

  The logfile format is<br>

<pre>
BACKUP_AIJ_ALL_{node}_yyyymmdd.LOG_ddmmmhhmm
</pre>

  Logfiles older than 24 hours are cleaned.<br>

<p>
<b>CPTRDB_BACKUP_AIJ.COM</b><br>
  Called per database from CPTRDB_BACKUP_AIJ_ALL.COM
</p>

<p>
  Execute a quiet point AIJ journal backup to disk for one database.<br>
  The runtime parameters are retrieved from the configuration file, identified
  by the keywords CPT$RDB_PARAM|CPTRDB_BACKUP_AIJ
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_BACKUP_AIJ|00;06;08;10;12;14;16;18;20;22|9|30|L15S36::ALLEMEERSCH
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_BACKUP_AIJ
! 2 Scheduled backup hours, hh ";" separated list, hh;hh;hh;hh
! 3 (Number - 1) scheduled backup hours
! 4 Timeout seconds, default 30
! 5 Exception mail address
</pre>

<pre>
[The logical RDM$BIND_AIJBCK_CHECKPOINT_TIMEOUT implements a timeout for
"%RMU-F-AIJJRNBSY, journal !AC is busy and cannot be backed up"
The value is expressed in 30 sec units.
As of Rdb V7.3-210, the value is expressed in 1 minute units.]
</pre>

The logfile format is<br>

<pre>
BACKUP_AIJ_{dbid}_{node}_yyyymmdd.LOG_ddmmmhhmmss
</pre>

  Logfiles older than 24 hours are cleaned.<br><br>

  The backup file format is<br>

<pre>
cpt$rdb_aij_bck:{dbid}_{node}_yyyymmdd_hhmm_{seqnbr}.aij_bck
</pre>

<p>
  The {dbid} string is truncated to char(12) in all output files
  .log*, .lis*, .mime* and .aij_bck, assuming a char(5) for {seqnbr}, 
  in order to respect the char(39) limit on filenames for ODS2 disks.
</p>

<pre>
123456789012345678901234567890123456789
123456789012_123456_yyyymmdd_hhmm_nnnnn.aij_bck
backup_aij_123456789012_123456_yyyymmdd.[log|lis|diff|mime]_ddmmmhhmmss
</pre>

  The default database journal backup edit string is<br>

<pre>
$ rmu/set after -
  /backups=(manual, -
  edit_filename=(YEAR,MONTH,DAY_OF_MONTH,"_",HOUR,MINUTE,"_",SEQUENCE) ) -
  {dbid}
</pre>

  A AIJ backup is executed if<br>

<pre>
   None exists for the current day
Or the current hour is in the list of scheduled hours
   And none exists for the current hour (based on the .aij_bck filename)
Or a live AIJ file (is full and) has the status "*Backup Needed*"
</pre>

<p>
  To force a AIJ backup, rename today's backup file(s) to a subdirectory
  and release the job CPTRDB_BACKUP_AIJ_ALL.
  Eventually clear beforehand the AIJ backup failed event(s) using:
</p>

<pre>
$ @CPTRDB_POKE_CLEAR_AIJ_BACKUP_FAILED
or
$ POKE/AGENT/INIT/CLASS="OracleRdb"
</pre>

<p>
  CockpitMgr captures, matches, displays and clears all standard AIJ related 
  opcom messages issued by Rdb. The database should have the setting 
  'NOTIFY ENABLED'.
</p>

  CockpitMgr events on standard Rdb opcom messages:<br>

<pre>
  RDB_AIJ_BackupStarted        "AIJ backup operation started*"

  RDB_AIJ_SwitchOverInProgress "After-image journal * switch-over in progress*"

  RDB_AIJ_SwitchOverComplete   "After-image journal switch-over complete*"
    Clears RDB_AIJ_SwitchOverInProgress

  RDB_AIJ_BackupCompleted      "AIJ backup operation completed*"
    Clears RDB_AIJ_BackupStarted

  RDB_AIJ_Opening              "Opening *.AIJ;*"

  RDB_AIJ_MANUAL_BACKUP_FAILED "AIJ manual backup operation failed"
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_AIJ_BackupFailed
"CPTRDB - Database {root} - AIJ Backup Failed - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - AIJ Backup Failed {dbid} {nodeid} yyyymmdd"
</pre>

  AIJ backup files are cleaned if:<br>

<pre>
    The current run is successful
And they are created more than 24 hours before the current date and time
And their expiration date is set to a timestamp older than 8 days before 
    the current date and time 
</pre>

<p>
  Default, after a successful run, the procedure sets the expiration timestamp
  to the creation timestamp for AIJ backup files created more than 24 hours 
  before the current date and time, so they are cleaned automatically after 
  8 days. 
      
<hr>
  The assumption is that at least one valid full quiet point database backup
  has been created over the last eight days, to assure the database
  can be recovered.
<hr>
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 18"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 18 -- List And Check Database Backup Files
</font>
</h3>

<b>CPTRDB_SHOW_DB_BCK_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_DB_BCK.COM</b><br>
<b>CPTRDB_SHOW_DB_BCK_DAILY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>
<b>CPTRDB_SHOW_DB_BCK.REF</b>   (Reference file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_DB_BCK_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_DB_BCK[_DAILY].COM
</p>

<p>
  List database backup files in CPT$RDB_DB_BCK: on one node for a series of 
  databases on the current day. The dates listed are creation, expiration and 
  backup date. The databases on this node are identified in the configuration 
  file by the keywords CPT$RDB_NODE|CPTRDB_SHOW_DB_BCK
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_DB_BCK|L15S29|CPTRDB_DB_1|
CPT$RDB_NODE|CPTRDB_SHOW_DB_BCK|L15S29|CPTRDB_MASTR_DB|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_DB_BCK
! 2 Execution node
! 3 Database id truncated to char(18)
</pre>

<p>
<b>CPTRDB_SHOW_DB_BCK.COM</b><br>
  Calls CPTRDB_SHOW_DB_BCK_BATCH.COM
</p>

<p>
  Interactive list today's database backup files for a series of nodes and
  databases, identified in the configuration file CPTRDB_CONFIGURATION.REF by
  the keywords CPT$RDB_NODE|CPTRDB_SHOW_DB_BCK
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_DB_BCK
</pre>

  Output sample:<br>

<pre>
 3-APR-2015 12:51:41.63 CPTRDB Database Backup Files From Node L15S29
 
--------------
On Node L15S29
--------------
 
-- 1 CPTRDB_DB_1 --

Directory DISK$DATA_29:[CPT$RDB_DB_BCK]

CPTRDB_DB_1_L15S29_20150403_0035.RBF;1
                           7056   3-APR-2015 00:35:01.15   {None specified}  {No backup recorded}

Total of 1 file, 7056 blocks.
 
-- 2 CPTRDB_MASTR_DB --

Directory DISK$DATA_29:[CPT$RDB_DB_BCK]

CPTRDB_MASTR_DB_L15S29_20150403_0036.RBF;1
                           2079   3-APR-2015 00:36:19.89   {None specified}  {No backup recorded}

Total of 1 file, 2079 blocks.
</pre>

<p>
<b>CPTRDB_SHOW_DB_BCK_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_DB_BCK_BATCH.COM
</p>

<p>
  Daily list today's database backup files for a series of nodes and databases,
  identified in the configuration file CPTRDB_CONFIGURATION.REF by
  the keywords CPT$RDB_NODE|CPTRDB_SHOW_DB_BCK.

  Send CockpitMgr event and mail if differences are found with reference file
  CPTRDB_SHOW_DB_BCK.REF.
 
  The reschedule node, reschedule time and exception mail address are
  retrieved from the configuration file identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_DB_BCK_DAILY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_DB_BCK_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_DB_BCK_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_DB_BackupsDifferences
"CPTRDB - Database Backups Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - DB Backups Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 19"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 19 -- List And Check AIJ Backup Files
</font>
</h3>

<b>CPTRDB_SHOW_AIJ_BCK_ONE.COM</b><br><br>

<b>CPTRDB_SHOW_AIJ_BCK_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_AIJ_BCK.COM</b><br>
<b>CPTRDB_SHOW_AIJ_BCK_DAILY.COM</b><br><br>

<b>CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_AIJ_BCK_NOEXP.COM</b><br>
<b>CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>
<b>CPTRDB_SHOW_AIJ_BCK.REF</b>  (Reference file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_ONE.COM</b><br>
  List all AIJ backup files available in CPT$RDB_AIJ_BCK: for a single 
  database on the executor node. This list is created in CPT$RDB_DATA and
  can be used as input file to RMU/Recover.<br>

  The procedure handles the truncation to char(12) of the {dbid} in
  the AIJ backup filespecs.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_AIJ_BCK_ONE {dbid}
</pre>

  Output sample:<br>

<pre>
CPTRDB - AIJ Backup Files
For Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On Node:      L15S29
At:            3-APR-2015 12:57:55.24
 
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150327_1408_5206.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150327_1608_5207.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150327_1808_5208.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150327_2008_5209.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150327_2208_5210.AIJ_BCK;1
...
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150403_0007_5271.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150403_0608_5272.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150403_0808_5273.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150403_1008_5274.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150403_1208_5275.AIJ_BCK;1
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_AIJ_BCK[_DAILY].COM
</p>

<p>
  List [today's] AIJ backup files in CPT$RDB_AIJ_BCK: on one node, group by 
  database. The list of databases on this node is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords 
  CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK|L15S29|CPTRDB_DB_1|
CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK|L15S29|CPTRDB_MASTR|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_AIJ_BCK
! 2 Execution node
! 3 Database id truncated to char(12)
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_BCK.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_BCK_BATCH.COM
</p>

<p>
  Interactive list [today's] AIJ backup files for a number of databases on a 
  series of nodes retrieved from the configuration file 
  CPTRDB_CONFIGURATION.REF, identified by the keywords 
  CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK. List the AIJ backup files, grouped by
  database.
</p>

Usage:<br>

<pre>
Parameters: P1,   since date,  date vms
            [P2], before date, date vms

$ @CPTRDB_SHOW_AIJ_BCK yesterday
</pre>

Output sample:<br>

<pre>
CPTRDB - AIJ Backup Files From Node L15S29
Since:  28-NOV-2017 00:00:00.00
Before: 29-NOV-2017 00:00:00.00
At:     29-NOV-2017 15:55:58.37
 
--------------
On Node L15S29
--------------
 
-- 1 CPTRDB_DB_1 --

Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]

CPTRDB_DB_1_L15S29_20171128_0014_14966.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_0614_14967.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_0814_14968.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_1014_14969.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_1214_14970.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_1414_14971.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_1614_14972.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_1814_14973.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_2015_14974.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171128_2215_14975.AIJ_BCK;1
 
-- 2 CPTRDB_MASTR --

Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]

CPTRDB_MASTR_L15S29_20171128_0014_10467.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_0614_10468.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_0814_10469.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_1014_10470.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_1214_10471.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_1414_10472.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_1614_10473.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_1814_10474.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_2015_10475.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171128_2215_10476.AIJ_BCK;1
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_BCK_BATCH.COM
</p>

<p>
  Daily list today's AIJ backup files for a number of databases on a series 
  of nodes, retrieved from the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK. List the AIJ
  backup files grouped by database.<br>

  Send CockpitMgr event and mail if a difference is found with the reference 
  file CPTRDB_SHOW_AIJ_BCK.REF.<br>

  The reference file contains one entry per node/directory/database.
  Duplicate entries per database are removed in the comparison of the
  actual output to the reference file, as the number of AIJ backup files 
  per database is not predetermined.<br>

  Reschedule node, time and exception mail address are retrieved from the
  configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_AIJ_BCK_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_AIJ_BCK_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_AIJ_BCK_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_AIJ_BackupsDifferences
"CPTRDB - AIJ Backups Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - AIJ Backups Diff {node} yyyymmdd"
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_AIJ_BCK_NOEXP[_DAY].COM
</p>

<p>
  List not expired AIJ backup files on one node, group by database.
  The list of databases on this node is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK_NOEXP
</p>

<pre>
!                                             123456789012
CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK_NOEXP|L15S29|CPTRDB_DB_1|
CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK_NOEXP|L15S29|CPTRDB_MASTR|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_AIJ_BCK_NOEXP
! 2 Execution node
! 3 Database id truncated to char(12)
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_NOEXP.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM
</p>

<p>
  Interactive list not expired AIJ backup files for (all) databases on a
  series of nodes retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK_NOEXP
</p>

<pre>
Parameters: P1,   since date,  date vms
            [P2], before date, date vms
</pre>

<p>
  The presence of AIJ backup files, older than 24 hours, with no expiration day
  set, is an indication of potential problems in the cleaning section of the 
  AIJ backup procedure, or in additional processing of the AIJ backup file
  (such as extract of the updated data), before the expiration date is finally
  set. The output file should only list AIJ backup files created within the
  last 24 hours.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_AIJ_BCK_NOEXP yesterday today
</pre>

  Output sample:<br>

<pre> 
CPTRDB - Not Expired AIJ Backup Files From Node L15S29
Since:  4-DEC-2017 00:00:00.00
Before: 5-DEC-2017 00:00:00.00
At:     5-DEC-2017 15:05:17.04
 
--------------
On Node L15S29
--------------
 
-- 1 CPTRDB_DB_1 --
 
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
 
CPTRDB_DB_1_L15S29_20171204_1620_15032.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171204_1820_15033.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171204_2020_15034.AIJ_BCK;1
CPTRDB_DB_1_L15S29_20171204_2220_15035.AIJ_BCK;1
 
-- 2 CPTRDB_MASTR --
 
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
 
CPTRDB_MASTR_L15S29_20171204_1620_10533.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171204_1820_10534.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171204_2020_10535.AIJ_BCK;1
CPTRDB_MASTR_L15S29_20171204_2220_10536.AIJ_BCK;1
</pre> 

<p>
<b>CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_BCK_NOEXP_BATCH.COM
</p>

<p>
  Daily list not expired AIJ backup files for a series of nodes and databases,
  retrieved from the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_AIJ_BCK_NOEXP.<br>

  Send CockpitMgr event and mail if not expired AIJ backup files are found
  older than 24 hours, over the last three weeks.
</p>

<pre>
Parameters: none
</pre>

  Output sample:<br>

<pre>
Consider:

/*
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]

CPTRDB_DB_1_DUMMY.AIJ_BCK;1               File ID:  (901,105,0)
Size:            1/96         Owner:    [SYSTEM]
Created:     1-DEC-2017 00:00:00.00
Revised:     5-DEC-2017 15:54:23.40 (2)
Expires:    {None specified}
*/
</pre>

<pre> 
CPTRDB - Not Expired AIJ Backup Files From Node L15S29
Since:  12-NOV-2017
Before: 4-DEC-2017 15:54:54.90
At:     5-DEC-2017 15:54:54.97
 
--------------
On Node L15S29
--------------
 
-- 1 CPTRDB_DB_1 --
 
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
 
CPTRDB_DB_1_DUMMY.AIJ_BCK;1
 
-- 2 CPTRDB_MASTR --
 
Directory DISK$DATA_29:[CPT$RDB_AIJ_BCK]
 
 5-DEC-2017 15:54:55.38 *Show not expired AIJ backups check failed*
</pre> 

<p>
  The reschedule node, time and exception mail address are retrieved from the
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_AIJ_BCK_NOEXP_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_AIJ_BCK_NOEXP_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_AIJ_BCK_NOEXP_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_AIJ_NotExpiredBackups
"CPTRDB - AIJ Not Expired Backups <node> - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - AIJ Not Expired Backups <node> yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 20"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 20 -- List And Check Batch Entries
</font>
</h3>

<b>CPTRDB_BATCH_ENTRIES.COM</b><br>
<b>CPTRDB_BATCH_ENTRIES_DAILY.COM</b><br>
<b>CPTRDB_BATCH_ENTRIES.REF</b> (Reference file)<br><br>

<b>CPTRDB_SUBMIT_ALL_REF_GEN.COM</b><br>
<b>CPTRDB_SUBMIT_ALL_QUEUE_GEN.COM</b><br><br>

<b>CPTRDB_SHOW_ENTRIES_BATCH.COM</b><br>
<b>CPTRDB_SHOW_ENTRIES.COM</b><br>
<b>CPTRDB_SHOW_ENTRIES_DAILY.COM</b><br>
<b>CPTRDB_SHOW_ENTRIES.REF</b> (Reference file)<br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_BATCH_ENTRIES.COM</b><br>
  List and check the batch entries for a single user and single source
  directory across all CPT$RDB_BATCH_{node} queues, identified in the
  confuguration file CPTRDB_CONFIGURATION.REF by the keywords
  CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES<br>

  Requires the reference file CPTRDB_BATCH_ENTRIES.REF<br><br>

  *This procedure is deprecated. The use of CPTRDB_SHOW_ENTRIES.COM is
  recommended.*
</p>

<pre>
CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES|L15S29|[USERS.ALLEMEERSCH.CPT$RDB]|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_BATCH_ENTRIES
! 2 Node/Queue
! 3 Source filespecs directory (sub)string
</pre>

  Usage:<br>
  (As user of the submitted jobs)<br>

<pre>
$ @CPTRDB_BATCH_ENTRIES
</pre>

  Output sample:<br>

<pre>
 3-APR-2015 13:04:56.02 CPTRDB - Batch Entries Differences From Node L15S29

Number of difference sections found: 0
Number of difference records found: 0

DIFFERENCES
/MERGED=1/OUTPUT=DISK$USERS:[ALLEMEERSCH.CPT$RDB]BATCH_ENTRIES.DIFF;176-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]CPTRDB_BATCH_ENTRIES.REF;197-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]BATCH_ENTRIES.TMP_REF;176

Output CPT$RDB_LISTS:BATCH_ENTRIES_L15S29_20150403.LIS_03APR130456
</pre>

<p>
  The output files<br>
  BATCH_ENTRIES[_DAILY].DIFF<br>
  BATCH_ENTRIES[_DAILY].TMP_REF<br>
  are created in CPT$RDB and not in CPT$RDB_LISTS for easy comparison with
  the reference file CPTRDB_BATCH_ENTRIES.REF, which is an exception to
  the toolset file location conventions.
</p>

<p>
  If batch entries have changed, such as a new version of command file, use
</p>

<pre>
$ @CPTRDB_RENAME_CDT CPTRDB_BATCH_ENTRIES.REF
$ copy BATCH_ENTRIES.TMP_REF CPTRDB_BATCH_ENTRIES.REF
or
$ edit CPTRDB_BATCH_ENTRIES.REF
</pre>

  to confirm the new version(s) as reference.<br>
  
<p>
<b>CPTRDB_BATCH_ENTRIES_DAILY.COM</b><br>
  (As user of the submitted jobs)<br>

  Daily list and check the batch entries for a single user and source directory
  across all CPT$RDB_BATCH_<node> queues, identified in the confuguration
  file CPTRDB_CONFIGURATION.REF by the keywords
  CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES<br>

  Send a CockpitMgr event and mail if a difference is found with the
  reference file CPTRDB_BATCH_ENTRIES.REF<br><br>

  *This procedure is deprecated. The use of CPTRDB_SHOW_ENTRIES_DAILY.COM is
  recommended.*
</p>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_BatchEntriesDifferences
"CPTRDB - Batch Entries Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Batch Entries Diff {node} yyyymmdd"
</pre>


<p>
  The reschedule node, time and exception mail address are retrieved from the
  configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_BATCH_ENTRIES_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_BATCH_ENTRIES_DAILY|L15S29|TOMORROW + 08:15|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_BATCH_ENTRIES_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

<p>
<b>CPTRDB_SUBMIT_ALL_REF_GEN.COM</b><br>
  Generate a summary command file to submit all toolset batch jobs
  in the CPT$RDB_BATCH_{node} queues, as listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keyword CPT$RDB_JOB.
</p>
  
<p>
  The generated command file assumes that the procedures CPTRDB_SUBMIT.COM
  and JCCLML_SUBMIT.COM handle the P3 parameter /AFTER={date time}
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT_ALL_REF_GEN
</pre>

  Output sample:<br>

<pre>
$!
$! Generated by CPTRDB On Node L15S29 At 27-SEP-2016 15:00:40.92
$!
$ @CPTRDB_SUBMIT L15S29 CPTRDB_ANA_DBS_WEEKLY          "TOMORROW +6-04:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BACKUP_AIJ_ALL          "+00:30"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BACKUP_DB_ALL           "TOMORROW + 00:35"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BATCH_ENTRIES_DAILY     "TOMORROW + 08:15"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_CLEANUP_JDBC_LOGS_ALL   "TOMORROW + 05:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_CLEANUP_LOGS_DAILY      "TOMORROW + 08:30"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_DDLCK_CNTS_ALL          "TOMORROW + 04:30"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_RESTART_JDBC_ALL        "TOMORROW + 00:16"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_AIJ_BCK_DAILY      "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_AIJ_LIVE_DAILY     "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_BUGCHECK_DAILY     "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_DBS_OPEN_DAILY     "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_DB_BCK_DAILY       "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_EXTENTS_DAILY      "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_JDBC_LOGS_DAILY    "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_JDBC_PROCESS_DAILY "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_SQLSRV_DAILY       "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_STATS_DAILY        "TOMORROW + 08:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SRVTRC_CLIENTS_ALL      "TOMORROW + 04:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_CNTS_ALL          "TOMORROW + 04:40"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_RW_CNTS_ALL       "TOMORROW + 05:00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_RW_TIMES_ALL      "TOMORROW + 05:10"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_TIMES_ALL         "TOMORROW + 04:50"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_TRNC_SNAPS_ALL          "TOMORROW +6-03:30"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_REOPEN_LOGS_ALL     "TOMORROW + 00:02"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_AERCP_CONT     "+00:30"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_HEARTBEAT_CONT "+00:30"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_PROCESS_DAILY  "TOMORROW + 08:00"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_STATS_DAILY    "TOMORROW + 08:10"
$!
$! Total number of jobs: 29
$!
</pre>

<p>
<b>CPTRDB_SUBMIT_ALL_QUEUE_GEN.COM</b><br>
  Generate a summary command file to submit all toolset batch jobs
  in the CPT$RDB_BATCH_{node} queues, as they actually exist in the queues,
  listed in the configuration file CPTRDB_CONFIGURATION.REF identified by the
  keywords CPT$RDB_NODE|CPTRDB_BATCH_ENTRIES
</p>
  
<p>
  The generated command file assumes that the procedures CPTRDB_SUBMIT.COM
  and JCCLML_SUBMIT.COM handle the P3 parameter /AFTER={date time}
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT_ALL_QUEUE_GEN
</pre>

  Output sample:<br>

<pre>
$!
$! Generated by CPTRDB On Node L15S29 At 27-SEP-2016 15:17:25.25
$!
$ @CPTRDB_SUBMIT L15S29 CPTRDB_ANA_DBS_WEEKLY          " 3-OCT-2016 04:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BACKUP_AIJ_ALL          "27-SEP-2016 15:37:30.48"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BACKUP_DB_ALL           "28-SEP-2016 00:35:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_BATCH_ENTRIES_DAILY     "28-SEP-2016 08:15:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_CLEANUP_JDBC_LOGS_ALL   "28-SEP-2016 05:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_CLEANUP_LOGS_DAILY      "28-SEP-2016 08:30:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_DDLCK_CNTS_ALL          "28-SEP-2016 04:30:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_AIJ_BCK_DAILY      "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_AIJ_LIVE_DAILY     "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_BUGCHECK_DAILY     "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_DBS_OPEN_DAILY     "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_DB_BCK_DAILY       "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_EXTENTS_DAILY      "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_JDBC_LOGS_DAILY    "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_JDBC_PROCESS_DAILY "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_SQLSRV_DAILY       "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SHOW_STATS_DAILY        "28-SEP-2016 08:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_SRVTRC_CLIENTS_ALL      "28-SEP-2016 04:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_CNTS_ALL          "28-SEP-2016 04:40:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_RW_CNTS_ALL       "28-SEP-2016 05:00:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_RW_TIMES_ALL      "28-SEP-2016 05:10:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_STALL_TIMES_ALL         "28-SEP-2016 04:50:00.00"
$ @CPTRDB_SUBMIT L15S29 CPTRDB_TRNC_SNAPS_ALL          " 3-OCT-2016 03:30:00.00"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_REOPEN_LOGS_ALL     "28-SEP-2016 00:02:00.00"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_AERCP_CONT     "27-SEP-2016 15:32:31.22"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_HEARTBEAT_CONT "27-SEP-2016 15:32:31.00"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_PROCESS_DAILY  "28-SEP-2016 08:00:00.00"
$ @JCCLML_SUBMIT L15S29 JCCLML_LML_SHOW_STATS_DAILY    "28-SEP-2016 08:10:00.00"
$!$ Running Entry 893 # @CPTRDB_SHOW_STAT_LOGS_GO L15S29 CPTRDB_DB_1 7.3
$!$ Running Entry 894 # @CPTRDB_SHOW_STAT_DATA_GO L15S29 CPTRDB_DB_1 7.3
$!$ Running Entry 897 # @JCCLML_SUBMIT L15S29 JCCLML_JCC_RUN_CTL-CPTRDB_LML
$!$ Running Entry 899 # @JCCLML_JCC_RUN_DTL_GO L15S29 CPTRDB_LML
$!
$! Total number of jobs: 32
$!
</pre>

<p>
  Note that the job CPTRDB_RESTART_JDBC_ALL is present in the configuration
  file, but has no corresponding queue entry.<br>

  The output of this procedure is the condensed version of the output for
  the procedure CPTRDB_TOOLSET_START_GEN.COM<br>

  It is recommended to preserve both generated command files as a precautional
  measure for later reference, in case queue and/or job information may be
  lost due to some problem or incident. 
</p>

<p>
<b>CPTRDB_SHOW_ENTRIES_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_ENTRIES[_DAILY].COM
</p>

<p>
  List the queue entries for one node, user, queue and source directory
  (sub)string on the executor node.
</p>

<pre>
[Internal Parameters: P1, queue name
                      P2, source filenames directory (sub)string
                      P3, output filename, SHOW_ENTRIES.TMP_{filecnt}]
</pre>

<p>
<b>CPTRDB_SHOW_ENTRIES.COM</b><br>
  Calls CPTRDB_SHOW_ENTRIES_BATCH.COM
</p>

<p>
  Interactive list queue entries for multiple nodes, users, queues and 
  directories, identified in the configuration file CPTRDB_CONFIGURATION.REF 
  by the keywords CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES.
</p>

<pre>
! -- List queue entries for multiple nodes, users, queues and directories
CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES|L15S29|RDBMON|CPT$RDB_BATCH_L15S29|CPT$RDB|
CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES|L15S28|RDBMON|CPT$RDB_BATCH_L15S28|CPT$RDB|
CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES|L15S28|RDBMON|RDB$BATCH_L15S28|RDB$PROCS|
CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES|L15S29|RDBMON|RDB$BATCH_L15S29|RDB$PROCS|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_ENTRIES
! 2 Exec node
! 3 Exec user
! 4 Queue name
! 5 Source filespecs directory (sub)string
</pre>

<p>
  Compare the results to the reference file CPTRDB_SHOW_ENTRIES.REF
</p>

<p>
  The output files SHOW_ENTRIES[_DAILY].[TMP_REF|DIFF] are created in the 
  default directory CPT$RDB or 'defdir' for ease of comparison with the
  reference file CPTRDB_SHOW_ENTRIES.REF, which is an exception to the
  toolset file location conventions.
</p>

  Parameters: None<br><br>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ENTRIES
</pre>

  Output sample:<br>

<pre>
Number of difference sections found: 0
Number of difference records found: 0

DIFFERENCES
/MERGED=1/OUTPUT=DISK$USERS:[ALLEMEERSCH.CPT$RDB]SHOW_ENTRIES.DIFF;37-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_ENTRIES.REF;17-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]SHOW_ENTRIES.TMP_REF;37

List: CPT$RDB_LISTS:SHOW_ENTRIES_L15S29_20180305.LIS_05MAR153840
Diff: CPT$RDB_LISTS:SHOW_ENTRIES_L15S29_20180305.DIFF_05MAR153840

====

 5-MAR-2018 15:38:40.37 CPTRDB - Show Entries [Differences] From Node L15S29
 
-----------------------------
On Node: L15S29
Queue:   CPT$RDB_BATCH_L15S29
User:    RDBMON      
Source:  CPT$RDB
-----------------------------
 
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_ANA_DBS_WEEKLY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BACKUP_AIJ_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BACKUP_DB_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_BATCH_ENTRIES_DAILY.COM;3
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_CLEANUP_JDBC_LOGS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_CLEANUP_LOGS_DAILY.COM;3
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_COLLECT_STAT_WEEKLY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_DDLCK_CNTS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_AIJ_BCK_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_AIJ_BCK_NOEXP_DAY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_AIJ_LIVE_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_BUGCHECK_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_DBS_OPEN_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_DB_BCK_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_ENTRIES_DAILY.COM;14
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_EXTENTS_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_JDBC_LOGS_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_SQLSRV_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STATS_DAILY.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_DATA.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_STAT_LOGS.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_SRVTRC_CLIENTS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_STALL_CNTS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_STALL_RW_CNTS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_STALL_RW_TIMES_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_STALL_TIMES_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]CPTRDB_TRNC_SNAPS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_JCC_RUN_DTL.COM;2
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_REOPEN_LOGS_ALL.COM;1
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_AERCP_CONT.COM;3
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_HEARTBEAT_CONT.COM;3
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_PROCESS_DAILY.COM;5
_DSA30:[USERS.ALLEMEERSCH.CPT$RDB]JCCLML_LML_SHOW_STATS_DAILY.COM;3
Number of jobs: 35
 
-----------------------------
On Node: L15S28
Queue:   CPT$RDB_BATCH_L15S28
User:    RDBMON      
Source:  CPT$RDB
-----------------------------
 
Number of jobs: 0
 
-----------------------------
On Node: L15S28
Queue:   RDB$BATCH_L15S28
User:    RDBMON      
Source:  RDB$PROCS
-----------------------------
 
_DSA30:[USERS.ORACLE.RDB$PROCS]CLEANUP_JDBC_LOGS_ALL.COM;9
_DSA30:[USERS.ORACLE.RDB$PROCS]CLEANUP_RDB_LOGS.COM;46
_DSA30:[USERS.ORACLE.RDB$PROCS]CPTRDB_BATCH_ENTRIES_DAILY.COM;23
_DSA30:[USERS.ORACLE.RDB$PROCS]CPTRDB_SHOW_SQLSRV_DAILY.COM;9
_DSA30:[USERS.ORACLE.RDB$PROCS]DEFINE_SLS_DB_ALL.COM;8
_DSA30:[USERS.ORACLE.RDB$PROCS]PURGE_LISA_SALES.COM;18
_DSA30:[USERS.ORACLE.RDB$PROCS]RESTART_JDBC_ALL.COM;15
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_AIJLIVE_ALL_V2.COM;18
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_AIJ_BCK_NOEXP_V2.COM;2
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_AIJ_BCK_V2.COM;17
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_BUGCHECK_V2.COM;6
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_DBS_OPEN_V2.COM;6
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_EXTENTS_V2.COM;27
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_JDBC_LOGS_V2.COM;19
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_JDBC_PROCESS_V2.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_RDB_AGENT_V2.COM;6
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_RDB_BCK_V2.COM;11
_DSA30:[USERS.ORACLE.RDB$PROCS]SHOW_STATS_V2.COM;7
_DSA30:[USERS.ORACLE.RDB$PROCS]TRNC_SNAPS_ALL.COM;8
_DSA30:[USERS.ORACLE.RDB$PROCS]X11_KEEP_ALIVE_V2.COM;8
Number of jobs: 34
 
-----------------------------
On Node: L15S29
Queue:   RDB$BATCH_L15S29
User:    RDBMON      
Source:  RDB$PROCS
-----------------------------
 
_DSA30:[USERS.ORACLE.RDB$PROCS]BACKUP_AIJ_ALL.COM;30
_DSA30:[USERS.ORACLE.RDB$PROCS]BACKUP_DB_ALL.COM;12
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_DATA.COM;13
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
_DSA30:[USERS.ORACLE.RDB$PROCS]RMU_SHOW_STAT_LOGS.COM;20
Number of jobs: 16

==== 

Number of difference sections found: 0
Number of difference records found: 0

DIFFERENCES /MERGED=1/OUTPUT=DISK$USERS:[ALLEMEERSCH.CPT$RDB]SHOW_ENTRIES.DIFF;37-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]CPTRDB_SHOW_ENTRIES.REF;17-
    DISK$USERS:[ALLEMEERSCH.CPT$RDB]SHOW_ENTRIES.TMP_REF;37
</pre>

<p>
<b>CPTRDB_SHOW_ENTRIES_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_ENTRIES_BATCH.COM
</p>

<p>
  Daily list queue entries for a number of nodes, users, queues and
  directories, identified in the configuration file CPTRDB_CONFIGURATION.REF
  by the keywords CPT$RDB_NODE|CPTRDB_SHOW_ENTRIES.
</p>
  
<p>
  Send a CockpitMgr event and mail if differences are found with the
  reference file CPTRDB_SHOW_ENTRIES.REF
</p>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_ShowEntriesDifferences
"CPTRDB - Show Entries Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Show Entries Diff {node} yyyymmdd"
</pre>

<p>
  The reschedule node, time and exception mail address are retrieved from the
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_ENTRIES_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_ENTRIES_DAILY|L15S29|TOMORROW + 08:20|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_ENTRIES_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 21"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 21 -- List And Check Live AIJ Files
</font>
</h3>

<b>CPTRDB_SHOW_AIJ_LIVE_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_AIJ_LIVE_ONE.COM</b><br>
<b>CPTRDB_SHOW_AIJ_LIVE.COM</b><br>
<b>CPTRDB_SHOW_AIJ_LIVE_DAILY.COM</b><br><br>

<b>CPTRDB_SHOW_AIJ_LIVE_DUMP.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_AFTER_JOURNAL_ADD.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_ALLOCATION.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_DROP.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_EDIT_FILENAME.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_RESERVE.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_SHUTDOWN_TIMEOUT.COM</b><br>
<b>CPTRDB_AFTER_JOURNAL_DROP_GEN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_AIJ_LIVE_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_AIJ_LIVE[_[ONE|DAILY]].COM
</p>

<p>
  List the status of the live AIJ files for one database.
</p>

  Per AIJ slot the procedure lists:<br>

<pre>
  rdb$journal_name
  rdb$sequence_number
  state -- current latent written
  status
  endoffile
  fullness
  rdb$allocation
  last_activated
  last_backup
  rdb$filename
  --
  total number of journals
  total size
  --
  flags
</pre>

  Output sample for one database:<br>

<pre>
-- 1 CPTRDB_DB_1 --
 
Live AIJ Journals For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29
At 2015-01-15 08:00:02
------------------------------------------------------------------------------------------------------------------------------------
AIJ1| 4493|Current|Accessible|    26| 0|500000|2015-01-15 06:27|2015-01-14 22:27|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_1.AIJ;1
AIJ2|   -1|Latent |Accessible|     0| 0|500000|2015-01-14 22:27|2015-01-15 00:27|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_2.AIJ;1
AIJ3|   -1|Latent |Accessible|     0| 0|500000|2015-01-15 00:27|2015-01-15 06:27|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_3.AIJ;1
------------------------------------------------------------------------------------------------------------------------------------
Number Of Live AIJ Journals 3
Total Size                  1500000
------------------------------------------------------------------------------------------------------------------------------------
AIJ1|AIJ file has been modified|AIJ file block has been assigned|
AIJ2|AIJ file block has been assigned|
AIJ3|AIJ file block has been assigned|
------------------------------------------------------------------------------------------------------------------------------------
</pre> 

<p>
<b>CPTRDB_SHOW_AIJ_LIVE_ONE.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_LIVE_BATCH.COM
</p>

<p>
  Interactive list the live AIJ files for one database on the executor node,
  using the current Rdb version.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_AIJ_LIVE_ONE {dbid}
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_LIVE_DUMP.COM</b><br>
  Interactive list the live AIJ files of one database on the executor node, 
  by dumping the header blocks, using RMU/Dump/After of the current Rdb version.
</p>

  Usage:<br>

<pre>
  $ @CPTRDB_SHOW_AIJ_LIVE_DUMP {dbid}
</pre>

  Output sample:<br>

<pre>
--  9-JUL-2015 11:16:44.92 Handle CPTRDB_MASTR_DB V7.3 --

For Database DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB
*     Filename: CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_1.AIJ;1
    AIJ Sequence Number is 1763
    Switch-over message sequence number is 175
*     Filename: CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_2.AIJ;1
    AIJ Sequence Number is -1
*     Filename: CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_3.AIJ;1
    AIJ Sequence Number is -1
Output CPT$RDB_LISTS:AIJ_LIVE_CPTRDB_MASTR_DB_L15S29_2015070.LIS_09JUL111644
</pre>

  The output file contains the full dump of the header blocks:<br>

<pre>
Live AIJ Files Dump
For Database DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB
On Node      L15S29
At            9-JUL-2015 11:16:44.93
 
*------------------------------------------------------------------------------
* Oracle Rdb V7.3-120                                    9-JUL-2015 11:16:45.12
*
* Dump of After Image Journal 
*     Filename: CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_1.AIJ;1
*
*------------------------------------------------------------------------------

1/1              TYPE=O, LENGTH=510, TAD= 9-JUL-2015 10:00:27.10, CSM=00
    Database DSA29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1
    Database timestamp is 14-JAN-2015 15:05:53.01
    Facility is "RDMSAIJ ", Version is 721.0
    Database version is 73.0
    AIJ Sequence Number is 1763
    Switch-over message sequence number is 175
    Last Commit TSN is 451341
    Synchronization TSN is 0
    Journal created on VMS platform
    Type is Normal (unoptimized)
    Open mode is Initial
    Backup type is Active
    I/O format is Record
    Commit-to-Journal optimization disabled
    Switchover by process 2DE912DF
    AIJ journal activation ID is 00AF13940E108215
    LogMiner is enabled

Display terminated at user request after AIJ record 1

1 total modification record

...
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_LIVE.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_LIVE_BATCH.COM
</p>

<p>
  Interactive list the live AIJ files for a series of databases
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_DATABASE|CPTRDB_SHOW_AIJ_LIVE
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_AIJ_LIVE|CPTRDB_DB_1|7.3|L15S29|
CPT$RDB_DATABASE|CPTRDB_SHOW_AIJ_LIVE|CPTRDB_MASTR_DB|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_AIJ_LIVE
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_AIJ_LIVE
</pre>

  Output sample:<br>

<pre>
 3-APR-2015 13:13:00.56 CPTRDB Live AIJ Files From Node L15S29
 
-- 1 CPTRDB_DB_1 --
 
Live AIJ Journals For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29
At 2015-04-03 13:13:00
------------------------------------------------------------------------------------------------------------------------------------
AIJ1| 5276|Current|Accessible|    19| 0|500000|2015-04-03 12:08|2015-04-03 08:08|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_1.AIJ;1
AIJ2|   -1|Latent |Accessible|     0| 0|500000|2015-04-03 08:08|2015-04-03 10:08|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_2.AIJ;1
AIJ3|   -1|Latent |Accessible|     0| 0|500000|2015-04-03 10:08|2015-04-03 12:08|CPT$RDB_AIJ:[CPTRDB_DB_1]CPTRDB_DB_1_JRNL_3.AIJ;1
------------------------------------------------------------------------------------------------------------------------------------
Number Of Live AIJ Journals 3
Total Size                  1500000
------------------------------------------------------------------------------------------------------------------------------------
AIJ1|AIJ file has been modified|AIJ file block has been assigned|
AIJ2|AIJ file block has been assigned|
AIJ3|AIJ file block has been assigned|
------------------------------------------------------------------------------------------------------------------------------------
 
-- 2 CPTRDB_MASTR_DB --
 
Live AIJ Journals For Database
DSA29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1
On Node L15S29
At 2015-04-03 13:13:01
------------------------------------------------------------------------------------------------------------------------------------
AIJ1|   -1|Latent |Accessible|     0| 0|100000|2015-04-03 10:08|2015-04-03 12:08|CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_1.AIJ;1
AIJ2|   -1|Latent |Accessible|     0| 0|100000|2015-04-03 08:08|2015-04-03 10:08|CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_2.AIJ;1
AIJ3|  792|Current|Accessible|     2| 0|100000|2015-04-03 12:08|2015-04-03 08:08|CPT$RDB_AIJ:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB_JRNL_3.AIJ;1
------------------------------------------------------------------------------------------------------------------------------------
Number Of Live AIJ Journals 3
Total Size                  300000
------------------------------------------------------------------------------------------------------------------------------------
AIJ1|AIJ file block has been assigned|
AIJ2|AIJ file block has been assigned|
AIJ3|AIJ file has been modified|AIJ file block has been assigned|
------------------------------------------------------------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_AIJ_LIVE_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_AIJ_LIVE_BATCH.COM
</p>

<p>
  Daily list live AIJ's status for a series of databases enumerated in the
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|CPTRDB_SHOW_AIJ_LIVE.

  Send CockpitMgr event and mail if exceptions are found, or a emergency
  journal exists.

  Exceptions are flagged with "*{exception}*" in the output file.
</p>

  Exception flags are:<br>

<pre>
  *Inaccessible*
  *Backup Needed*
  *Initialization in progress*
  *Backup in progress*
  *AIJ restored from existing file*
  *Hard data loss resulted from fail over*
  *Soft data loss resulted from fail over*
  *New version of journal created*
  *Journal has been overwritten*
  *Backup failed prematurely*
  *Journal created due to switch-over suspension*
  *Journal created for recovery synchronization*

  *Backup denied* is not handled as this status is not documented (?).
</pre>

  Normal flags are:<br>

<pre>
  AIJ file block has been assigned
  AIJ file has been modified
</pre>

<p>
  The reschedule node, reschedule time and exception mail address are 
  retrieved from the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_JOB|CPTRDB_SHOW_AIJ_LIVE_DAILY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_AIJ_LIVE_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_AIJ_LIVE_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_AIJ_LiveExceptions
"CPTRDB - AIJ Live Exceptions {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - AIJ Live Exceptions {node} yyyymmdd"
</pre>

<p>
If an exception is reported, search the output file for "*" or "emergency".
</p>

<p>
<b>CPTRDB_AFTER_JOURNAL_ADD.COM</b><br>
  Add online one live AIJ journal file to a database.
</p>
  
<p>
  Requires a free AIJ slot in the root file. AIJ slots can only be added to
  a closed database using: 
</p>

<pre>
SQL> alter database filename {dbid} reserve {n} journals;
or
$ @CPTRDB_AFTER_JOURNAL_RESERVE.COM
</pre>
  
<p>
  Use CPTRDB_SHOW_AIJ_LIVE_ONE.COM to check the live AIJ files status.
  Use RMU/Show Statistics "Journaling Information|AIJ Journal Information"
  to check for free AIJ slots.
</p>

  Parameters: Adapt the parameter block<br>

<pre>
$!---------------------------------------------
$ dbid          = "CPTRDB_DB_1"
$ aij_live_dir  = "CPT$RDB_AIJ:[''dbid']"
$ aij_bck_dir   = "CPT$RDB_AIJ_BCK:"
$ aij_name      = "AIJ4"
$ aij_nbr       = "4"
$ aij_live_file = "''dbid'_JRNL_''aij_nbr'.AIJ"
$ aij_bck_file  = "''dbid'_.AIJ_BCK"
$ aij_alloc     = "500000"
$!---------------------------------------------
</pre>

<p>
<b>CPTRDB_AFTER_JOURNAL_ALLOCATION.COM</b><br>
  Alter online the allocation for a (series of) live AIJ file(s) of a database.
  The new value will be applied at the next initialization of the live AIJ file.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------------
$ dbid        = "CPTRDB_DB_1"
$ aij_name1   = "AIJ1"
$ aij_name2   = "AIJ2"
$ aij_name3   = "AIJ3"
$ alloc_value = "500000" ! blocks
$!-------------------------------
</pre>

<p>
<b>CPTRDB_AFTER_JOURNAL_DROP.COM</b><br>
  Drop online one live AIJ journal file from a database.
</p>

<p>
  Requires the state 'Latent' for the to be deleted live AIJ journal file.
  Use CPTRDB_SHOW_AIJ_LIVE_ONE.COM to check the live AIJ files state.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------
$ dbid     = "CPTRDB_DB_1"
$ aij_name = "AIJ4"
$!$ aij_name = "EMERGENCY_00AFF255EAE4041E"
$!-----------------------------------------
</pre>

<p>
 To force a AIJ journal switch and free up a 'Current' or 'Written' AIJ slot 
 to the state 'Latent', rename today's AIJ backup files in CPT$RDB_AIJ_BCK: to
 a [.RENAME] subdirectory, and run the job CPTRDB_BACKUP_AIJ_ALL.
</p>

<p>
<b>CPTRDB_AFTER_JOURNAL_EDIT_FILENAME.COM</b><br>
  Set online the AIJ backup file filespec edit string for a database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!--------------------------------------------------------------------------
$ dbid        = "CPTRDB_DB_1"
$ file_suffix = "(YEAR,MONTH,DAY_OF_MONTH,""_"",HOUR,MINUTE,""_"",SEQUENCE)"
$!--------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_AFTER_JOURNAL_RESERVE.COM</b><br>
  Offline add AIJ slots to the root file of a database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------------
$ dbid            = "CPTRDB_DB_1"
$ nbr_aij_slots   = "1"
$!-------------------------------
</pre>

<p>
  The database must be closed to execute this procedure, as the root file is 
  being changed physically. Otherwise the messages below are issued.
</p>

<pre>
%RMU-I-WAITOFF, Waiting for offline access to DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
%RMU-I-WAITOFF, Waiting for offline access to DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
%RMU-I-WAITOFF, Waiting for offline access to DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
%RMU-I-WAITOFF, Waiting for offline access to DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
%RMU-I-WAITOFF, Waiting for offline access to DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
%RMU-F-FILACCERR, error opening database root file DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
-COSI-E-FLK, file currently locked by another user
%RMU-F-FTL_SET, Fatal error for SET operation at  4-FEB-2016 16:32:24.02
</pre>

<p>
<b>CPTRDB_AFTER_JOURNAL_SHUTDOWN_TIMEOUT.COM</b><br>
  Set online the database shutdown timeout value, which is applied
  when no more AIJ journal files are available: all live AIJ files full and/or
  inaccessible and/or in *Backup Needed* ..., and all AIJ slots used.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------
$ dbid          = "CPTRDB_DB_1"
$ timeout_value = "4320" ! minutes = 3 days
$!-----------------------------------------
</pre>

<p>
  This value should allow to survive a weekend and avoid a database shutdown.
</p>

<p>
  Note that if<br>
  all live AIJ files are full,<br>
  and the AIJ Log Server ALS process is running,<br>
  and the logical RDM$BIND_ALS_CREATE_AIJ is defined as "1",<br>
  Rdb will create emergency live AIJ files named EMERGENCY_{timestamp in hex}
  with the same allocation and in the same or RDM$BIND_AIJ_EMERGENCY_DIR
  directory as the AIJ file being switched from.
</p>

<p>
  Rdb will continue to do so until all AIJ slots in the root file are used
  (or device full) in which case the shutdown timeout timer starts running.
  If no AIJ space is freed within the timeout delay the database will shut
  down.
</p>

<p>
  If the logical RDM$BIND_ALS_CREATE_AIJ is defined as "0", no emergency
  journals will be created.
</p>

<p>
  Always make up a detailed diagnosis of why the database was shut down
  and first attempt a noquiet point AIJ backup, before deciding on a AIJ
  disable, drop, recreate, reenable and full database backup.
</p>

<p>
  Refer to My Oracle Support Document Id 62665.1 'AIJ Journaling Switch-Over
  Recovery & Failure Prevention' for a in depth discussion of the AIJ
  suspend state and database shutdown.
</p>

<p>
  As of Rdb V7.3-200 the command RMU/SET AFTER_JOURNAL/SWITCH_JOURNAL is
  able to create a emergency journal file while the database is in AIJ
  suspend state. Refer to the Rdb V7.3.x.x New Features Document for
  more information.
</p>

<p>
<b>CPTRDB_AFTER_JOURNAL_DROP_GEN.COM</b><br>
  Generate a command file in CPT$RDB_DATA: to drop latent emergency live
  AIJ files for a given database.
</p>

<p>
  Parameters: P1, database logical, varchar(255)
</p>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_AFTER_JOURNAL_DROP_GEN {dbid}
</pre>

<p>
  Output sample:
</p>

<pre>
$!
$! Generated By CPTRDB On Node L15S55 At 2016-08-29 12:13:26
$!
$ set nover
$ on error then goto exit_procedure
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$!
$ set ver
$!
$ rmu/set after_journal /drop=(name=EMERGENCY_00B0E18B9B88BB0A) ACC_DB_B01S15
$ rmu/set after_journal /drop=(name=EMERGENCY_00B0E18C514FE436) ACC_DB_B01S15
$!
$ set nover
$!
$exit_procedure:
$ set nover
$ exit
</pre>

<p>
 Refer to the procedure CPTRDB_CVT_FROM_HEX.COM to interprete the hexadecimal
 timestamp in the emergency live AIJ file filespecs.
</p>

<p>
Usage:
</p>

<pre>
$ @CPTRDB_CVT_FROM_HEX timestamp 00B0E18B9B88BB0A
Hex:  00B0E18B9B88BB0A
Char: 24-AUG-2016 12:29:22.72

$ @CPTRDB_CVT_TO_HEX timestamp 24-AUG-2016 12:29:22.72
Char: 24-AUG-2016 12:29:22.72
Hex:  00B0E18B9B889A00

$ @CPTRDB_CVT_from_HEX timestamp 00B0E18B9B880000
Hex:  00B0E18B9B880000
Char: 24-AUG-2016 12:29:22.71
</pre>

<p>
Note that the hundredth's of seconds {.CC} in the translated timestamp are not
reliable.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 22"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 22 -- Cleanup Log And Output Files
</font>
</h3>

<b>CPTRDB_CLEANUP_LOGS_DAILY.COM</b><br>
<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<p>
  Catchall cleanup the toolset's general directories, dedicated directories,
  daily logfiles and JCC LML daily logfiles. In most cases the individual
  log and output files are cleaned by the repeating procedures themselves.
  This procedure handles any overlooked files, such as the output
  of interactive procedures.

  Stall logs, size and T4 data are cleaned by this procedure.

  The general retention interval is 22 days for output files, 8 days 
  for daily logfiles and mime files. In other words, three or one
  full week(s) from weekday to weekday.

  The reschedule node and time are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_JOB|CPTRDB_CLEANUP_LOGS_DAILY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_CLEANUP_LOGS_DAILY|L15S29|TOMORROW + 08:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_CLEANUP_LOGS_DAILY
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 23"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 23 -- Quick Interactive Check
</font>
</h3>

<b>CPTRDB_DAILY.COM</b><br>

<p>
  Quick interactive check on log and output files for a specific day.
  The procedure lists the *.mime* files and searches .log* and .lis* files 
  for a string indicating an exception such as
  "*Show ... check failed*".<br>

  The default day is today.<br>
  No output file is created.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_DAILY [{vms_date}]
</pre>

  A typical quick check would consist of:<br>

<pre>
$ SET DEF CPT$RDB:
$ @CPTRDB_BATCH_ENTRIES
$ @CPTRDB_SHOW_ENTRIES
$ PIPE @CPTRDB_DAILY [{vms_date}] > x.x
$ EDIT x.x
$ EDIT CPT$RDB_LISTS:SHOW_AIJ_BCK_{node}_yyyymmdd.LIS_ddmmmhhmmss
$ DIRE CPT$RDB_LISTS:*.MIME*
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 24"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 24 -- Collect RMU/Show Statistics Stall And Deadlock Messages
</font>
</h3>

<b>CPTRDB_SHOW_STAT_LOGS_ALL.COM</b> (Calls)<br>
<b>CPTRDB_SHOW_STAT_LOGS_GO.COM</b>  (Calls)<br>
<b>CPTRDB_SHOW_STAT_LOGS.COM</b><br>
<b>CPTRDB_SHOW_STAT_LOGS.CONFIG</b><br><br>

<b>CPTRDB_STOP_STATS.COM</b> (Calls)<br>
<b>CPTRDB_STOP_STATS_BATCH.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_SEARCH_WAITING_FOR.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The gathering and analysis of stall and deadlock messages per database and
node, using RMU/Show Satistics sessions in batch, should be considered
mandatory in each (at least production) environment. They allow a detailed
insight into the internal functioning of the database, and contain direct
indications of concurrency issues and other potential problem areas.
</p>

<p>
The toolset handles the analysis of the most frequent 'waiting for' stall
messages in separate procedures from the less frequent NOT 'waiting for',
named Read/Write RW, procedures.
</p>

<p>
A nearly complete set of all possible stall messages written to the stall log 
files is listed below:
</p>

<pre>
Bugcheck: !AD
Processing pending messages
Processing pending redo
RCS idle -waiting for work request
RCS waiting for !AD cache record latch !AD
binding to database
committing TSN !UL:!UL
connecting to remote database (!UL)
creating AIJ backup file
creating RCS process
creating storage area !UL
creating temporary AIJ journal
extending AIJ file
extending RUJ file
extending storage area !UL
finding buffer for record cache !AD
hibernating for !AD cache latch
hibernating on AIJ I/O completion
hibernating on AIJ submission
initializing AIJ journal
initializing new AIJ journal
latching page !UL:!UL in GB
opening storage area !AD file
performing cluster statistics collection
performing local statistics collection
prepared, waiting to commit distributed transaction
querying standby database for state information
reading !UL AIJ file blocks from VBN !UL
reading !UL sort work file blocks from VBN !UL
reading AIJ open record (block 1)
reading ROOT file (!AD VBN !UL)
reading RUJ file block !UL
reading pages !UL:!UL to !UL:!UL
sending "!AD" AIJ message !UL to standby database
sending AIJ replication reply to master database
switching AIJ journals
waiting !UL second!%S for next pass through AIJ files
waiting for !AD (!AD)
waiting for !AD cache hash latch !UL
waiting for !AD cache record latch
waiting for !UL-block unmodified AIJ (!UL minute!%S)
waiting for "!AD" reply !UL from standby database
waiting for AIJ initialization
waiting for AIJ message !UL from master database
waiting for active AIJ backups to complete
waiting for async-prefetch of pages !UL:!UL to !UL:!UL
waiting for async-write of AIJ file
waiting for async-write of ROOT file
waiting for async-write of pages !UL:!UL to !UL:!UL
waiting for asynchronous I/O completion
waiting for busy AIJ sequence !UL (!UL minute!%S)
waiting for checkpoint completion
waiting for latch on !AD
waiting for page !+!SL (!AD)
waiting for page !SL:!SL (!AD)
waiting for RCS synch request
waiting for record !SW:!SL:!SW (!AD) E**!%F)
waiting for routine !AD
waiting for standby database activity request
writing !UL AIJ file blocks from VBN !UL
writing !UL page!%S back to database
writing !UL sort work file blocks from VBN !UL
writing AIJ sequence !UL block !UL
writing ROOT file (!AD VBN !UL)
writing RUJ file block !UL
</pre>

<p>
A random stall log header and extract for the per database/node stall log file
SBN_DB_STALL_L15S50_20181004.LOG_04OCT000200 :
</p>

<pre>
 Oracle Rdb V7.3-200 Performance Monitor Stall Log
 Database DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;1
 Stall Log created  4-OCT-2018 00:02:00.78
...
 4-OCT-2018 03:53:07.3741046 2A7D5322:87638  4-OCT-2018 03:53:07.3721046 reading pages 17:350491 to 17:350494
 4-OCT-2018 03:56:32.7421046 2A76BCB4:163  4-OCT-2018 03:56:32.7351046 waiting for async-write of ROOT file
 4-OCT-2018 03:59:41.4801046 2A7D5322:87638  4-OCT-2018 03:59:41.4781046 waiting for async-write of ROOT file
 4-OCT-2018 04:08:28.6467146 2A75677B:158  4-OCT-2018 04:08:28.6447146 reading pages 16:488836 to 16:488836
 4-OCT-2018 04:23:49.3879946 2A791921:139  4-OCT-2018 04:23:49.3859946 reading pages 16:483899 to 16:483902
 4-OCT-2018 04:23:56.4029946 2A7D5322:87638  4-OCT-2018 04:23:56.4009946 reading pages 17:429695 to 17:429698
 4-OCT-2018 04:26:14.8889946 2A607A7F:1  4-OCT-2018 04:26:14.6619946 waiting for AIJ journal lock 0 (PW)
   State... Process.ID Process.name... Lock.ID. Rq Gr Queue "AIJ journal lock 0"
   Blocker: 2A051265   RDM_ALS73_0002  242A164F    PW Grant
   Owner:   2A65905F   SBN_LISA_0005   7D17EF96    NL Grant
</pre>

<p>
<b>CPTRDB_SHOW_STAT_LOGS_ALL.COM</b><br>
  Calls CPTRDB_SHOW_STAT_LOGS_GO.COM
</p>

<p>
  Start all RMU/Show Statistics stall logging sessions on all nodes.
  The databases and nodes involved are listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_DATABASE|CPTRDB_SHOW_STAT_LOGS
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_STAT_LOGS|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_STAT_LOGS
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

<p>
<b>CPTRDB_SHOW_STAT_LOGS_GO.COM</b><br>
  Calls CPTRDB_SHOW_STAT_LOGS.COM
</p>

<p>
  Start one RMU/Show Statistics stall logging session in batch.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_STAT_LOGS_GO {node} {dbid} {rdb_vrsn}
</pre>

<p>
<b>CPTRDB_SHOW_STAT_LOGS.COM</b><br>
  Run RMU/Show Statistics in batch and collect stall, deadlock,
  timeout and opcom messages in the cpt$rdb_stall directory
  for one database and node.<br>

  Scheduled daily between 00:02 and 23:58.<br>
  Reschedules itself on the executor node.<br>

  The default refresh rate is 1 second.<br>

  The default stall alarm is 5 seconds, reported by the CockpitMgr event
  RDB_StallExceeded.<br>

  The default long transaction alarm, as specified in the configuration
  file CPTRDB_SHOW_STAT_LOGS.CONFIG "LONG_TX_SECONDS = 300;" is 5 minutes,
  reported by the CockpitMgr event RDB_LONG_LASTING_TRANSACTION.<br>

  The CockpitMgr event console displays all standard Rdb alarm messages 
  generated by this procedure.
</p>

  Unique output filespecs are created on each restart, such as:<br>

<pre>
Directory DISK$DATA_29:[CPT$RDB_STALL]

CPTRDB_DB_1_DEADLOCK_L15S29_20150403.LOG_03APR000202;1
CPTRDB_DB_1_OPCOM_L15S29_20150403.LOG_03APR000202;1
CPTRDB_DB_1_STALL_L15S29_20150403.LOG_03APR000202;1
CPTRDB_DB_1_TIMEOUT_L15S29_20150403.LOG_03APR000202;1
</pre>

<p>
  The output files are cleaned by the job CPTRDB_CLEANUP_LOGS_DAILY.COM,
  with a retention interval of 22 days. 
</p>

<p>
<b>CPTRDB_SEARCH_WAITING_FOR.COM</b><br>
  Interactive list 'waiting for' messages from the stall logfiles for a specific
  database, node, and period.
</p>

<pre>
Parameters: P1,   wildcard dbid,      varchar(255)
            P2,   wildcard node name, char(6)
            P3,   /since  date,       date vms
            [P4], /before date,       date vms
</pre>
  
<p>
  The procedure expects the stall log format
  'stalldir'*'dbid'*STALL*'nodeid'*.LOG*;*.
</p>

  Additional search strings can be specified using /MATCH=AND<br>

<pre>
$!---------------------------------------------------
$   search -
    /since  = "''P3'" -
    /before = "''P4'" -
    /out='outdir''filename'.lis_'dateout' -
!    /match = and -
    'stalldir'*'dbid'*stall*'nodeid'*.log*;* -
    "waiting for" ! -- Add additional strings here --
$!---------------------------------------------------
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SEARCH_WAITING_FOR {dbid} {node} {since date} [{before date}]
</pre>

  Output sample:<br>

<pre>  
******************************
DISK$DATA_29:[CPT$RDB_STALL]CPTRDB_DB_1_STALL_L15S29_20150403.LOG_03APR000202;1

 3-APR-2015 05:00:01.0313756 2DAB092B:2  3-APR-2015 05:00:01.0293756 waiting for checkpoint completion
 3-APR-2015 06:08:12.0010256 2DA751FC:1  3-APR-2015 06:08:12.0000256 waiting for async-write of ROOT file
</pre>

<p>
<b>CPTRDB_STOP_STATS_BATCH.COM</b><br>
  Called from CPTRDB_STOP_STATS.COM
</p>

<p>
  Stop the RMU/Show Statistics batch processes on one cluster node.
  The process name search strings are listed in the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|CPTRDB_STOP_STATS
</p>

<pre>
CPT$RDB_NODE|CPTRDB_STOP_STATS|L15S29|STATS_CPTRDB|
CPT$RDB_NODE|CPTRDB_STOP_STATS|L15S29|STATD_CPTRDB|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_STOP_STATS
! 2 Execution node
! 3 Process name (sub)string
</pre>

<pre>
(Internal)
Parameters: P1, output file, STOP_STATS.TMP_{filecnt}
            P2, do_stop, char(1), Y/N
</pre>

<p>
<b>CPTRDB_STOP_STATS.COM</b><br>
  Calls CPTRDB_STOP_STATS_BATCH.COM
</p>

<p>
  Stop all RMU/Show Statistics processes on a series of cluster nodes,
  listed in the configuration file CPTRDB_CONFIGURATION.REF, identified
  by the keywords CPT$RDB_NODE|CPTRDB_STOP_STATS
</p>

<pre>
CPT$RDB_NODE|CPTRDB_STOP_STATS|L15S29|STATS_CPTRDB|
CPT$RDB_NODE|CPTRDB_STOP_STATS|L15S29|STATD_CPTRDB|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_STOP_STATS
! 2 Execution node
! 3 Process name (sub)string
</pre>

<pre>
Parameters: P1, do_stop, char(1), Y/N
</pre>

<p>
  The P1 parameter determines whether or not the RMU/Show Statistics processes 
  are effectively deleted, and allows a preliminary simulation of the
  procedure's actions.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_STOP_STATS [Y|N]
</pre>

  Output sample:<br>

<pre>  
15-JUN-2016 15:17:32.66 CPTRDB - Statistics Processes Stopped From Node L15S29
 
Do Stop Is "N"
 
--------------
On Node L15S29
--------------
 
OpenVMS V8.4  on node L15S29   15-JUN-2016 15:17:32.91   Uptime  421 02:49:15
2DFB5E4B STATD_CPTRDB_1  HIB      6     1007   0 00:00:01.65      4574   2308  B
2DF9C24A STATS_CPTRDB_1  HIB      6      550   0 00:00:09.59      3650   2428  B
Number of stats processes: 2
 
$ stop/id=2DFB5E4B
$ stop/id=2DF9C24A
</pre>

<p>
  The chapters<br>
  <a href="#Chapter 31">§ -- 31 -- List And Detect Excessive Stall Counts Per Hour</a><br>
  <a href="#Chapter 32">§ -- 32 -- List And Detect Excessive Deadlock Counts Per Hour</a><br>
  provide daily automated reporting of descending stall or deadlock counts 
  group by waiting message and hour of the day.
</p>

<p>
  The chapter<br>
  <a href="#Chapter 33">§ -- 33 -- List And Detect Excessive Stall Times</a><br>
  provides daily automated reporting of excessive stall times.
</p>

<p>
  Refer to these individual chapters for more information on this type of
  analysis of the stall and deadlock logfiles.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 25"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 25 -- Collect And Format RMU/Show Statistics Binary Output Data
</font>
</h3>

<b>CPTRDB_SHOW_STAT_DATA_ALL.COM</b> (Calls)<br>
<b>CPTRDB_SHOW_STAT_DATA_GO.COM</b>  (Calls)<br>
<b>CPTRDB_SHOW_STAT_DATA.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_TRANS_SBN_DB_L15S53_20151216.JPG[_17DEC150651]</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_STAT_DATA_ALL.COM</b><br>
  Calls CPTRDB_SHOW_STAT_DATA_GO.COM
</p>

<p>
  Start all RMU/Show Statistics binary data collection sessions on all nodes.

  The databases and nodes involved are listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_DATABASE|CPTRDB_SHOW_STAT_DATA
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_STAT_DATA|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_STAT_DATA
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

<p>
<b>CPTRDB_SHOW_STAT_DATA_GO.COM</b><br>
  Calls CPTRDB_SHOW_STAT_DATA.COM
</p>

<p>
  Start one RMU/Show Statistics binary data collection session in batch.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_STAT_DATA_GO {node} {dbid} {rdb_vrsn}
</pre>

<p>
<b>CPTRDB_SHOW_STAT_DATA.COM</b><br>
  Collect RMU/Show Statistics .UNL binary output data in CPT$RDB_PERFT4,
  and format to .CSV by SQL$SAMPLE:PERFT4_RDB[72|73].EXE, used as input to TlViz,
  the T4 timeline visualizer, for one database and node.<br>

  Scheduled daily between 00:02 and 23:58.<br>
  Reschedules itself on the executor node.<br>

  The default refresh rate is 30 seconds, which determines the output files 
  sizes.<br>

  The SQL$SAMPLE:PERFT4_RDB[72|73].EXE code determines the refresh interval from the
  .UNL input file and calculates each statistic as a rate per second.<br>

  Note that time values are expressed in 100 nanoseconds units,
  1 second = 10,000,000 (100 nanoseconds units).
</p>

  Unique output filespecs are created on each restart, such as:<br>

<pre>
Directory DISK$DATA_29:[CPT$RDB_PERFT4]

CPTRDB_DB_1_DATA_L15S29_20150402.CSV_02APR235800;1
CPTRDB_DB_1_DATA_L15S29_20150402.UNL_02APR000201;1
CPTRDB_DB_1_DATA_L15S29_20150403.UNL_03APR000202;1
</pre>

<p>
  The output files are cleaned by the job CPTRDB_CLEANUP_LOGS_DAILY.COM,
  with a retention interval of 8 days for .UNL files and 22 days for
  .CSV files. 
</p>

<p>
<b>CPTRDB_TRANS_SBN_DB_L15S53_20151216.JPG</b><br>
  Display the transaction rate per second for a single database, node and day.
</p>

<p>
  This chart export jpg image from a TlViz session using a .csv file as created
  by the procedures in this chapter, illustrates the tremendous graphical
  reporting capabilities of this approach for all Rdb statistics.
</p>

<img src="CPTRDB_TRANS_SBN_DB_L15S53_20151216.JPG"
     alt="[Image CPTRDB_TRANS_SBN_DB_L15S53_20151216.JPG]"><br><br>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 26"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 26 -- List And Check RMU/Show Statistics Processes And Files
</font>
</h3>

<b>CPTRDB_SHOW_STATS_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_STATS.COM</b><br>
<b>CPTRDB_SHOW_STATS_DAILY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>
<b>CPTRDB_SHOW_STATS.REF</b>    (Reference file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_STATS_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_STATS[_DAILY].COM
</p>

<p>
  List the RMU/Show Statistics batch processes on one cluster node in sorted 
  order. The process name search strings are listed in the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_NODE|CPTRDB_SHOW_STATS.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_STATS|L15S29|STATS_CPTRDB|
CPT$RDB_NODE|CPTRDB_SHOW_STATS|L15S29|STATD_CPTRDB|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_STATS
! 2 Execution node
! 3 Process name (sub)string
</pre>

<p>
<b>CPTRDB_SHOW_STATS.COM</b><br>
  Calls CPTRDB_SHOW_STATS_BATCH.COM
</p>

<p>
  Interactive list all RMU/Show Statistics processes and log/output files
  on a series of cluster nodes, listed in the configuration file
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_STATS.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_STATS
</pre>

  Output sample:<br>

<pre>
 3-APR-2015 14:58:00.81 CPTRDB - Statistics Processes From Node L15S29
 
--------------
On Node L15S29
--------------
 
OpenVMS V8.4  on node L15S29    3-APR-2015 14:58:01.25   Uptime  73 00:26:44
2DA7622E STATD_CPTRDB_1  HIB      6     3349   0 00:00:08.02      4561   2327  B
2DA6DA2D STATS_CPTRDB_1  HIB      6      563   0 00:00:54.83      3698   2393  B
Number of stats processes: 2
 
DISK$DATA_29:[CPT$RDB_STALL]CPTRDB_DB_1_STALL_L15S29_20150403.LOG_03APR000202;1

Total of 1 file.
 
DISK$DATA_29:[CPT$RDB_PERFT4]CPTRDB_DB_1_DATA_L15S29_20150403.UNL_03APR000202;1

Total of 1 file.
 
DISK$DATA_29:[CPT$RDB_PERFT4]CPTRDB_DB_1_DATA_L15S29_20150402.CSV_02APR235800;1

Total of 1 file.
</pre>

<p>
<b>CPTRDB_SHOW_STATS_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_STATS_BATCH.COM
</p>

<p>
  Daily list RMU/Show Statistics processes and log/output files on a series of 
  cluster nodes, listed in the configuration file CPTRDB_CONFIGURATION.REF
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_STATS.

  Send CockpitMgr event and mail if difference found with reference file
  CPTRDB_SHOW_STATS.REF

  If a statistics job is missing, this will also be reported by the procedures
  CPTRDB_BATCH_ENTRIES[_DAILY].COM .
  
  The reschedule node, time and exception mail address are retrieved
  from the configuration file identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_STATS_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_STATS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_STATS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_StatisticsDifferences
"CPTRDB - Statistics Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Statistics Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 27"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 27 -- List And Check Open Databases
</font>
</h3>

<b>CPTRDB_SHOW_DBS_OPEN_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_DBS_OPEN.COM</b><br>
<b>CPTRDB_SHOW_DBS_OPEN_DAILY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>
<b>CPTRDB_SHOW_DBS_OPEN.REF</b> (Reference file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_DBS_OPEN_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_DBS_OPEN[_DAILY].COM
</p>

<p>
  List open databases, their RMU/OPEN timestamp and elapsed time, on one node
  sorted by root filename. Align RMU/Open timestamps. 

  The runtime parameters are retrieved from the configuration file, 
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_PARAM|CPTRDB_SHOW_DBS_OPEN_BATCH
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_SHOW_DBS_OPEN_BATCH|8|11|38|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_SHOW_DBS_OPEN_BATCH
! 2 Root file sort key position
! 3 Root file sort key size
! 4 RMU/Open timestamp alignment column position
</pre>

<p>
<b>CPTRDB_SHOW_DBS_OPEN.COM</b><br>
  Calls CPTRDB_SHOW_DBS_OPEN_BATCH.COM
</p>

<p>
  Interactive list open databases for a series of nodes listed in the
  configuration file CPTRDB_CONFIGURATION.REF.

  The participating nodes and Rdb versions are retrieved runtime from
  the configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN|L15S28|7.2|
CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN|L15S28|7.3|
CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN|L15S29|7.2|
CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN|L15S29|7.3|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_DBS_OPEN
! 2 Execution node
! 3 Rdb version
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_DBS_OPEN
</pre>

  Output sample:<br>

<pre> 
15-JAN-2015 08:00:01.28 CPTRDB Open Databases From Node L15S29
 
--------------
On Node L15S28
--------------
 
Oracle Rdb V7.2-550 on node L15S28 15-JAN-2015 08:00:02.03
DSA21:[BDG_DB]BDG_DB.RDB;1           28-NOV-2014 10:54:18.04 (elapsed 47 21:05:43)
DSA25:[C170_DB]C170_DB.RDB;1         28-NOV-2014 10:54:18.08 (elapsed 47 21:05:43)
DSA25:[CLIO_DB]CLIO_DB.RDB;1         28-NOV-2014 10:54:18.57 (elapsed 47 21:05:43)
DSA23:[SBN_DB]SABIN_TT.RDB;1         28-NOV-2014 10:54:18.72 (elapsed 47 21:05:43)
DSA25:[SLS_DB_1411]SLS_DB_1411.RDB;1 28-NOV-2014 10:54:19.31 (elapsed 47 21:05:42)
DSA25:[SLS_DB_1412]SLS_DB_1412.RDB;1 28-NOV-2014 10:54:19.75 (elapsed 47 21:05:42)
DSA25:[SLS_DB_1501]SLS_DB_1501.RDB;1 23-DEC-2014 11:19:07.75 (elapsed 22 20:40:54)
DSA23:[SSP_DB_VDD]SSP_DB.RDB;1       28-NOV-2014 10:54:19.86 (elapsed 47 21:05:42)
DSA31:[YPTO.C170_DB]C170_DB.RDB;1    28-NOV-2014 10:54:19.93 (elapsed 47 21:05:42)
Number of open databases: 9
 
--------------
On Node L15S28
--------------
 
Oracle Rdb V7.3-120 on node L15S28 15-JAN-2015 08:00:03.12
Number of open databases: 0
 
--------------
On Node L15S29
--------------
 
Oracle Rdb V7.2-550 on node L15S29 15-JAN-2015 08:00:04.20
DSA21:[BDG_DB]BDG_DB.RDB;1           28-NOV-2014 11:26:11.19 (elapsed 47 20:33:53)
DSA25:[C170_DB]C170_DB.RDB;1         28-NOV-2014 11:26:11.27 (elapsed 47 20:33:52)
DSA25:[CLIO_DB]CLIO_DB.RDB;1         28-NOV-2014 11:26:11.40 (elapsed 47 20:33:52)
DSA23:[SBN_DB]SABIN_TT.RDB;1         28-NOV-2014 11:26:11.62 (elapsed 47 20:33:52)
DSA25:[SLS_DB_1411]SLS_DB_1411.RDB;1 28-NOV-2014 11:26:12.25 (elapsed 47 20:33:51)
DSA25:[SLS_DB_1412]SLS_DB_1412.RDB;1 28-NOV-2014 11:26:12.40 (elapsed 47 20:33:51)
DSA25:[SLS_DB_1501]SLS_DB_1501.RDB;1 23-DEC-2014 11:19:31.78 (elapsed 22 20:40:32)
DSA23:[SSP_DB_VDD]SSP_DB.RDB;1       28-NOV-2014 11:26:12.53 (elapsed 47 20:33:51)
Number of open databases: 8
 
--------------
On Node L15S29
--------------
 
Oracle Rdb V7.3-120 on node L15S29 15-JAN-2015 08:00:05.11
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1 25-NOV-2014 12:36:28.80 (elapsed 50 19:23:36)
DSA29:[CPTRDB_DB_2]CPTRDB_DB_2.RDB;1 25-NOV-2014 12:36:31.79 (elapsed 50 19:23:33)
DSA29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1 14-JAN-2015 15:50:27.72 (elapsed 0 16:09:37)
DSA29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB;1 14-JAN-2015 15:20:47.55 (elapsed 0 16:39:17)
DSA29:[JCCLML_FILTER_DIR]JCCLML_FILTER_DB.RDB;1 25-NOV-2014 12:47:16.13 (elapsed 50 19:12:48)
Number of open databases: 5
</pre> 

<p>
<b>CPTRDB_SHOW_DBS_OPEN_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_DBS_OPEN_BATCH.COM
</p>

<p>
  Daily list open databases on a series of nodes listed in the configuration 
  file, identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_DBS_OPEN.

  Send CockpitMgr event and mail if difference found with reference file
  CPTRDB_SHOW_DBS_OPEN.REF.

  Reschedule node, reschedule time and exception mail address are
  retrieved from the configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_DBS_OPEN_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_DBS_OPEN_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_DBS_OPEN_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>
  
Toolset CockpitMgr event:<br>

<pre>
CPTRDB_OpenDatabasesDifferences
"CPTRDB - Open Databases Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Open Databases Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 28"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 28 -- Monitor And Manage Storage Area Extents
</font>
</h3>

<b>CPTRDB_DB_SIZE.COM</b><br>
<b>CPTRDB_SHOW_EXTENTS_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_EXTENTS.COM</b><br>
<b>CPTRDB_SHOW_EXTENTS_DAILY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_SHOW_STORAGE_AREAS.COM</b><br>
<b>CPTRDB_ALTER_EXTENTS_GEN.COM</b><br><br>

<b>CPTRDB_SHOW_SNAPSHOT_AREAS.COM</b><br>
<b>CPTRDB_SHOW_DATA_AREAS.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures usage
</font>
</h4>

<p>
<b>CPTRDB_DB_SIZE.COM</b><br>
  List all storage areas and their sizes for a single database
  based on RMU/Dump/Header, using the current Rdb version on the executor node.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_DB_SIZE {dbid} [sys$output|{output file}]
</pre>

  Output sample:<br>

<pre>
File sizes at  3-APR-2015 15:05:12.36 on node L15S29
----------------------------------------------------
       288 DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.SNP;1
       288 <- .RDB Size
    193536 <- .RDA Size
    193536 <- .SNP Size
    387360 <- Total Size
</pre>

<p>
<b>CPTRDB_SHOW_EXTENTS_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_EXTENTS[_DAILY].COM
</p>

<p>
  List extents for one database on one node in CPT$RDB_SIZE.

  The procedure requires per database a file named {dbid}.size in CPT$RDB_SIZE:,
  created beforehand using:
</p>

<pre>
$ @CPT$RDB:CPTRDB_DB_SIZE {dbid} cpt$rdb_size:{dbid}.size
</pre>

<hr>
  This file has to be recreated after each physical files reorganization
  of the database.
<hr>
 
<p>
  The most recent actual 'size' file is named 
  cpt$rdb_size:{dbid}.size<br>

  Previous size files are renamed to 
  cpt$rdb_size:{dbid}_{nodeid}_yyyymmdd.size_ddmmmhhmmss
  based on their creation timestamp.<br>

  Diff files are named
  cpt$rdb_size:{dbid}_{nodeid}_yyyymmdd.diff_ddmmmhhmmss
  based on the creation timestamp of the corresponding .size file.
</p>

  Output files sample:<br>

<pre>
Directory DISK$DATA_29:[CPT$RDB_SIZE]

CPTRDB_DB_1.SIZE;2          5/96         7-MAY-2018 12:10:08.86
CPTRDB_DB_1_L15S29_20180507.DIFF_07MAY121008;1
                            1/96         7-MAY-2018 12:10:09.12
CPTRDB_DB_1_L15S29_20180507.SIZE_07MAY120911;1
                            5/96         7-MAY-2018 12:09:11.60
</pre>

<p>
  These output files are cleaned by the job CPTRDB_CLEANUP_LOGS_DAILY
  with a retention interval of 22 days.
</p>

<p>
<b>CPTRDB_SHOW_EXTENTS.COM</b><br>
  Calls CPTRDB_SHOW_EXTENTS_BATCH.COM
</p>

<p>
  Interactive list extents for a series of databases, enumerated in the
  confuguration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|CPTRDB_SHOW_EXTENTS.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_EXTENTS|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_EXTENTS
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_EXTENTS
</pre>

<p>
Output sample:<br>
(After a snapshot files truncation)
</p>

<pre>
30-JUL-2018 07:48:00.30 CPTRDB - Storage Areas Extents From Node L15S53
 
-- 1 BDG_DB --
 
1 File sizes at 30-JUL-2018 07:48:00.68 on node L15S53
1 File sizes at 29-JUL-2018 07:48:00.65 on node L15S53
 
-- 2 C170_DB --
 
1 File sizes at 30-JUL-2018 07:48:01.22 on node L15S53
1 File sizes at 29-JUL-2018 07:48:01.16 on node L15S53
 
-- 3 CLIO_DB --
 
1 File sizes at 30-JUL-2018 07:48:01.78 on node L15S53
1 File sizes at 29-JUL-2018 07:48:01.75 on node L15S53
 
-- 4 EXP_DB --
 
1 File sizes at 30-JUL-2018 07:48:02.47 on node L15S53
1 File sizes at 29-JUL-2018 07:48:02.44 on node L15S53
 
-- 5 GPS_DB --
 
1 File sizes at 30-JUL-2018 07:48:02.93 on node L15S53
1 File sizes at 29-JUL-2018 07:48:02.94 on node L15S53
 
-- 6 SBN_DB --
 
1 File sizes at 30-JUL-2018 07:48:03.47 on node L15S53
1 File sizes at 29-JUL-2018 07:48:03.50 on node L15S53
 
DISK$DATA_21:[SBN_DB]FULL_SLS_SIDS.SNP;1
From: 36096 To: 12096 Diff: -24000
 
DISK$DATA_22:[SBN_DB]SBN_WASTED_DATA.SNP;1
From: 12096 To: 12096 Diff: 0
 
DISK$DATA_21:[SBN_DB]SBN_WASTED_SIDS.SNP;1
From: 12096 To: 12096 Diff: 0
 
DISK$DATA_23:[SBN_DB]SEASN_TKT_DATA.SNP;1
From: 24096 To: 12096 Diff: -12000
 
DISK$DATA_21:[SBN_DB]SEASN_TKT_SIDS.SNP;1
From: 36096 To: 12096 Diff: -24000
 
DISK$DATA_22:[SBN_DB]TRACING_SIDS.SNP;1
From: 24096 To: 12096 Diff: -12000
 
DISK$DATA_22:[SBN_DB]TTONWEB_DATA.SNP;1
From: 12096 To: 12096 Diff: 0
 
DISK$DATA_21:[SBN_DB]TTONWEB_SIDS.SNP;1
From: 48096 To: 12096 Diff: -36000
 
DISK$DATA_23:[SBN_DB]VALDTN_DATA.SNP;1
From: 48096 To: 12096 Diff: -36000
 
DISK$DATA_22:[SBN_DB]VALDTN_SIDS.SNP;1
From: 60096 To: 12096 Diff: -48000
 
DISK$DATA_25:[SBN_DB]LISA_DATA.SNP;1
From: 12096 To: 12096 Diff: 0
 
DISK$DATA_23:[SBN_DB]LISA_SIDS.SNP;1
From: 12096 To: 12096 Diff: 0
 
DISK$DATA_22:[SBN_DB]LISA_SALES_DATA.SNP;1
From: 60096 To: 12096 Diff: -48000
 
DISK$DATA_24:[SBN_DB]LISA_SALES_SIDS.SNP;1
From: 84096 To: 12096 Diff: -72000
 
-- 7 SBN_DB_ARCH --
 
1 File sizes at 30-JUL-2018 07:48:04.34 on node L15S53
1 File sizes at 29-JUL-2018 07:48:04.35 on node L15S53
 
-- 8 SITTE_DB --
 
1 File sizes at 30-JUL-2018 07:48:04.82 on node L15S53
1 File sizes at 29-JUL-2018 07:48:04.82 on node L15S53
 
-- 9 SLS_DB_1804 --
 
1 File sizes at 30-JUL-2018 07:48:05.26 on node L15S53
1 File sizes at 29-JUL-2018 07:48:05.27 on node L15S53
 
-- 10 SLS_DB_1805 --
 
1 File sizes at 30-JUL-2018 07:48:05.73 on node L15S53
1 File sizes at 29-JUL-2018 07:48:05.72 on node L15S53
 
-- 11 SLS_DB_1806 --
 
1 File sizes at 30-JUL-2018 07:48:06.20 on node L15S53
1 File sizes at 29-JUL-2018 07:48:06.22 on node L15S53
 
DISK$DATA_33:[SLS_DB_1806]SLS_DB_1806_SLS.SNP;1
From: 108096 To: 12096 Diff: -96000
 
-- 12 SLS_DB_1807 --
 
1 File sizes at 30-JUL-2018 07:48:06.64 on node L15S53
1 File sizes at 29-JUL-2018 07:48:06.67 on node L15S53
 
-- 13 SSP_DB_CMP --
 
1 File sizes at 30-JUL-2018 07:48:07.18 on node L15S53
1 File sizes at 29-JUL-2018 07:48:07.18 on node L15S53
 
-- 14 SSP_DB_PROD --
 
1 File sizes at 30-JUL-2018 07:48:08.05 on node L15S53
1 File sizes at 29-JUL-2018 07:48:08.12 on node L15S53
 
-- 15 TRACE_DB --
 
1 File sizes at 30-JUL-2018 07:48:09.38 on node L15S53
1 File sizes at 29-JUL-2018 07:48:09.41 on node L15S53
 
 
30-JUL-2018 07:48:09.66 *Show extents check failed*
</pre>

<p>
<b>CPTRDB_SHOW_EXTENTS_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_EXTENTS_BATCH.COM
</p>

<p>
  Daily list storage area extents for a series of databases, enumerated in the
  confuguration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|CPTRDB_SHOW_EXTENTS.

  Send CockpitMgr event and mail if storage areas extents or (snapshot areas)
  shrinks found.

  The reschedule node, time and execption mail address are retrieved from
  the configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_EXTENTS_DAILY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_EXTENTS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_EXTENTS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>


Toolset CockpitMgr event:<br>

<pre>
CPTRDB_ExtentsFound
"CPTRDB - Extents Found {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Extents Found {node} yyyymmdd"
</pre>

<p>
<b>CPTRDB_SHOW_STORAGE_AREAS.COM</b><br>
  Interactive report size, format, page size and extents settings for all 
  storage areas of a given database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_STORAGE_AREAS {dbid}
</pre>

<p>
  Refer to the chapter 
  <a href="#Chapter 37">§ -- 37 -- List Database Objects</a> 
  for more information on this procedure.
</p>

<p>
<b>CPTRDB_ALTER_EXTENTS_GEN.COM</b><br>
  Interactive generate a DCL/SQL command file to alter the extents 
  of all storage areas for a given database.

  Target extent settings are grouped at the beginning of the procedure.
  Assuming a page size of 4 blocks, and a disk cluster size of 96, 
  default .RDA files grow with 24,000 blocks, .SNP files grow with 
  12,000 blocks.
</p>

<pre>
$!--------------------------------------
$! -- Target extent sizes in blocks
$! -- Take into account
$!      Disk cluster size (96)
$!      Buffer size       (24)
$!      Page size          (4)
$!      Multiples of 4 or 16 recommended
$!--------------------------------------
$ rda_min_extent_blocks_ref = "12000"
$ rda_max_extent_blocks_ref = "24000"
$ rda_percent_extent_ref    = "20"
$ snp_min_extent_blocks_ref = "12000"
$ snp_max_extent_blocks_ref = "12000"
$ snp_percent_extent_ref    = "20"
$!---------------------------------------
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_ALTER_EXTENTS_GEN {dbid} ! (Generates)
$ @EXTENTS_{dbid}_{node}_yyyyddmm.COM_ddmmmhhmmss
</pre>

<p>
  The generated .COM file can be executed 'as is' online against the target 
  database.
</p>

  Output sample:<br>

<pre>
$! Alter extents for database
$! DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$! Buffer size 24
$! On node L15S29
$! At 2015-04-03 15:23:23
$!----------------------------------------------------------------------------------------------------------------------------------
$ set nover
$ on error then goto exit_procedure
$!
$ set proc/priv=all
$ set proc/prio=4
$!
$ set noon
$ deass sqlini
$ deass sql$database
$ set on
$!
$ sql := $sql$
$ sql

-- set noexecute

alter database filename DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1

--                        RDA Pages  %     SNP Pages  %      RDA Blocks      SNP Blocks
-- DATA_AREA_11   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DATA_AREA_12   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DATA_AREA_21   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DATA_AREA_22   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DATA_AREA_31   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DATA_AREA_32   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- DEFAULT_AREA   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- INDEX_AREA_1   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- INDEX_AREA_2   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- INDEX_AREA_3   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- LISTS_AREA     | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- MIXED_AREA_1   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- MIXED_AREA_2   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- MIXED_AREA_3   | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- RDB$SYSTEM     | 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
-- STALL_CNTS_AREA| 4| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000

alter storage area DATA_AREA_11
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DATA_AREA_12
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DATA_AREA_21
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DATA_AREA_22
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DATA_AREA_31
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DATA_AREA_32
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area DEFAULT_AREA
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area INDEX_AREA_1
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area INDEX_AREA_2
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area INDEX_AREA_3
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area LISTS_AREA
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area MIXED_AREA_1
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area MIXED_AREA_2
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area MIXED_AREA_3
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area RDB$SYSTEM
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

alter storage area STALL_CNTS_AREA
extent is          (minimum 3000, maximum 6000, percent growth 20)
snapshot extent is (minimum 3000, maximum 3000, percent growth 20)

;

$!
$exit_procedure:
$ set nover
$ exit
</pre>

<p>
<b>CPTRDB_SHOW_SNAPSHOT_AREAS.COM</b><br>
  List the current snapshot areas file sizes for a series of databases,
  based on the data in the CPT$RDB_SIZE directory, identified in the
  configuration file CPTRDB_CONFIGURATION.REF by the keywords
  CPT$RDB_DATABASE|CPTRDB_SHOW_SNAPSHOT_AREAS
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_SNAPSHOT_AREAS|CPTRDB_DB_1|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_SNAPSHOT_AREAS
! 2 Database
</pre>

<p>
  Requires the {dbid}.size file(s) in the CPT$RDB_SIZE: directory.
</p>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SHOW_SNAPSHOT_AREAS
</pre>

<p>
  Output sample:
</p>

<pre>
2016-06-21 14:35:37.23 CPTRDB - Snapshot Areas Files On Node L15S29
 
-- 1 -- CPTRDB_DB_1
 
       288 DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.SNP;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.SNP;1
       288 <- .RDB Size
    193536 <- .SNP Size
</pre>

<p>
<b>CPTRDB_SHOW_DATA_AREAS.COM</b><br>
  List the current data areas file sizes for a series of databases,
  based on the data in the CPT$RDB_SIZE directory, identified in the
  configuration file CPTRDB_CONFIGURATION.REF by the keywords
  CPT$RDB_DATABASE|CPTRDB_SHOW_DATA_AREAS
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SHOW_DATA_AREAS|CPTRDB_DB_1|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SHOW_DATA_AREAS
! 2 Database
</pre>

<p>
  Requires the {dbid}.size file(s) in the CPT$RDB_SIZE: directory. 
</p>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SHOW_DATA_AREAS
</pre>

<p>
  Output sample:
</p>

<pre>
2016-06-21 14:41:54.88 CPTRDB - Data Areas Files On Node L15S29
 
-- 1 -- CPTRDB_DB_1
 
       288 DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.RDA;1
     12096 DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.RDA;1
       288 <- .RDB Size
    193536 <- .RDA Size
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 29"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 29 -- Truncate Snapshots Online
</font>
</h3>

<b>CPTRDB_TRNC_SNAPS_GEN.COM</b><br>
<b>CPTRDB_TRNC_SNAPS_GEN_ALL.COM</b><br>
<b>CPTRDB_TRNC_SNAPS_ALL.COM</b><br>
<b>CPTRDB_TRNC_SNAPS_STOP.COM</b><br><br>

TRNC_{dbid}_{node}_yyyymmdd.COM[_ddmmmhhmmss] per database<br>
CPTRDB_TRNC_CPTRDB_DB_1_L15S29_20150603.COM<br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
[Note that the online snapshot truncation has two side effects. The truncation
itself waits for the currently active read only transactions to terminate
and prevents new read only transactions from starting. Hence the need
for a stop procedure, called in parallel from the truncation, to prevent
excessive stall times.]
</p>

<p>
<b>CPTRDB_TRNC_SNAPS_GEN.COM</b><br>
  Interactive generate a DCL/SQL command file to truncate the snapshot files 
  of all storage areas for a database to a given size in blocks.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_TRNC_SNAPS_GEN {dbid} {.SNP size blocks}
</pre>

<p>
  Two identical files are created named<br>
  TRNC_{dbid}_{node}_yyyymmdd.COM (Called from CPTRDB_TRNC_SNAPS_ALL.COM)<br> 
  TRNC_{dbid}_{node}_yyyymmdd.COM_ddmmmhhmmss (For later reference)<br>

  Input parameter to TRNC_{dbid}_{node}_yyyymmdd.COM is 
  P1, Rdb version, char(3), [7.2|7.3]<br>

  The procedure requires the information table RDB$STORAGE_AREAS.<br>

  A output sample file is included in the kit:
  CPTRDB_TRNC_CPTRDB_DB_1_L15S29_20150603.COM
</p>

<pre>
$! Trunc Snapshot Files For Database
$! DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$! On Node L15S29
$! At 2015-06-03 15:13:43
$!
$! Parameters: P1, Rdb version, char(3), 7.3
$!
$!----------------------------------------------------------------------------------------------------------------------------------
$ set nover
$ on error then goto exit_procedure
$!
$ if P1 .eqs. ""
$ then
$   write sys$output "Parameters: P1, Rdb version, char(3), 7.3"
$   exit
$ endif
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$ set output_rate=00:00:05
$!
$ say := write sys$output
$ sql := $sql$
$!
$ dbid = "CPTRDB_DB_1"
$ process_name=f$extract(0,15,"TRNC ''dbid'")
$!
$ if f$extract(0,10,"''dbid'") .eqs. "CPTRDB_DB_"
$ then
$   dbnbr = f$extract(10,1,"''dbid'")
$   process_name = "TRNC CPTRDB_''dbnbr'"
$ endif
$!
$!$ set proc/name="''process_name'"
$!
$ show process
$ say " "
$!
$ rdb_vrsn = "''P1'"
$ @sys$share:rdb$setver 'rdb_vrsn'
$ say " "
$!
$ set noon
$ deass sqlini
$ deass sql$database
$ set on
$ say " "
$!
$ say "''f$time()' Starting snapshot truncation"
$ say " "
$!
$ sql

-- set noexecute

-- Snapshot areas
-- Buffer size: 24
-- Target snapshot allocation (blocks): 12000
------------------------------------------------------------------------------------------------------------------------------------
--  28|DATA_AREA_11   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.SNP;1
--  29|DATA_AREA_12   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.SNP;1
--  30|DATA_AREA_21   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.SNP;1
--  31|DATA_AREA_22   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.SNP;1
--  32|DATA_AREA_31   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.SNP;1
--  33|DATA_AREA_32   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.SNP;1
--  23|DEFAULT_AREA   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.SNP;1
--  34|INDEX_AREA_1   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.SNP;1
--  35|INDEX_AREA_2   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.SNP;1
--  36|INDEX_AREA_3   |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.SNP;1
--  24|LISTS_AREA     |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.SNP;1
--  25|MIXED_AREA_1   |Mixed  | 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.SNP;1
--  26|MIXED_AREA_2   |Mixed  | 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.SNP;1
--  27|MIXED_AREA_3   |Mixed  | 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.SNP;1
--  22|RDB$SYSTEM     |Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.SNP;1
--  37|STALL_CNTS_AREA|Uniform| 4| 3000|    12000|DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.SNP;1
------------------------------------------------------------------------------------------------------------------------------------
--                                             16 Total number of snapshot areas
--                                         192000 Total size of snapshot areas
--                                         192000 Target total size of snapshot areas
--                                              0 Delta total size of snapshot areas

alter database filename DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1

alter storage area DATA_AREA_11    snapshot allocation 3000
alter storage area DATA_AREA_12    snapshot allocation 3000
alter storage area DATA_AREA_21    snapshot allocation 3000
alter storage area DATA_AREA_22    snapshot allocation 3000
alter storage area DATA_AREA_31    snapshot allocation 3000
alter storage area DATA_AREA_32    snapshot allocation 3000
alter storage area DEFAULT_AREA    snapshot allocation 3000
alter storage area INDEX_AREA_1    snapshot allocation 3000
alter storage area INDEX_AREA_2    snapshot allocation 3000
alter storage area INDEX_AREA_3    snapshot allocation 3000
alter storage area LISTS_AREA      snapshot allocation 3000
alter storage area MIXED_AREA_1    snapshot allocation 3000
alter storage area MIXED_AREA_2    snapshot allocation 3000
alter storage area MIXED_AREA_3    snapshot allocation 3000
alter storage area RDB$SYSTEM      snapshot allocation 3000
alter storage area STALL_CNTS_AREA snapshot allocation 3000
;

$!
$exit_procedure:
$ set nover
$ say "''f$time()' Snapshot truncation completed"
$ say " "
$ exit
</pre>

<p>
<b>CPTRDB_TRNC_SNAPS_GEN_ALL.COM</b><br>
  Calls CPTRDB_TRNC_SNAPS_GEN.COM per database
</p>

<p>
  Interactive generate a snapshot truncation command file for a 
  series of databases.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_TRNC_SNAPS_GEN_ALL
</pre>

<p>
<b>CPTRDB_TRNC_SNAPS_ALL.COM</b><br>
  Calls per database<br>
      TRNC_{dbid}_{node}_yyyymmdd.COM<br>
  and CPTRDB_TRNC_SNAPS_STOP.COM in parallel
</p>

<p>
  Weekly trunc the snapshot files for a series of databases.
  Abort and switch to next database if stalled for more than n seconds and send 
  a CockpitMgr event and mail.

  The list of databases and their individual trunc procedure settings are
  retrieved from the configuration file CPTRDB_CONFIGURATION.REF identified by
  the keywords CPT$RDB_DATABASE|CPTRDB_TRNC_SNAPS.

  The generated trunc command file format (Called from 
  CPTRDB_TRNC_SNAPS_ALL.COM) is
  TRNC_{dbid}_{node}_yyyymmdd.COM 
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_TRNC_SNAPS|CPTRDB_DB_1|L15S29|20150306|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_TRNC_SNAPS
! 2 Database {dbid}
! 3 Generate node {node}
! 4 Generate date {yyyymmdd}
! 5 Rdb version
! 6 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_TRNC_SNAPS_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_TRNC_SNAPS_ALL|L15S29|TOMORROW +6-03:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_TRNC_SNAPS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_TRNC_SNAPS_STOP.COM</b><br>
  Called per database in parallel from CPTRDB_TRNC_SNAPS_ALL.COM.<br>

  If the trunc job for a database is still running after n seconds,
  it is stopped and a CockpitMgr event and mail are sent.
</p>

<pre>
Input parameters: P1, entry number, integer
                  P2, job name,     char(39)
                  P3, db logical,   varchar(255)
</pre>

<p>
  The runtime parameters are retrieved from the configuration file identified
  by the keywords CPT$RDB_PARAM|CPTRDB_TRNC_SNAPS_STOP
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_TRNC_SNAPS_STOP|00:00:30|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_TRNC_SNAPS_STOP
! 2 Timeout seconds
! 3 Exception mail address
</pre>

Toolset CockpitMgr event:<br>

<pre>
CPTRDB_TruncSnapsStopped
"CPTRDB - Database {root} - Trunc Snaps Stopped - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Trunc Snaps Stopped {dbid} {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 30"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 30 -- Detect And Summarize Bugcheck Dump Files
</font>
</h3>

<b>CPTRDB_SHOW_BUGCHECK_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_BUGCHECK.COM</b><br>
<b>CPTRDB_SHOW_BUGCHECK_DAILY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_RENAME_CDT.COM</b><br>
<b>CPTRDB_SEARCH_DUMP.COM</b><br><br>

<b>CPTRDB_SUMMARIZE_DUMP.COM</b> (Calls)<br>
<b>CPTRDB_DUMP_SUMMARIZER_20130314.COM</b><br>
<b>CPTRDB_DUMP_SUMMARIZER_20150907.COM</b><br><br>

<b>CPTRDB_RDM$BUGCHECK_IGNORE_FLAGS.COM</b><br><br>

<b>CPTRDB_INFOZIP_ZIP_30.EXE</b><br>
<b>CPTRDB_INFOZIP_UNZIP_60.EXE</b><br>
<b>CPTRDB_ZIP_DUMP.COM</b><br>
<b>CPTRDB_UNZIP_DUMP.COM</b><br>
<b>CPTRDB_SUBMIT_SYSTEM.COM</b><br><br>

<b>CPTRDB_BUGCHECK_PROCESS.COM</b><br>
<b>CPTRDB_BUGCHECK_PROCESS_GO.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_BUGCHECK_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_BUGCHECK[_DAILY].COM
</p>

<p>
  List (bugcheck) *.DMP*;* dump files in RDM$BUGCHECK_DIR on one node.
</p>

<p>
<b>CPTRDB_SHOW_BUGCHECK.COM</b><br>
  Calls CPTRDB_SHOW_BUGCHECK_BATCH.COM
</p>

<p>
  Interactive list bugcheck dump files in RDM$BUGCHECK_DIR on a series of nodes.
  
  The list of nodes is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_NODE|CPTRDB_SHOW_BUGCHECK.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_BUGCHECK|L15S29|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_BUGCHECK
! 2 Execution node
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_BUGCHECK
</pre>

  Output sample:<br>

<pre>
 3-APR-2015 15:45:04.66 CPTRDB - Bugcheck Dump Files From Node L15S29
 
--------------
On Node L15S29
--------------

Directory DISK$DATA_29:[RDB_BUGCHECK]

RDSBUGCHK_20150115_ILLPAGCNT.DMP_15JAN100647;1
                           1/96        3-APR-2015 15:43:53.00

Total of 1 file, 1/96 blocks.
</pre>

<p>
<b>CPTRDB_SHOW_BUGCHECK_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_BUGCHECK_BATCH.COM
</p>

<p>
  Daily list (bugcheck) dump files *.dmp*;* in RDM$BUGCHECK_DIR on a series of 
  nodes, listed in the configuration file, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_BUGCHECK.

  Send CockpitMgr event and mail if dump files are found.

  The reschedule node, time and exception mail address are retrieved from
  the configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_BUGCHECK_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_BUGCHECK_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_BUGCHECK_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_BugcheckDumpsFound
"CPTRDB - Bugcheck Dumps Found {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - Bugcheck Dumps Found {node} yyyymmdd"
</pre>

<p>
<b>CPTRDB_RENAME_CDT.COM</b><br>
  Rename a file to {name}_{node}_yyyymmdd.{ext}_ddmmmhhmmss based on the 
  creation date and time to prevent unintended purge or delete.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_RENAME_CDT {filespec}
</pre>

  Output sample:<br>

<pre>
$ @CPTRDB_RENAME_CDT BOEM.TXT
Renamed To DISK$USERS:[ALLEMEERSCH.CPT$RDB]BOEM_L15S29_20150423.TXT_23APR150243
</pre>

<p>
<b>CPTRDB_SEARCH_DUMP.COM</b><br>
  Search bugcheck dump file(s) in RDM$BUGCHECK_DIR for basic information
  on exception, node, database, user and application.
</p>

  Parameters: Adapt the dump file(s) filespec and reply username<br>

<pre>
$!-----------------------------------------------
$ reply_user = "RDBMON"
$ dump_file  = "RDM$BUGCHECK_DIR:*BUGCHK*.DMP*;*"
$!-----------------------------------------------
</pre>

<p>
  Submit the job as user system with the logfile in RDM$BUGCHECK_DIR:
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT_SYSTEM {node} CPTRDB_SEARCH_DUMP 
</pre>

  The search items are:<br>

<pre>
$!-----------------------
$ search/match=or -
  'dump_file' -
  "***** Exception at", -
  "-E-", -
  "-F-", -
  "RT_FILNAM_ASCIC =", -
  "Saved PC =", -
  "USERNAME =", -
  "IMAGNAME =", -
  "NODENAME =", -
  "PGFLQUOTA =", -
  "PAGFILCNT =", -
  "DIO_CUR_DBK =", -
  "PIO_CUR_DBK =", -
  "MASTER_PID =", -
  "Current time is", -
  "PRCNAM ="
$!-----------------------
</pre>

<p>
<b>CPTRDB_DUMP_SUMMARIZER_20130314.COM</b><br>
<b>CPTRDB_DUMP_SUMMARIZER_20150907.COM</b><br>

  The procedures contain a copy of the bugcheck dump summarizer (BDS) created 
  and maintained by Peter Jackson, available from 'My Oracle Support', 
  Document Id 165466.1
</p>

  Usage:<br>

<pre>
$ @CPTRDB_DUMP_SUMMARIZER_20150907
Bugcheck dump summarizer, version 07 September 2015

Parameters:
P1 - Name of dump file
P2 - Options - separate by commas
     NOTSN   - forces off TSN checking which can improve performance.
     TSN     - forces on TSN checking.
     BLR     - extract the BLR of the current query.
     INDEX   - try to extract index information
     LOG     - record information about running the summarizer
     LOGICAL - list the logical names
     PROCESS - list the processes on the system
     STACK   - write the full stack dump to a file
     MORE    - report extra information
     OUTPUT  - output goes to files with unique names
</pre>
  
<p>
<b>CPTRDB_SUMMARIZE_DUMP.COM</b><br>
  Summarize one hardcoded bugcheck dump file in RDM$BUGCHECK_DIR,
  using Peter Jackson's summarizer, available from 'My Oracle Support',
  Document Id 165466.1
</p>

  Parameters: Adapt the dump file filespec and reply username<br>

<pre>
$!-------------------------------------------------------------------
$ reply_user = "RDBMON"
$ dump_file  = "RDM$BUGCHECK_DIR:RDSBUGCHK_20150115.DMP_15JAN100647;1
$!-------------------------------------------------------------------
</pre>

<p>
  Submit the job as user system with the logfile in RDM$BUGCHECK_DIR:
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT_SYSTEM {node} CPTRDB_SUMMARIZE_DUMP
</pre>

  Output samples:<br>

<pre>
A corrupt ranked index, with tons of duplicates:

Itanium OpenVMS 8.4
Oracle Rdb Server 7.2.5.0.0
Got a RDSBUGCHK.DMP
COSI-F-BUGCHECK, internal consistency failure
Exception occurred at RDMSHRP72\PSII2REMOVEDUPBBC + 00001C40
Called from RDMSHRP72\PSII2REMOVEBOTTOM + 000018F0
Called from RDMSHRP72\PSII2REMOVET + 000003E0
Called from RDMSHRP72\PSII2REMOVETREE + 000004B0
Called from RDMSHRP72\RDMS$$KOD_REMOVE_TREE + 000039D0
Called from RDMSHRP72\RDMS$$EXE_ACTION + 0000A3B0
Called from RDMSHRP72\RDMS$$C_EXE_ACTION + 00000080
Called from RDMSHRP72\RDMS_EXE_INTERP + 0000FD10
Called from RDMSHRP72\RDMS$TOP_RECEIVE_BUFFER + 00002010
Called from RDMSHRP72\RDMS$TOP_SEND + 000009E0
Called from Image RDMSHRP72 + 000001A0
Called from RDMSHRP72\KODSTREAM$JACKET + 00000130
Called from symbol not found
Called from RDMSHRP72\KOD$SETSTK_AND_CONTINUE + 00000180
Bugcheck when working on sorted ranked index
BLR of current query written to DISK$DATA_29:[RDB_BUGCHECK]BLR.TXT;1
Running image RDBSERVER72.EXE
Process name is RDB72_BG34259
Dump created: 23-APR-2015 01:50:01.10
Database root: DISK$DATA_34:[CE_DPRTR_DB_L14S45]CE_DPRTR_DB_04130
Tables in current request: DOSSIER_SUPPORT
Current DB key: 74:7031:0
Physical Data DB key for user: 10:7031:1988
Index being worked on: DOSSIER_SUPPORT_IDX5
This bugcheck may have been caused by a corrupt index.
The database should be verified to check for such corruption.
Suggested command:
  RMU/VERIFY/LAREA=(DOSSIER_SUPPORT)/INDEX=(DOSSIER_SUPPORT_IDX5) -
   DISK$DATA_34:[CE_DPRTR_DB_L14S45]CE_DPRTR_DB_04130


A rare monitor bugcheck:

Itanium OpenVMS 8.4
Oracle Rdb Server 7.2.5.0.0
Got a RDMMONBUG.DMP
Rdb Monitor bugchecked
COSI-F-IVLOCKID, invalid lock id
Exception occurred at Image RDMMON72 + 80116920
Called from Image RDMMON72 + 800E65A0
When handling earlier exception at Image RDMMON72 + 80116920
Called from Image RDMMON72 + 8014C190
Called from Image RDMMON72 + 80152FA0
Called from Image RDMMON72 + 80153E80
Called from Image RDMMON72 + 801177D0
Called from Image RDMMON72 + 800CF9C0
Called from Image RDMMON72 + 8008F550
Called from Image RDMMON72 + 8008DFE0
Called from Image RDMMON72 + 800CF620
No BLR for current query found
Running image RDMMON72.EXE
Process name is "RDMS_MONITOR72"
Dump created: 18-FEB-2015 05:16:37.89
Dump created on node L15S59
</pre>

  Monitor logfile extract:<br>

<pre>
18-FEB-2015 05:16:37.80 - lock granted to cluster watcher
  - database name "DSA33:[SLS_DB_1401]SLS_DB_1401.RDB;1" [_DSA33] (52,8,0)
  - cluster watcher detected invalid MEMBIT lock value block
  - starting forced-exit shutdown of database:
    - %COSI-F-IVLOCKID, invalid lock id
%RDMS-I-BUGCHKDMP, generating bugcheck dump file DISK$DATA_29:[RDB_BUGCHECK]RDMMONBUG.DMP;
</pre>

<p>
  The background is a very high rate of connect/disconnect to a OPEN AUTOMATIC
  database, in a six nodes cluster environment, with some cluster interconnect
  problems at that moment (processes in RWSCS state).
  The MEMBIT lock value block contains the list of which databases are open on
  which nodes, and was being updated n times per second.
</p>

<p>
<b>CPTRDB_RDM$BUGCHECK_IGNORE_FLAGS.COM</b><br>
  Define flags to limit the size of bugcheckdump files on one node.
</p>

Possible values are any combination of:<br>

<pre>
C client-specific information
G global buffer data structures
H header, root file information
K KODA section
L locking information
O operator OPCOM notifications of bugchecks
P page buffers
R row cache section
</pre>

Usage:<br>

<pre>
$ define/sys/exec RDM$BUGCHECK_IGNORE_FLAGS "GLP"
</pre>

<p>
<b>CPTRDB_INFOZIP_ZIP_30.EXE</b><br>
<b>CPTRDB_INFOZIP_UNZIP_60.EXE</b><br>
  Itanium Infozip executables.
</p>

  Usage:<br>

<pre>
$ ZIP   := $CPT$RDB:CPTRDB_INFOZIP_ZIP_30
$ UNZIP := $CPT$RDB:CPTRDB_INFOZIP_UNZIP_60
$ ZIP -h2
$ UNZIP -hh
</pre>

<p>
<b>CPTRDB_ZIP_DUMP.COM</b><br>
  Zip a series of hardcoded (bugcheckdump) files located in RDM$BUGCHECK_DIR:
</p>

  Parameters: Adapt the parameter block<br>

<pre>
$!------------------------------------------------------------------------------
$ reply_user =      "RDBMON"
$ set def            RDM$BUGCHECK_DIR:
$ define src_file_1 "RDSBUGCHK_20150115.DMP_15JAN100647"
$ define zip_file   "RDSBUGCHK_20150115.ZIP_15JAN100647"
$!------------------------------------------------------------------------------
</pre>

<p>
  The procedure creates the source subdirectory [.ZIP].

  Submit the job as user system with the logfile in RDM$BUGCHECK_DIR: 
</p>

  Usage:<br>

<pre>
@CPTRDB_SUBMIT_SYSTEM {node} CPTRDB_ZIP_DUMP
</pre>

<p>
<b>CPTRDB_UNZIP_DUMP.COM</b><br>
  Unzip one hardcoded (bugcheckdump) zip archive located in RDM$BUGCHECK_DIR.
</p>

  Parameters: Adapt the parameter block<br>

<pre>
!------------------------------------------------------------------------------
$ reply_user =    "RDBMON"
$ set def          RDM$BUGCHECK_DIR:
$ define zip_file "RDSBUGCHK_20150115.ZIP_15JAN100647;1"
$!------------------------------------------------------------------------------
</pre>

<p>
  The procedure creates the destination subdirectory [.UNZIP]

  Submit the job as user system with the logfile in RDM$BUGCHECK_DIR:
</p>

  Usage:<br>

<pre>
@CPTRDB_SUBMIT_SYSTEM {node} CPTRDB_UNZIP_DUMP
</pre>

<p>
<b>CPTRDB_SUBMIT_SYSTEM.COM</b><br>
  Submit a toolset job in batch as user [SYSTEM] to the queue 
  CPT$RDB_BATCH_{node} with the logfile in a directory owned by user [SYSTEM],
  such as RDM$BUGCHECK_DIR.
</p>
  
  Adapt the parameter block:<br>

<pre>
$!----------------------------
$ defdir = "CPT$RDB:"
$ logdir = "RDM$BUGCHECK_DIR:"
$!----------------------------

Parameters: P1,   nodename,                      char(6)
            P2,   filename, CPTRDB_{name}[.COM], char(39)
            [P3], /AFTER date time,              [absolute|delta] time

P2 is the filename only, without extension .COM
P3 is optional
The prefix "CPTRDB_" is stripped off from the logfile filename
The logfile format is {name}_{node}_yyyymmdd.log_ddmmmhhmmss
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT_SYSTEM {node} [{name}|CPTRDB_SEARCH_DUMP] {date time}
</pre>

<p>
<b>CPTRDB_BUGCHECK_PROCESS.COM</b><br>
Called from CPTRDB_BUGCHECK_PROCESS_GO.COM
</p>

<p>
  RMU/Bugcheck one Rdb user process based on the process name.
</p>
  
<pre>
Parameters: P1, dbid,         varchar(255), cptrdb_db_1
            P2, process name, varchar(15),  stats_cptrdb_1
</pre>

<p>
  The bugcheckdump file most recent called routines will be similar to:
</p>

<pre>
Saved PC = 0000000081E48060 : RDMSHRP73\KOD$BUGCHECK_DUMP + 00002270
Saved PC = 0000000081B8E900 : RDMSHRP73\BUGCHKAST$COMPLETION_AST + 00000300
...
Saved PC = FFFFFFFF805E01C0 : symbol not found
Saved PC = FFFFFFFF804E06A0 : symbol not found
Saved PC = 0000000081D2A590 : RDMSHRP73\PIOGB$ADD_PAGE_TO_ASET + 00000000
Saved PC = 0000000081D36F70 : RDMSHRP73\PIOGB$WITHIN_POOL + 000022A0
Saved PC = 0000000081D33CA0 : RDMSHRP73\PIOGB$WITHIN_DB + 00000350
Saved PC = 0000000081D112A0 : RDMSHRP73\PIOFETCH$WITHIN_DB + 00001CC0
Saved PC = 0000000081D0AFE0 : RDMSHRP73\PIOFETCH$FETCH + 00000530
Saved PC = 0000000081D08830 : RDMSHRP73\PIO$FETCH + 000017C0
Saved PC = 0000000081B931E0 : RDMSHRP73\DIOFETCH$FETCH_VISIBLE_SEG + 000001E0
Saved PC = 0000000081B95940 : RDMSHRP73\DIOFETCH$FETCH_ONE_LINE + 00001450
Saved PC = 0000000081B96850 : RDMSHRP73\DIO$FETCH_DBKEY + 00000720
Saved PC = 00000000813C41B0 : RDMSHRP73\RDMS$$KOD_FIND_CURRENT_REC + 00000AD0
</pre>

<p>
<b>CPTRDB_BUGCHECK_PROCESS_GO.COM</b><br>
Calls CPTRDB_BUGCHECK_PROCESS.COM
</p>

<p>
  Submit CPTRDB_BUGCHECK_PROCESS.COM in batch with hardcoded parameters.
</p>

<p>
  Parameters: Adapt the parameter block.
</p>
 
<pre>
$!-------------------------------
$ dbid         = "CPTRDB_DB_1"
$ process_name = "STATS_CPTRDB_1"
$ sched_node   = "L15S29"
$ sched_time   = "+00:00:30"
$!-------------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 31"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 31 -- List And Detect Excessive Stall Counts Per Hour
</font>
</h3>

<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br><br>

<b>CPTRDB_STALL_CNTS.COM</b><br>
<b>CPTRDB_STALL_CNTS.RRD</b><br>
<b>CPTRDB_STALL_CNTS_GO.COM</b><br>
<b>CPTRDB_STALL_CNTS_ALL.COM</b><br><br>

<b>CPTRDB_STALL_RW_CNTS.COM</b><br>
<b>CPTRDB_STALL_RW_CNTS.RRD</b><br>
<b>CPTRDB_STALL_RW_CNTS_GO.COM</b><br>
<b>CPTRDB_STALL_RW_CNTS_ALL.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The purpose of these procedures is to detect potential hotspots and performance
bottlenecks within a database, by (daily) analyzing the stall log files.
</p>

<p>
<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br>
  Add a storage area to a database to store the WAITING_FOR_CNTS and
  STALL_RW_CNTS tables, used in the 'stall counts per hour' reporting.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_DB_1"
$!----------------------
</pre>

<p>
<b>CPTRDB_STALL_CNTS.COM</b><br>
  Called per stall log file from CPTRDB_STALL_CNTS_[GO|ALL].COM
</p>

<p>
  List 'waiting for' messages counts, desc per hour, from the stall logfile(s)
  for a specific database, node, and period.<br>

  Send mail and CockpitMgr event if a counts per hour alarm is exceeded.
</p>
  
<pre>
Parameters: P1, database logical,       varchar(255)
            P2, stall node,             char(6)
            P3, /since  date,           date vms
            P4, /before date,           date vms
            P5, stall counts alarm,     integer
            P6, Rdb version,            char(3), [7.2|7.3]
            P7, exception mail address, varchar(255)
</pre>

  The procedure requires:<br>

<pre>
. The P1 database contains the storage area
  STALL_CNTS_AREA
  that can be created using CPT$RDB:CPTRDB_STALL_CNTS_ADD_SAREA.COM
  
. A stall logs format of
  {stall_dir}:{dbid}*STALL*{node}*.LOG*
</pre>

<p>
  The procedure (re)creates a table named WAITING_FOR_CNTS in the P1 database
  to load the extracted 'waiting for' messages, and performs a count group by 
  the day, the hour of the day and the stalled database object.

  Some frequent reoccurring database objects such as SEQBLK and 'TSN block'
  are excluded from notification, if they are the only alarms reported
  for the stall log file. They still are flagged in the output file
  as '*Exceeded*' and visible using the CPTRDB_DAILY.COM procedure. 
</p>

  Source extract:<br>

<pre>
-- Do not send mail/cockpit when only seqblk/tsn block stalls
-- Do not send mail/cockpit before 02:00
-- Add additional conditions here

if    :t1.stall_cnt >= :stall_cnts_limit
  and :t1.stall_reason not starting with 'SEQBLK'
  and :t1.stall_reason not starting with 'TSN block'
  and cast(:t1.stall_time as integer) >= 2
then
  set :cnt_status = '*Exceeded Send*';
  call lib$set_symbol('STALL_CNTS_SEND','YES');
end if;
</pre>

<p>
  If implemented, the analyze database ANA_{P1} is a feasible alternative
  to create the STALL_CNTS_AREA storage area and WAITING_FOR_CNTS table.
</p>

<pre>
$!-----------------------------------
$!$ define sql$database "ANA_''dbid'"
$!-----------------------------------
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_StallCntsExceeded
"CPTRDB - Stall Cnts Exceeded {db} {node} yyyymmdd - ddmmmhhmmss"
</pre>

  Toolset mail subject:<br>

<pre>
"CPTRDB - Stall Cnts Exceeded {db} {node} yyyymmdd"
</pre>

  Output sample without notification:<br>

<pre>
CPTRDB - Stall Counts Per Hour From Node L15S50
For Database: DISK$DATA_25:[C170_DB]C170_DB.RDB
On Node:      L15S58
Since:        16-JUN-2015
Before:       17-JUN-2015
Alarm:        30
At:           17-JUN-2015 04:45:09.99
--------------------------------------------------------------------------------
2015-06-16|00|     3|async-write of pages 6:495435 to 6:495435|
---------------------
2015-06-16|07|     6|record 84:33701:0 (EX)|
---------------------
2015-06-16|08|     7|routine SYS$CREATE|
2015-06-16|08|     3|record 70:453708:0 (EX)|
2015-06-16|08|     3|routine SYS$ERASE|
2015-06-16|08|     2|routine SYS$SEARCH|
2015-06-16|08|     2|async-write of ROOT file|
---------------------
2015-06-16|09|     4|routine SYS$CREATE|
2015-06-16|09|     3|async-write of ROOT file|
---------------------
2015-06-16|10|     8|record 95:35923:0 (EX)|
2015-06-16|10|     4|routine SYS$CREATE|
2015-06-16|10|     4|routine SYS$ERASE|
2015-06-16|10|     3|async-write of ROOT file|
2015-06-16|10|     2|async-write of pages 6:488456 to 6:488456|
2015-06-16|10|     2|record 70:453708:0 (EX)|
---------------------
2015-06-16|11|     3|routine SYS$PARSE|
2015-06-16|11|     2|page 1:378 (PW)|
2015-06-16|11|     2|routine SYS$CREATE|
2015-06-16|11|     2|routine SYS$ERASE|
2015-06-16|11|     2|AIJ journal lock 0 (PW)|
---------------------
2015-06-16|12|     8|record 76:298409:0 (EX)|
2015-06-16|12|     2|async-write of ROOT file|
---------------------
2015-06-16|13|     8|async-write of ROOT file|
2015-06-16|13|     7|routine SYS$CREATE|
2015-06-16|13|     3|routine SYS$ERASE|
2015-06-16|13|     3|page 1:378 (PW)|
2015-06-16|13|     2|page 16:265 (PR)|
2015-06-16|13|     2|routine SYS$PARSE|
---------------------
2015-06-16|14|    11|async-write of ROOT file|
2015-06-16|14|    10|routine SYS$CREATE|
2015-06-16|14|     7|routine SYS$ERASE|
2015-06-16|14|     2|routine SYS$CLOSE|
2015-06-16|14|     2|record 70:453708:0 (EX)|
---------------------
2015-06-16|15|     7|record 70:453708:0 (EX)|
2015-06-16|15|     5|routine SYS$CREATE|
2015-06-16|15|     4|routine SYS$ERASE|
2015-06-16|15|     3|record 84:33701:0 (EX)|
2015-06-16|15|     3|async-write of ROOT file|
2015-06-16|15|     2|routine SYS$CLOSE|
---------------------
2015-06-16|16|     3|record 76:298409:0 (EX)|
2015-06-16|16|     2|routine SYS$ERASE|
---------------------
2015-06-16|18|    13|record 84:33701:0 (EX)|
---------------------
2015-06-16|19|     3|routine SYS$CREATE|
2015-06-16|19|     3|AIJ journal lock 0 (PW)|
---------------------
2015-06-16|20|     2|AIJ journal lock 0 (PW)|
2015-06-16|20|     2|routine SYS$CREATE|
---------------------
2015-06-16|23|     2|async-write of pages 6:57877 to 6:57877|
--------------------------------------------------------------------------------
Total number of stall groups:     47
Total number of stall lines:     188
</pre>

<p>
<b>CPTRDB_STALL_CNTS_GO.COM</b><br>
  Calls CPTRDB_STALL_CNTS.COM
</p>

<p>
  Start one stall counts analyze session in batch with hardcoded parameters.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------------------------
$ dbid             = "CPTRDB_DB_1"
$ stall_node       = "L15S29"
$ since_date       = "YESTERDAY"
$ before_date      = "TODAY"
$ stall_cnts_limit = "2"
$ rdb_vrsn         = "7.3"
$ mailto1          = "L15S36::ALLEMEERSCH"
$ exec_node        = "L15S29"
$!----------------------------------------
</pre>

<p>
<b>CPTRDB_STALL_CNTS_ALL.COM</b><br>
  Calls CPTRDB_STALL_CNTS.COM per stall log file.
</p>

<p>
  List 'waiting for' messages counts, desc per hour, from the stall logfiles
  for a series of databases, nodes, and periods.
</p>

<p>
  The list of parameters per stall log file is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords  
  CPT$RDB_DATABASE|CPTRDB_STALL_CNTS.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|CPTRDB_DB_1|L15S29|YESTERDAY|TODAY|60|7.3|L15S36::ALLEMEERSCH|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_STALL_CNTS
! 2 Database
! 3 Stall node
! 4 Since date
! 5 Before date
! 6 Stall counts alarm limit
! 7 Rdb version
! 8 Exception mail address
! 9 Execution node
</pre>

<p>
  Extract of a production configuration file for one database in a six node 
  cluster with a daily analysis:
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S50|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S51|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S52|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S53|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S58|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
CPT$RDB_DATABASE|CPTRDB_STALL_CNTS|SBN_DB|L15S59|YESTERDAY|TODAY|30|7.2|L15S36::ALLEMEERSCH|L15S50|
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_STALL_CNTS_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_STALL_CNTS_ALL|L15S29|TOMORROW + 04:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_STALL_CNTS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_STALL_RW_CNTS.COM</b><br>
  Called per stall file from CPTRDB_STALL_RW_CNTS_[GO|ALL].COM
</p>

<p>
  List not 'waiting for' stall counts, desc per hour, from the stall logfile(s)
  for a specific database, node, and period.
</p>
  
<p>
  The stall messages of interest, other than 'waiting for', and their char(1)
  indicator in the output file are:
</p>  

<pre>
B binding
B bugcheck
C committing
C connecting
C creating
E extending
F finding
H hibernating
I initializing
L latching
O opening
P performing
P prepared,
P processing
Q querying
R RCS
R reading
S sending
S switching
W waiting n seconds for next pass through AIJ files
W writing
</pre>

<p>
  Send mail and CockpitMgr event if a counts per hour alarm is exceeded.
</p>
  
<pre>
Parameters: P1, database logical,       varchar(255)
            P2, stall node,             char(6)
            P3, /since  date,           date vms
            P4, /before date,           date vms
            P5, stall r/w cnts limit,   integer
            P6, Rdb version,            char(3), [7.2|7.3]
            P7, exception mail address, varchar(255)
</pre>

<p>
  The procedure requires:
</p>
  
<pre>
. The P1 database contains the storage area
  STALL_CNTS_AREA
  that can be created using CPT$RDB:CPTRDB_STALL_CNTS_ADD_SAREA.COM

. A stall logs format of
  {stall_dir}:{dbid}*STALL*{node}*.LOG*
</pre>

<p>
  The procedure (re)creates a table named STALL_RW_CNTS in the P1 database
  to load the extracted stall messages, and performs a count group by 
  the day, the hour of the day, the stall type and the stalled database object.
</p>

<p>
  Some frequent reoccurring stall types can be excluded from notification.
  They are still flagged in the output file as '*Exceeded*' and visible using 
  the CPTRDB_DAILY.COM procedure. 
</p>

  Source extract:<br>

<pre>
  -- Do not send mail/cockpit when only hibernating stalls
  -- Do not send mail/cockpit before 02:00
  -- Add additional conditions here

  if :t1.stall_cnt >= :stall_rw_cnts_limit
--    and :t1.indic_rw <> 'H'
--    and cast(:t1.stall_time as integer) >= 2
  then
    set :cnt_status = '*Exceeded Send*';
    call lib$set_symbol('STALL_RW_CNTS_SEND','YES');
  end if;
</pre>

<p>
  If implemented, the analyze database ANA_{P1} is a feasible alternative
  to create the STALL_CNTS_AREA storage area and STALL_RW_CNTS table.
</p>

<pre>
$!-----------------------------------
$!$ define sql$database "ANA_''dbid'"
$!-----------------------------------
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_StallRwCntsExceeded
"CPTRDB - Stall R/W Cnts Exceeded {db} {node} yyyymmdd - ddmmmhhmmss"
</pre>

  Toolset mail subject:<br>

<pre>
"CPTRDB - Stall R/W Cnts Exceeded {db} {node} yyyymmdd"
</pre>

  Output sample:<br>

<pre> 
CPTRDB - Not 'waiting for' Stall Counts Per Hour From Node L15S52
For Database: DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB
On Node:      L15S59
Since:        11-OCT-2018
Before:       12-OCT-2018
Alarm:        15
At:           12-OCT-2018 14:32:05.07
--------------------------------------------------------------------------------
B binding
B bugcheck
C committing
C connecting
C creating
E extending
F finding
H hibernating
I initializing
L latching
O opening
P performing
P prepared
P processing
Q querying
R RCS
R reading
S sending
S switching
W waiting next pass
W writing
--------------------------------------------------------------------------------
2018-10-11|01|    47|I|AIJ journal|*Exceeded Send*
2018-10-11|01|     5|B|to database|
2018-10-11|01|     2|O|storage area DISK$DATA_22:[CLIO_DB]CLIO_CLNTS_DATA.SNP;1 file|
-----------------------
2018-10-11|06|     9|I|AIJ journal|
-----------------------
2018-10-11|14|     2|W|4 pages back to database|
-----------------------
2018-10-11|15|     2|H|on AIJ I/O completion|
-----------------------
2018-10-11|22|     2|B|to database|
--------------------------------------------------------------------------------
Total number of stall groups:      7
Total number of stall lines:      69

12-OCT-2018 14:32:06.73 *Stall R/W Cnts Exceeded CLIO_DB L15S59 20181011*
 
12-OCT-2018 14:32:06.73 *Stall R/W Cnts Send     CLIO_DB L15S59 20181011*
</pre> 

<p>
<b>CPTRDB_STALL_RW_CNTS_GO.COM</b><br>
  Calls CPTRDB_STALL_RW_CNTS.COM
</p>

<p>
  Start one not 'waiting for' stall counts per hour analysis session in batch,
  with hardcoded parameters.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------------------------
$ dbid                = "CPTRDB_DB_1"
$ stall_node          = "L15S29"
$ since_date          = "YESTERDAY"
$ before_date         = "TODAY"
$ stall_rw_cnts_limit = "1"
$ rdb_vrsn            = "7.3"
$ mailto1             = "L15S36::ALLEMEERSCH"
$ exec_node           = "L15S29"
$!-------------------------------------------
</pre>

<p>
<b>CPTRDB_STALL_RW_CNTS_ALL.COM</b><br>
  Calls CPTRDB_STALL_RW_CNTS.COM per stall log file.
</p>

<p>
  Daily report not 'waiting for' stall counts, desc per hour, from the stall 
  logfiles for a series of databases, nodes and periods.
</p>

<p>
  The list of parameters per stall log file is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords  
  CPT$RDB_DATABASE|CPTRDB_STALL_RW_CNTS
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_STALL_RW_CNTS|CPTRDB_DB_1|L15S29|YESTERDAY|TODAY|24|7.3|L15S36::ALLEMEERSCH|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_STALL_RW_CNTS
! 2 Database
! 3 Stall node
! 4 Since date
! 5 Before date
! 6 Stall counts per hour alarm limit
! 7 Rdb version
! 8 Exception mail address
! 9 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_STALL_RW_CNTS_ALL
</p>

<pre>
CPT$RDB_JOB|CPTRDB_STALL_RW_CNTS_ALL|L15S29|TOMORROW + 04:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_STALL_RW_CNTS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 32"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 32 -- List And Detect Excessive Deadlock Counts Per Hour
</font>
</h3>

<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br><br>

<b>CPTRDB_DDLCK_CNTS.COM</b><br>
<b>CPTRDB_DDLCK_CNTS.RRD</b><br>
<b>CPTRDB_DDLCK_CNTS_GO.COM</b><br>
<b>CPTRDB_DDLCK_CNTS_ALL.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The purpose of these procedures is to detect potential hotspots and performance
bottlenecks within a database, by (daily) analyzing the deadlock logfiles.
</p>

<p>
<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br>
  Add a storage area to a database to store the WAITING_FOR_DDLCKS table,
  used in the 'deadlock counts per hour' reporting.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_DB_1"
$!----------------------
</pre>

<p>
<b>CPTRDB_DDLCK_CNTS.COM</b><br>
  Called per deadlock log file from CPTRDB_DDLCK_CNTS_[GO|ALL].COM
</p>

<p>
  List 'waiting for' messages counts, desc per hour, from the deadlock 
  logfile(s) for a specific database, node, and period.
  
  Send mail and CockpitMgr event if a deadlock counts per hour alarm is exceeded.
</p>
  
<pre>
Parameters: P1, database logical,       varchar(255)
            P2, ddlck node,             char(6)
            P3, /since  date,           date vms 
            P4, /before date,           date vms 
            P5, ddlck counts alarm,     integer
            P6, Rdb version,            char(3), [7.2|7.3]
            P7, exception mail address, varchar(255)
</pre>
  
  The procedure requires:<br>
  
<pre>
. The P1 database contains the storage area
  STALL_CNTS_AREA
  that can be created using CPT$RDB:CPTRDB_STALL_CNTS_ADD_SAREA.COM
  
. A deadlock logs format of
  {stall_dir}:{dbid}*DEADLOCK*{node}*.LOG*
</pre>
  
<p>
  The procedure (re)creates a table named WAITING_FOR_DDLCKS in the P1 database
  to load the extracted 'waiting for' messages, and performs a count group by 
  the day, the hour of the day and the deadlocked database object.

  Default no additional conditions are applied for notification. A mail
  and CockpitMgr event are sent as soon a the deadlock counts alarm limit
  is reached.
</p>

  Source extract:<br>

<pre>
-- Always send mail/cockpit
-- Add additional conditons here

if :t1.stall_cnt >= :ddlck_cnts_limit then
  set :cnt_status = '*Exceeded Send*';
  call lib$set_symbol('DDLCK_CNTS_SEND','YES');
end if;
</pre>

<p>
  If implemented, the analyze database ANA_{P1} is a feasible alternative
  to create the STALL_CNTS_AREA storage area and WAITING_FOR_DDLCKS table.
</p>

<pre>
$!-----------------------------------
$!$ define sql$database "ANA_''dbid'"
$!-----------------------------------
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_DeadlockCntsExceeded
"CPTRDB - Deadlock Cnts Exceeded {db} {node} yyyymmdd - ddmmmhhmmss"
</pre>

  Toolset mail subject:<br>

<pre>
"CPTRDB - Deadlock Cnts Exceeded {db} {node} yyyymmdd"
</pre>

  Output sample without notification:<br>

<pre>
CPTRDB - Deadlock Counts Per Hour From Node L15S50
For Database: DISK$DATA_25:[C170_DB]C170_DB.RDB
On Node:      L15S58
Since:        16-JUN-2015
Before:       17-JUN-2015
Alarm:        6
At:           17-JUN-2015 04:30:11.32
--------------------------------------------------------------------------------
2015-06-16|11|     1|page 16:625 (PW)|
---------------------
2015-06-16|13|     1|page 1:378 (PW)|
--------------------------------------------------------------------------------
Total number of ddlck groups:      2
Total number of ddlck lines:       2
</pre>

<p>
<b>CPTRDB_DDLCK_CNTS_GO.COM</b><br>
  Calls CPTRDB_DDLCK_CNTS.COM
</p>

<p>
  Start one deadlock counts analyze session in batch with hardcoded parameters.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------------------------
$ dbid             = "CPTRDB_DB_1"
$ stall_node       = "L15S58"
$ since_date       = "YESTERDAY"
$ before_date      = "TODAY"
$ ddlck_cnts_limit = "2"
$ rdb_vrsn         = "7.3"
$ mailto1          = "L15S36::ALLEMEERSCH"
$ exec_node        = "L15S29"
$!----------------------------------------
</pre>

<p>
<b>CPTRDB_DDLCK_CNTS_ALL.COM</b><br>
  Calls CPTRDB_DDLCK_CNTS.COM per deadlock log file.
</p>

<p>
  List 'waiting for' messages counts, desc per hour, from the deadlock logfiles
  for a series of databases, nodes, and periods.
</p>

<p>
  The list of parameters per deadlock log file is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords  
  CPT$RDB_DATABASE|CPTRDB_DDLCK_CNTS.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_DDLCK_CNTS|CPTRDB_DB_1|L15S29|YESTERDAY|TODAY|12|7.3|L15S36::ALLEMEERSCH|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_DDLCK_CNTS
! 2 Database
! 3 Deadlock node
! 4 Since date
! 5 Before date
! 6 Deadlock counts per hour alarm limit
! 7 Rdb version
! 8 Exception mail address
! 9 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_DDLCK_CNTS_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_DDLCK_CNTS_ALL|L15S29|TOMORROW + 04:45|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_DDLCK_CNTS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 33"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 33 -- List And Detect Excessive Stall Times
</font>
</h3>

<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br><br>

<b>CPTRDB_STALL_TIMES.COM</b><br>
<b>CPTRDB_STALL_TIMES.RRD</b><br>
<b>CPTRDB_STALL_TIMES_GO.COM</b><br>
<b>CPTRDB_STALL_TIMES_ALL.COM</b><br><br>

<b>CPTRDB_STALL_RW_TIMES.COM</b><br>
<b>CPTRDB_STALL_RW_TIMES.RRD</b><br>
<b>CPTRDB_STALL_RW_TIMES_GO.COM</b><br>
<b>CPTRDB_STALL_RW_TIMES_ALL.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The purpose of these procedures is to detect potential hotspots and performance
bottlenecks within a database, by (daily) analyzing the stall logfiles.
</p>

<p>
<b>CPTRDB_STALL_CNTS_ADD_SAREA.COM</b><br>
  Add a storage area to a database to store the WAITING_FOR_TIMES and
  STALL_RW_TIMES tables, used in the 'stall times' reporting.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_DB_1"
$!----------------------
</pre>

<p>
<b>CPTRDB_STALL_TIMES.COM</b><br>
  Called per stall log file from CPTRDB_STALL_TIMES_[GO|ALL].COM
</p>

<p>
  List 'waiting for' messages stall times from the stall logfile(s)
  for a specific database, node, and period.

  Send mail and CockpitMgr event if a stall times alarm is exceeded.
</p>
  
<pre>
Parameters: P1, database logical,       varchar(255)
            P2, stall node,             char(6)
            P3, /since  date,           date vms
            P4, /before date,           date vms
            P5, stall times alarm,      integer seconds
            P6, Rdb version,            char(3), [7.2|7.3]
            P7, exception mail address, varchar(255)
</pre>

  The prodedure requires:<br>

<pre>
. The P1 database contains the storage area
  STALL_CNTS_AREA
  that can be created using CPT$RDB:CPTRDB_STALL_CNTS_ADD_SAREA.COM
  
. A stall logs format of
  {stall_dir}:{dbid}*STALL*{node}*.LOG*
</pre>

<p>
  The procedure (re)creates a table named WAITING_FOR_TIMES in the P1 database
  to load the extracted 'waiting for' messages, and performs a count group by 
  the repeating 2nd 'since' timestamp, the Rdb process:stream_id and the 
  stalled database object.
</p>

  Input stall logfile extract:<br>

<pre>
...
19-FEB-2015 15:38:48.8884258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
   State... Process.ID Process.name... Lock.ID. Rq Gr Queue "quiet"
   Blocker: 2BAF095C   RDB72_BG35833   0506FA71    CR Grant
   Owner:   2BA208D0   RDB72_BG37465   450A081B    NL Grant
   Waiting: 2BB18337   AIJBCK L15S45   1C114A54 EX NL Cnvrt
19-FEB-2015 15:38:49.8904258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:50.8914258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:51.8924258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:52.8934258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:53.8944258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:54.8964258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:55.8974258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
19-FEB-2015 15:38:56.8984258 2BB18337:1 19-FEB-2015 15:38:48.1544258 waiting for quiet (EX)
...
</pre>

<p>
  Assuming a one second refresh rate of the stall messages (the default), the 
  stall times groupby count of the 'since' timestamp reflects a wait time in 
  seconds.

  Some frequent reoccurring database objects such as SEQBLK and 'TSN block'
  are excluded from notification, if they are the only alarms reported
  for the stall log file. They still are flagged in the output file
  as '*Exceeded*' and visible using the CPTRDB_DAILY.COM procedure. 
</p>

  Source extract:<br>

<pre>
-- Do not send mail/cockpit when only seqblk/tsn block stalls
-- Do not send mail/cockpit before 02:00
-- Add additional conditions here

if    :t1.stall_seconds >= :stall_times_limit
  and :t1.stall_reason not starting with 'SEQBLK'
  and :t1.stall_reason not starting with 'TSN block'
  and cast(substring(:t1.stall_time from 1 for 2) as integer) >= 2
then
  set :times_status = '*Exceeded Send*';
  call lib$set_symbol('STALL_TIMES_SEND','YES');
end if;
</pre>

<p>
  If implemented, the analyze database ANA_{P1} is a feasible alternative
  to create the STALL_CNTS_AREA storage area and WAITING_FOR_TIMES table.
</p>

<pre>
$!-----------------------------------
$!$ define sql$database "ANA_''dbid'"
$!-----------------------------------
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_StallTimesExceeded
"CPTRDB - Stall Times Exceeded {db} {node} yyyymmdd - ddmmmhhmmss"
</pre>

  Toolset mail subject:<br>

<pre>
"CPTRDB - Stall Times Exceeded {db} {node} yyyymmdd"
</pre>

  Output sample with notification:<br>

<pre>
CPTRDB - Stall Times Greater Than One Second From Node L15S50
For Database: DISK$DATA_25:[C170_DB]C170_DB.RDB
On Node:      L15S58
Since:        16-JUN-2015
Before:       17-JUN-2015
Alarm:        6
At:           17-JUN-2015 05:00:13.32
------------------------------------------------------------------------------------------------------------------------------------
2015-06-16|07:00:16.5417482|27A106C6:2582 |    6|record 84:33701:0 (EX)|*Exceeded Send*
2015-06-16|08:36:12.3185982|27BF9B16:2771 |    3|record 70:453708:0 (EX)|
2015-06-16|10:10:51.6908182|27BDDB72:2886 |    2|async-write of pages 6:488456 to 6:488456|
2015-06-16|10:18:32.6881582|27BEDA22:2891 |    2|record 70:453708:0 (EX)|
2015-06-16|10:40:12.6004982|27A51075:2975 |    4|record 95:35923:0 (EX)|
2015-06-16|10:40:14.0124982|27BEDA22:2969 |    4|record 95:35923:0 (EX)|
2015-06-16|11:49:09.8758682|27A69351:3210 |    2|page 1:378 (PW)|
2015-06-16|12:19:13.1481482|27BF9B16:3385 |    8|record 76:298409:0 (EX)|*Exceeded Send*
2015-06-16|13:50:38.0238582|27A203CB:3453 |    2|page 1:378 (PW)|
2015-06-16|14:49:31.3013882|27BDDB72:4219 |    2|record 70:453708:0 (EX)|
2015-06-16|15:18:50.9098482|27A51075:4334 |    7|record 70:453708:0 (EX)|*Exceeded Send*
2015-06-16|15:50:23.7978182|27BEDA22:4438 |    3|record 84:33701:0 (EX)|
2015-06-16|16:47:50.7167982|27BDDB72:4608 |    3|record 76:298409:0 (EX)|
2015-06-16|18:17:49.5250382|27A5897F:4667 |   13|record 84:33701:0 (EX)|*Exceeded Send*
2015-06-16|19:48:31.2674582|27A5897F:4687 |    2|routine SYS$CREATE|
------------------------------------------------------------------------------------------------------------------------------------
Total number of stall groups:      15
Total number of stall seconds:     63

17-JUN-2015 05:00:15.72 *Stall times exceeded C170_DB L15S58 20150616*

17-JUN-2015 05:00:15.73 *Stall times send     C170_DB L15S58 20150616*
</pre>

<p>
<b>CPTRDB_STALL_TIMES_GO.COM</b><br>
  Calls CPTRDB_STALL_TIMES.COM
</p>

<p>
  Start one stall times session in batch with hardcoded parameters.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------
$ dbid              = "CPTRDB_DB_1"
$ stall_node        = "L15S59"
$ since_date        = "21-JAN-2015"
$ before_date       = ""
$ stall_times_limit = "5"
$ rdb_vrsn          = "7.3"
$ mailto1           = "L15S36::ALLEMEERSCH"
$ exec_node         = "L15S29"
$!-----------------------------------------
</pre>

<p>
<b>CPTRDB_STALL_TIMES_ALL.COM</b><br>
  Calls CPTRDB_STALL_TIMES.COM per stall log file.
</p>

<p>
  List 'waiting for' stall times from the stall logfiles
  for a series of databases, nodes, and periods.
</p>

<p>
  The list of parameters per stall log file is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords  
  CPT$RDB_DATABASE|CPTRDB_STALL_TIMES.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_STALL_TIMES|CPTRDB_DB_1|L15S29|YESTERDAY|TODAY|6|7.3|L15S36::ALLEMEERSCH|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_STALL_TIMES
! 2 Database
! 3 Stall node
! 4 Since date
! 5 Before date
! 6 Stall time alarm limit, seconds
! 7 Rdb version
! 8 Exception mail address
! 9 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_STALL_TIMES_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_STALL_TIMES_ALL|L15S29|TOMORROW + 05:00|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_STALL_TIMES_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_STALL_RW_TIMES.COM</b><br>
  Called per stall file from CPTRDB_STALL_RW_TIMES_[GO|ALL].COM
</p>

<p>
  List not 'waiting for' stall times from the stall logfile(s) for a specific 
  database, node, and period.
</p>
  
<p>
  The stall messages of interest, other than 'waiting for', and their char(1)
  indicator in the output file are:
</p>
  
<pre>
B binding
B bugcheck
C committing
C connecting
C creating
E extending
F finding
H hibernating
I initializing
L latching
O opening
P performing
P prepared,
P processing
Q querying
R RCS
R reading
S sending
S switching
W waiting n seconds for next pass through AIJ files
W writing
</pre>

<p>
  Send mail and CockpitMgr event if a number of seconds times alarm is exceeded.
</p>
  
<pre>
Parameters: P1, database logical,       varchar(255)
            P2, stall node,             char(6)
            P3, /since  date,           date vms
            P4, /before date,           date vms
            P5, stall r/w times limit,  integer, seconds
            P6, Rdb version,            char(3), [7.2|7.3]
            P7, exception mail address, varchar(255)
</pre>

  The procedure requires:<br>
  
<pre>
. The P1 database contains the storage area
  STALL_CNTS_AREA
  that can be created using CPT$RDB:CPTRDB_STALL_CNTS_ADD_SAREA.COM

. A stall logs format of
  {stall_dir}:{dbid}*STALL*{node}*.LOG*
</pre>

<p>
  The procedure (re)creates a table named STALL_RW_TIMES in the P1 database
  to load the extracted stall messages, and performs a count group by 
  the repeating 2nd 'since' timestamp, the Rdb process:stream_id, the stall
  type and the stalled database object.
</p>

<p>
  Assuming a one second refresh rate of the stall messages (the default), the
  stall times groupby count of the 'since' timestamp reflects a wait time in
  seconds.
</p>

<p>
  Some frequent reoccurring stall types can be excluded from notification.
  They are still flagged in the output file as '*Exceeded*' and visible using 
  the CPTRDB_DAILY.COM procedure. 
</p>

  Source extract:<br>

<pre>
  -- Do not send mail/cockpit when only ... stalls
  -- Do not send mail/cockpit before 02:00
  -- Add additional conditions here

  if    :t1.stall_seconds >= :stall_rw_times_limit
--    and :t1.stall_reason not starting with ''
--    and :t1.stall_reason not starting with ''
--    and :t1.stall_reason not starting with ''
--    and cast(substring(:t1.stall_time from 1 for 2) as integer) >= 2
  then
    set :times_status = '*Exceeded Send*';
    call lib$set_symbol('STALL_RW_TIMES_SEND','YES');
  end if;
</pre>

<p>
  If implemented, the analyze database ANA_{P1} is a feasible alternative
  to create the STALL_CNTS_AREA storage area and STALL_RW_TIMES table.
</p>

<pre>
$!-----------------------------------
$!$ define sql$database "ANA_''dbid'"
$!-----------------------------------
</pre>

  Toolset CockpitMgr event:<br>

<pre>
  CPTRDB_StallRwTimesExceeded
  "CPTRDB - Stall R/W Times Exceeded {db} {node} yyyymmdd - ddmmmhhmmss"
</pre>

  Toolset mail subject:<br>

<pre>
  "CPTRDB - Stall R/W Times Exceeded {db} {node} yyyymmdd"
</pre>

  Output sample:<br>

<pre> 
CPTRDB - Not 'waiting for' Stall Times Greater Than One Second From Node L15S52
For Database: DISK$DATA_23:[SBN_DB]SABIN_TT.RDB
On Node:      L15S59
Since:        21-OCT-2018
Before:       22-OCT-2018
Alarm:        6
At:           22-OCT-2018 05:00:15.68
------------------------------------------------------------------------------------------------------------------------------------
B binding
B bugcheck
C committing
C connecting
C creating
E extending
F finding
H hibernating
I initializing
L latching
O opening
P performing
P prepared
P processing
Q querying
R RCS
R reading
S sending
S switching
W waiting next pass
W writing
------------------------------------------------------------------------------------------------------------------------------------
2018-10-21|06:09:31.3976083|2A5CBC5A:1    |   14|I|AIJ journal|*Exceeded Send*
2018-10-21|09:32:21.2217883|2A47811D:3    |    4|H|on AIJ submission|
2018-10-21|12:22:32.4441883|2A53AFC8:1    |    2|I|AIJ journal|
------------------------------------------------------------------------------------------------------------------------------------
Total number of stall groups:       3
Total number of stall seconds:     20

22-OCT-2018 05:00:16.59 *Stall R/W Times Exceeded SBN_DB L15S59 20181021*
 
22-OCT-2018 05:00:16.60 *Stall R/W Times Send     SBN_DB L15S59 20181021*
</pre> 

<p>
<b>CPTRDB_STALL_RW_TIMES_GO.COM</b><br>
  Calls CPTRDB_STALL_RW_TIMES.COM
</p>

<p>
  Start one not 'waiting for' stall times analysis session in batch,
  with hardcoded parameters.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------------------------
$ dbid                 = "CPTRDB_DB_1"
$ stall_node           = "L15S29"
$ since_date           = "YESTERDAY"
$ before_date          = "TODAY"
$ stall_rw_times_limit = "1"
$ rdb_vrsn             = "7.3"
$ mailto1              = "L15S36::ALLEMEERSCH"
$ exec_node            = "L15S29"
$!-------------------------------------------
</pre>

<p>
<b>CPTRDB_STALL_RW_TIMES_ALL.COM</b><br>
  Calls CPTRDB_STALL_RW_TIMES.COM per stall log file.
</p>

<p>
  Daily report not 'waiting for' stall times from the stall logfiles for a 
  series of databases, nodes and periods.
</p>

<p>
  The list of parameters per stall log file is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords  
  CPT$RDB_DATABASE|CPTRDB_STALL_RW_TIMES
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_STALL_RW_TIMES|CPTRDB_DB_1|L15S29|YESTERDAY|TODAY|24|7.3|L15S36::ALLEMEERSCH|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_STALL_RW_TIMES
! 2 Database
! 3 Stall node
! 4 Since date
! 5 Before date
! 6 Stall times alarm limit, seconds
! 7 Rdb version
! 8 Exception mail address
! 9 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file,
  identified by the keywords CPT$RDB_JOB|CPTRDB_STALL_RW_TIMES_ALL
</p>

<pre>
CPT$RDB_JOB|CPTRDB_STALL_RW_TIMES_ALL|L15S29|TOMORROW + 04:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_STALL_RW_TIMES_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 34"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 34 -- Placement Via Hashed Index And Vertical/Horizontal Partitioning
</font>
</h3>

<b>CPTRDB_ADD_STORAGE_AREAS.COM</b><br>
<b>CPTRDB_ADD_TABLES.COM</b><br>
<b>CPTRDB_DBKEYS_GROUPBY_PAGE.COM</b><br>
<b>CPTRDB_ANALYZE_PLACEMENT.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_ADD_STORAGE_AREAS.COM</b><br>
  Add storage areas to the test database to implement vertical/horizontal
  partitioning and placement via hashed index, using matrix naming conventions,
  row_number/column_number for the storage areas names.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_DB_1"
$!----------------------
</pre>

  The storage areas added are:<br>

<pre>
DATA_AREA_11
DATA_AREA_12
DATA_AREA_21
DATA_AREA_22
DATA_AREA_31
DATA_AREA_32
INDEX_AREA_1
INDEX_AREA_2
INDEX_AREA_3
MIXED_AREA_1
MIXED_AREA_2
MIXED_AREA_3
</pre>

<p>
<b>CPTRDB_ADD_TABLES.COM</b><br>
  Create and load tables in the test database to demonstrate
  placement via hashed index and vertical/horizontal partitioning.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------------
$ define sql$database cptrdb_db_1
$!-------------------------------
</pre>

  The tables added are:<br>

<pre>
TABLE_PARTI, partitioned across DATA_AREA_nn
TABLE_PLACE, placement via hashed index across MIXED_AREA_n
</pre>

<p>
  A sorted index on TABLE_PARTI is partitioned across INDEX_AREA_n.
</p>

<p>
<b>CPTRDB_DBKEYS_GROUPBY_PAGE.COM</b><br>
  List the row dbkeys counts, group by page, and avg number of rows per page 
  for a single database and hardcoded table. 
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------------------------
$ dbid       = "CPTRDB_DB_1"
$ table_name = "TABLE_PARTI"
$! *** Adapt the sql FROM {table name} ***
$!----------------------------------------
</pre>

<p>
  The procedure allows to evaluate in detail the hashing effectiveness
  and data distribution. The results (on a subset of data) can also
  be usefull in sizing (new) storage areas.<br> 
  Note that the dbkey always refers to the first vertical partition
  which is always read in a access by dbkey.<br>
  Individual pages can be dumped using CPTRDB_SHOW_ONE_PAGE.COM.
</p>

  Usage batch:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_DBKEYS_GROUPBY_PAGE
</pre>

<p>
  Requires the CPT$RDB:CPTRDB_SHOW_DBKEY.SQL external functions
  and information tables.<br>

  Adapt the table name in the sql FROM clause !!! 
</p>

  Output sample:<br>

<pre>
Row Dbkeys Counts Group By Page
For Table TABLE_PARTI
Of Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-03-31 15:48:21
--------------------------------------------------------------------------------
TABLE_PARTI
 Count  LArea  SArea   Page SArea
--------------------------------------------------------------------------------
    41|    73|     7|     8|DATA_AREA_11
    41|    73|     7|     9|DATA_AREA_11
    41|    73|     7|    10|DATA_AREA_11
    41|    73|     7|    11|DATA_AREA_11
    41|    73|     7|    12|DATA_AREA_11
    41|    73|     7|    13|DATA_AREA_11
    41|    73|     7|    14|DATA_AREA_11
    41|    73|     7|    15|DATA_AREA_11
    41|    73|     7|    16|DATA_AREA_11
    41|    73|     7|    17|DATA_AREA_11
    41|    73|     7|    18|DATA_AREA_11
    41|    73|     7|    19|DATA_AREA_11
     9|    73|     7|    20|DATA_AREA_11
    41|    74|     9|     8|DATA_AREA_21
    41|    74|     9|     9|DATA_AREA_21
    41|    74|     9|    10|DATA_AREA_21
    41|    74|     9|    11|DATA_AREA_21
    41|    74|     9|    12|DATA_AREA_21
    41|    74|     9|    13|DATA_AREA_21
    41|    74|     9|    14|DATA_AREA_21
    41|    74|     9|    15|DATA_AREA_21
    41|    74|     9|    16|DATA_AREA_21
    41|    74|     9|    17|DATA_AREA_21
    41|    74|     9|    18|DATA_AREA_21
    41|    74|     9|    19|DATA_AREA_21
     8|    74|     9|    20|DATA_AREA_21
    41|    75|    11|     8|DATA_AREA_31
    41|    75|    11|     9|DATA_AREA_31
    41|    75|    11|    10|DATA_AREA_31
    41|    75|    11|    11|DATA_AREA_31
    41|    75|    11|    12|DATA_AREA_31
    41|    75|    11|    13|DATA_AREA_31
    41|    75|    11|    14|DATA_AREA_31
    41|    75|    11|    15|DATA_AREA_31
    41|    75|    11|    16|DATA_AREA_31
    41|    75|    11|    17|DATA_AREA_31
    41|    75|    11|    18|DATA_AREA_31
    41|    75|    11|    19|DATA_AREA_31
     8|    75|    11|    20|DATA_AREA_31
--------------------------------------------------------------------------------
Number of rows :         1501
          pages:           39
Avg rows/page  :        38.49
</pre>

<p>
<b>CPTRDB_ANALYZE_PLACEMENT.COM</b><br>
  Execute RMU/Analyze/Placement for one hardcoded 'placement via'
  hashed index and database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------
$ dbid  = "CPTRDB_DB_1"
$ hdxid = "TABLE_PLACE_HDX"
$!-------------------------
</pre>

/PARTITIONS - ! Is Rdb v7.3 only<br><br>

  Usage batch:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_ANALYZE_PLACEMENT
</pre>

<p>
Physical design hint for horizontal partitioned tables in uniform page format
storage areas, with buildup of recent data and physical cleanup of aging data:
</p>

<pre>
.Specify the storage map as PARTITIONING IS NOT UPDATABLE
.If a sorted index has the same partitioning condition, store
 the index with the data.
</pre>

<p>
  With this setup, aging data and index can be easily removed (also physically)
  in one statement using ALTER DATABASE DROP STORAGE AREA CASCADE for
  the oldest storage areas.

  Rdb will do the right thing and adapt the data and index storage maps
  accordingly in one single step.
</p>

<p>
The module RDB$STORAGE_MAPS contains the {map name} functions that allow to
test if a data item fits within the partitioning bounderies of a storage map.
</p>

Consider:<br>

<pre>
----
SQL> show module rdb$storage_maps
Information for module RDB$STORAGE_MAPS
 
 Header:
 RDB$STORAGE_MAPS
 Comment:	Contains storage map routines
 Module ID is: -70
 
Routines in module RDB$STORAGE_MAPS:
     LISTTAB_MAP
     TABLE_PARTI_MAP
     TABLE_PARTI_MAP__2
     TABLE_PLACE_MAP
     TABLE_TRACE_MAP
     WAITING_FOR_CNTS_MAP
     WAITING_FOR_DDLCKS_MAP
     WAITING_FOR_TIMES_MAP
 
SQL> show function TABLE_PARTI_MAP
Information for function TABLE_PARTI_MAP
 
 Function ID is: -72
 Source:
return 
    case 
	when (:COL1 <= 500) then 1
	when (:COL1 <= 1000) then 2
	when (:COL1 <= 1500) then 3
	else -1
    end;
 Comment:	Return value for select partition - range 1 .. 3 - return -1 if
		 out of range
 Module name is: RDB$STORAGE_MAPS
 Module ID is: -70
 Number of parameters is: 1
 
Parameter Name			Data Type	 Domain or Type
--------------			---------	 --------------
                                INTEGER		 
	Function result datatype
	Return value is passed by value
 
COL1                            INTEGER		 
	Parameter position is 1
	Parameter is IN (read)
	Parameter is passed by reference
 
SQL> show function listtab_map
Information for function LISTTAB_MAP

 Function ID is: -77
 Source:
return 1;
 Comment:       Mapped to just one area - always return 1
 Module name is: RDB$STORAGE_MAPS
 Module ID is: -70
 Number of parameters is: 0

Parameter Name                  Data Type        Domain or Type
--------------                  ---------        --------------
                                INTEGER
        Function result datatype
        Return value is passed by value
----
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 35"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 35 -- Collect And Store RMU/Analyze Data
</font>
</h3>

<b>CPTRDB_CREATE_ANA_DB.COM</b><br><br>

<b>CPTRDB_ANA_DBS_WEEKLY.COM</b> (Calls)<br>
<b>CPTRDB_ANA_DBS_BATCH.COM</b><br><br>

<b>CPTRDB_RMU$ANALYZE_AREA_72.RRD</b><br>
<b>CPTRDB_RMU$ANALYZE_AREA_73.RRD</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_CREATE_ANA_DB.COM</b><br>
  Create a database to store the per database RMU/Analyze data, with the
  specific settings:
</p>

<pre>
Number of cluster nodes 1
Open AUTOMATIC (wait 60 minutes for close)
</pre>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "ANA_CPTRDB_DB_1"
$!------------------------
</pre>

<p>
  The column RMU$DATE of table RMU$ANALYZE_AREA is defined as date ansi DATE 
  (not DATE VMS) and unique (via unique sorted index) to allow for exact
  match in queries.

  The database is named ANA_{dbid}.
  This is a requirement for all analyze reporting procedures.
</p>

  Rdb v7.3 provides 4 extra columns, only filled if using /PARTITIONS<br>

<pre>
RMU$TABLE_NAME     char(32),     -- v7.3 Set if using /partitions,
RMU$INDEX_NAME     char(32),     -- v7.3 conflicts if using /areas,
RMU$PARTITION_NAME char(32),     -- v7.3 only partitioned areas listed.
RMU$ST_AREA_NAME   char(32),     -- v7.3
</pre>

<p>
  Also in Rdb V7.2, the RMU$ANALYZE_AREA table can be created in V7.3 format.
  The CPTRDB_ANA_DBS_BATCH.COM procedure applies the correct /FIELDS
  during the load of the analyze data, depending on the Rdb version running.
</p>

<p>
<b>CPTRDB_ANA_DBS_WEEKLY.COM</b><br>
  Calls CPTRDB_ANA_DBS_BATCH.COM per database
</p>

<p>
  Weekly RMU/Analyze a series of databases and store the binary output
  in eachs individual reporting database named ANA_{dbid},
  created using CPTRDB_CREATE_ANA_DB.COM.

  The list of databases is enumerated in the configuration file 
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|CPTRDB_ANA_DBS.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_ANA_DBS|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_ANA_DBS
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

<p>
  The reschedule date and time are retrieved from the configuration file,  
  identified by the keywords CPT$RDB_JOB|CPTRDB_ANA_DBS_WEEKLY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_ANA_DBS_WEEKLY|L15S29|TOMORROW +6-04:00|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_ANA_DBS_WEEKLY
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_ANA_DBS_BATCH.COM</b><br>
  Called per database from CPTRDB_ANA_DBS_WEEKLY.COM
</p>

<p>
  The procedure performs three execution steps:
</p>

<pre>
1) RMU/Analyze one database and store the binary output
   in it's individual reporting database named ANA_{dbid},
   created using CPTRDB_CREATE_ANA_DB.COM .

   Both Rdb V7.2 and V7.3 are handled. The procedure assumes the
   RMU$ANALYZE_AREA table has a V7.3 format, with 4 extra columns.
   In Rdb V7.2 the correct /FIELDS qualifier is applied to RMU/Load the analyze
   data.

2) Dump the database header, and create/save the restore and AIJ options files 
   in CPT$RDB_ANA: for later reference (in case of disaster recovery).

3) Create a database backup of the reporting database in CPT$RDB_ANA_DB_BCK:
</pre>

<p>
  In Rdb v7.3 /PARTITIONS conflicts with /AREAS and only lists partitioned
  areas. 
</p>

  Output files sample:<br>

<pre>
Directory DISK$DATA_29:[CPT$RDB_ANA]

CPTRDB_DB_1_AIJ_OPT_L15S29_20151207.LIS_07DEC040000;1
CPTRDB_DB_1_ANA_L15S29_20151207.LIS_07DEC040000;1
CPTRDB_DB_1_ANA_L15S29_20151207.UNL_07DEC040000;1
CPTRDB_DB_1_HDR_L15S29_20151207.LIS_07DEC040000;1
CPTRDB_DB_1_OPT_L15S29_20151207.LIS_07DEC040000;1

Total of 5 files.

Directory DISK$DATA_29:[CPT$RDB_ANA_DB_BCK]

ANA_CPTRDB_DB_1_L15S29_20151207_0400.RBF;1

Total of 1 file.
</pre>

<p>
The load files .unl and database backup files .rbf are cleaned with a
retention interval of 8 days. The log and output files .log and .lis are
cleaned with a retention interval of 22 days.
</p>

<p>
<b>CPTRDB_RMU$ANALYZE_AREA_72.RRD</b><br>
<b>CPTRDB_RMU$ANALYZE_AREA_73.RRD</b><br>
  Used in CPTRDB_ANA_DBS_BATCH.COM<br>
  Rdb v7.2 and v7.3 record structures to load the analyze data.
</p>

<p>
  Rdb v7.3 provides 4 extra columns, only filled if using /PARTITIONS
</p>

<pre>
DEFINE FIELD RMU$TABLE_NAME     DATATYPE IS TEXT SIZE IS 32.
DEFINE FIELD RMU$INDEX_NAME     DATATYPE IS TEXT SIZE IS 32.
DEFINE FIELD RMU$PARTITION_NAME DATATYPE IS TEXT SIZE IS 32.
DEFINE FIELD RMU$ST_AREA_NAME   DATATYPE IS TEXT SIZE IS 32.

RMU$TABLE_NAME.
RMU$INDEX_NAME.
RMU$PARTITION_NAME.
RMU$ST_AREA_NAME.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 36"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 36 -- List RMU/Analyze Data
</font>
</h3>

<b>CPTRDB_ANA_AVAILABLE_DATES.COM</b><br>
<b>CPTRDB_ANA_FRAGMENTS.COM</b><br>
<b>CPTRDB_ANA_FRAGMENTS_DIFF.COM</b><br>
<b>CPTRDB_ANA_FREE_SPACE.COM</b><br>
<b>CPTRDB_ANA_FREE_SPACE_DIFF.COM</b><br>
<b>CPTRDB_ANA_FREE_SPACE_DYN.COM</b><br>
<b>CPTRDB_ANA_FREE_SPACE_DYN_LAREA.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_ALL.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_CONTAINING.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_DYN.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_ONE.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_RDB$.COM</b><br>
<b>CPTRDB_ANA_LAREA_COUNTS_STARTING.COM</b><br>
<b>CPTRDB_ANA_LAREA_ID.COM</b><br>
<b>CPTRDB_ANA_PAGE_SIZE_ALL.COM</b><br>
<b>CPTRDB_ANA_PAGE_SIZE_CONT.COM</b><br>
<b>CPTRDB_ANA_PAGE_SIZE_START.COM</b><br>
<b>CPTRDB_ANA_SAREA_ID.COM</b><br>
<b>CPTRDB_ANA_SAREA_NAME.COM</b><br>
<b>CPTRDB_ANA_SAREA_NAME_SIZES.COM</b><br>

<p>
All procedures in this chapter have a interactive usage mode and use the 
current Rdb version on the executor node.

They require the logical ANA_{dbid} to point to the individual per database 
reporting database.

All {date} input parameters must have a date ansi format yyyy-mm-dd.
</p>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_ANA_AVAILABLE_DATES.COM</b><br>
  List available analysis dates from the RMU/Analyze reporting database
  since a start date.

  Note that the analysis dates have a date ansi format, and are unique
  enforced by a unique index, to allow for exact match queries.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_AVAILABLE_DATES {dbid} {start date}
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29

Available analysis dates
Since:    2015-03-01

At: 2015-04-02 11:37:46
--------------------------------------------------------------------------------
Date
--------------------------------------------------------------------------------
2015-03-02
2015-03-09
2015-03-16
2015-03-23
2015-03-30
2015-04-02
--------------------------------------------------------------------------------
Total number of analysis dates: 6
</pre>

<p>
<b>CPTRDB_ANA_FRAGMENTS.COM</b><br>
  List fragmentation per logical area on a specific day,
  from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_FRAGMENTS {dbid} {min % fragm} {min n rows} {ana date} 

Specify P2=0.00, P3=0 to list all fragmented logical areas.
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_23:[SBN_DB]SABIN_TT.RDB
On node:  L15S50
On:       2015-03-30

Fragmented (%), fragment ratio, and counts per logical area
Areas shown: >= 0.00 % fragmented
             >= 0 rows

At: 2015-04-01 13:02:51
--------------------------------------------------------------------------------
 LaId Larea                           Frag% Ratio      Fcnt      Tcnt
 SaId Sarea
--------------------------------------------------------------------------------
    1 RDB$SEGMENTED_STRINGS            0.23  2.38        16      7009
    1 RDB$SYSTEM

  184 SEASN_TKT_MISC                   0.05  2.00      1874   3600047
    8 SEASN_TKT_DATA

   35 SEASN_TKT_MOBIB                  1.92  2.00     15237    794323
   14 TTONWEB_DATA

   83 SEASN_TKT_PRSN                   0.11  2.00      4381   3940960
    8 SEASN_TKT_DATA

--------------------------------------------------------------------------------
Total number of fragmented logical areas: 4
Total number of alarms: 4
</pre>

<p>
The My Oracle Support Document Id. 283203.1 illustrates how to identify
fragmented rows of a table using the function RDB$$IS_ROW_FRAGMENTED,
that can/must be declared in interactive or dynamic SQL only.
</p>

<pre>
SQL> attach 'filename mf_personnel';
     declare function RDB$$IS_ROW_FRAGMENTED
     (in :dbk char(8) character set unspecified)
     returns integer;

SQL> select college_code, RDB$$IS_ROW_FRAGMENTED (dbkey) from colleges
     where RDB$$IS_ROW_FRAGMENTED (dbkey) = 1;
COLLEGE_CODE
DREW 1
QUIN 1
2 rows selected
</pre>

RDB$$IS_ROW_FRAGMENTED Usage Notes:<br>

<pre>
.A function result of zero (0) indicates a non-fragmented row and a value of 
 one (1) indicates a fragmented row.

.This routine may only be used from Interactive and Dynamic SQL.

.Only valid DBKEY values should be passed to the function.

.If the DBKEY is for a vertically partitioned table then only the fragmented 
 state of the primary segment is reported. There is currently no programatic 
 method to determine fragmented secondary segments.
</pre>

<p>
<b>CPTRDB_ANA_FRAGMENTS_DIFF.COM</b><br>
  List fragmentation and delta's per logical area on two specific days,
  from the RMU/Analyze reporting database.
  The procedure requires that fragmented rows exist on day1 and day2.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_FRAGMENTS_DIFF {dbid} {min % fragm} {min n rows} {ana date1} {ana date2}

Specify P2=0.00, P3=0 to list all fragmented logical areas.
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On        2015-03-23
And:      2015-03-30

Fragmented (%), fragment ratio, counts and deltas per logical area
Areas shown: >= 0.00 % fragmented
             >= 0 rows
             on 2015-03-30

At: 2015-04-01 16:16:18
--------------------------------------------------------------------------------
 LaId Larea                           Frag1 Frag2   Diff Ratio     Fcnt1     Fcnt2     Fdiff
 SaId Sarea                                                        Tcnt1     Tcnt2     Tdiff
--------------------------------------------------------------------------------
    1 RDB$SEGMENTED_STRINGS            0.12  0.12   0.00  2.60         5         5         0
    1 RDB$SYSTEM                                                    4311      4311         0

--------------------------------------------------------------------------------
Total number of fragmented logical areas: 1
Total number of alarms: 1

Fragmented logical areas added or removed:
--------------------------------------------------------------------------------
 LaId Larea                           Frag% Ratio      Fcnt      Tcnt
 SaId Sarea
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_FREE_SPACE.COM</b><br>
  List free space for all storage areas on a specific day
  from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_FREE_SPACE {dbid} {max % free} {min blocks} {ana date}

Specify P2=100, P3=0 to list all areas
</pre>

  Two output samples:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On:       2015-03-30

Total size (blocks) and free space (%, blocks) per storage area
Areas shown: <= 100 % free
             >= 0 block(s)
Areas that contain hashed index(es) are shown regardless, flagged *

At: 2015-04-01 12:45:31
--------------------------------------------------------------------------------
Storage Area                            Size      Free% FreeBlocks StorAreaId
--------------------------------------------------------------------------------
DATA_AREA_11                           12004         97      11660          7
DATA_AREA_12                           12004         97      11685          8
DATA_AREA_21                           12004         97      11684          9
DATA_AREA_22                           12004         97      11686         10
DATA_AREA_31                           12004         97      11684         11
DATA_AREA_32                           12004         97      11686         12
DEFAULT_AREA                           12004         78       9329          2
INDEX_AREA_1                           12004         98      11707         13
INDEX_AREA_2                           12004         98      11707         14
INDEX_AREA_3                           12004         98      11707         15
LISTS_AREA                             12004         98      11729          3
* MIXED_AREA_1                         12056         96      11628          4
* MIXED_AREA_2                         12056         96      11628          5
* MIXED_AREA_3                         12056         96      11628          6
RDB$SYSTEM                             12004         61       7307          1
STALL_CNTS_AREA                        12004         97      11598         16
--------------------------------------------------------------------------------
Total Sizes All Areas                 192220         94     180053
Total Free Excluding Mixed Areas                     76     145169
--------------------------------------------------------------------------------
Total number of storage areas: 16
Total number of alarms, excluding mixed areas: 13
Total number of mixed areas: 3

...

Database: DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB
On node:  L15S50
On:       2015-03-30

Total size (blocks) and free space (%, blocks) per storage area
Areas shown: <= 100 % free
             >= 0 block(s)
Areas that contain hashed index(es) are shown regardless, flagged *

At: 2015-04-02 12:11:13
--------------------------------------------------------------------------------
Storage Area                            Size      Free% FreeBlocks StorAreaId
--------------------------------------------------------------------------------
CLIO_CLNTS_DATA                      1088212         17     187452         14
CLIO_CLNTS_IDX                       2002788          1      22041          6
* CLIO_CLNTS_MIXED                    482248         69     330868          9
CLIO_CLNT_ADR_IDX                    1290184          1      11689          7
* CLIO_CLNT_ADR_MIXED                 482248         54     262234         10
* CLIO_CLNT_ADR_MIXED_2               482248         23     113195         11
CLIO_DESCRIPTIONS                     364768          4      13886          4
CLIO_DESCRIPTIONS_IDX                  12028         95      11465          5
CLIO_FUSION_AREA                      364480          2       7817         13
* CLIO_LNK_KEYS_MIXED                 482248         28     133981         12
CLNTS_DATA                           3585960         11     404111          2
CLNTS_SIDS                           3649200         14     519046          3
PMR_DATA                             1140408         48     549042          8
RDB$SYSTEM                             27550         60      16605          1
--------------------------------------------------------------------------------
Total Sizes All Areas               15454570         17    2583432
Total Free Excluding Mixed Areas                     11    1743154
--------------------------------------------------------------------------------
Total number of storage areas: 14
Total number of alarms, excluding mixed areas: 10
Total number of mixed areas: 4
</pre>

<p>
<b>CPTRDB_ANA_FREE_SPACE_DIFF.COM</b><br>
  List free space, size and delta's per storage area on two specific days,
  from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_FREE_SPACE_DIFF {dbid} {max % free} {min blocks} {ana date1} {ana date2}

Specify P2=100, P3=0 to list all areas
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB
On node:  L15S50
On        2015-01-05
And:      2015-03-30

Free space (%), total size (blocks) and deltas per storage area
Areas shown: <= 100 % free
             >= 0 block(s)
             on 2015-03-30
Areas that contain hashed index(es) are shown regardless, flagged *

At: 2015-04-02 12:15:47
--------------------------------------------------------------------------------
Sarea                           Free1 Free2 FDiff    Size1    Size2 SizeDiff
--------------------------------------------------------------------------------
CLIO_CLNTS_DATA                 17    17    0      1064232  1088212    23980
CLIO_CLNTS_IDX                  1     1     0      2002788  2002788        0
* CLIO_CLNTS_MIXED              69    69    0       482248   482248        0
CLIO_CLNT_ADR_IDX               2     1     -1     1266164  1290184    24020
* CLIO_CLNT_ADR_MIXED           56    54    -2      482248   482248        0
* CLIO_CLNT_ADR_MIXED_2         26    23    -3      482248   482248        0
CLIO_DESCRIPTIONS               7     4     -3      364768   364768        0
CLIO_DESCRIPTIONS_IDX           95    95    0        12028    12028        0
CLIO_FUSION_AREA                6     2     -4      364480   364480        0
* CLIO_LNK_KEYS_MIXED           29    28    -1      482248   482248        0
CLNTS_DATA                      13    11    -2     3585960  3585960        0
CLNTS_SIDS                      15    14    -1     3649200  3649200        0
PMR_DATA                        49    48    -1     1140408  1140408        0
RDB$SYSTEM                      60    60    0        27550    27550        0
--------------------------------------------------------------------------------
Totals:                                           15406570 15454570    48000
Total number of storage areas: 14
Total number of alarms, excluding mixed areas: 10
Total number of mixed areas: 4

Storage areas added or removed:
--------------------------------------------------------------------------------
         Sarea                           Free%     Size
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_FREE_SPACE_DYN.COM</b><br>
  List size and free space evolution per available analysis date
  for a specific storage area from the RMU/Analyze reporting db
  since a start date.
</p>
 
  Usage:<br>

<pre>
$ @CPTRDB_ANA_FREE_SPACE_DYN {dbid} {sarea name} {start date}
</pre>

  Output sample:<br>

<pre>
Database:      DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB
Storage area:  CLIO_CLNTS_DATA
On node:       L15S50

Size and free space evolution
Starting from: 2015-01-01

At: 2015-04-02 12:18:06
--------------------------------------------------------------------------------
Date       Size       Free DiffSize   DiFr TotDifSize Said
--------------------------------------------------------------------------------
2015-01-05 1064232    17   0          0    0          14
2015-01-12 1064232    16   0          -1   0          14
2015-01-19 1064232    16   0          0    0          14
2015-01-26 1064232    16   0          0    0          14
2015-02-02 1064232    16   0          0    0          14
2015-02-09 1064232    16   0          0    0          14
2015-02-16 1088212    18   23980      2    23980      14
2015-02-23 1088212    18   0          0    23980      14
2015-03-02 1088212    18   0          0    23980      14
2015-03-09 1088212    17   0          -1   23980      14
2015-03-16 1088212    17   0          0    23980      14
2015-03-23 1088212    17   0          0    23980      14
2015-03-30 1088212    17   0          0    23980      14
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_FREE_SPACE_DYN_LAREA.COM</b><br>
  List size and free space evolution per available analysis date
  for a specific storage area from the RMU/Analyze reporting db.
  Show total space evolution and percentage of storage area size
  for a particular logical area, stored in this storage area,
  since a start date.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_FREE_SPACE_DYN_LAREA {dbid} {sarea name} {larea name} {start date}
</pre>

  Output sample:<br>

<pre>
Database:      DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB
Storage area:  CLIO_CLNTS_DATA
Logical area:  CLIO_CLNTS
On node:       L15S50

Size and free space evolution
Starting from: 2015-01-01

At: 2015-04-02 12:20:06
--------------------------------------------------------------------------------
Date           Size DiffSize Free DiFr LareSize LareDiff Lar% La%D SaId LaId
--------------------------------------------------------------------------------
2015-01-05  1064232        0   17    0   766971        0   72    0   14   79
2015-01-12  1064232        0   16   -1   767984     1013   72    0   14   79
2015-01-19  1064232        0   16    0   769095     1111   72    0   14   79
2015-01-26  1064232        0   16    0   770486     1391   72    0   14   79
2015-02-02  1064232        0   16    0   771686     1200   73    1   14   79
2015-02-09  1064232        0   16    0   772617      931   73    0   14   79
2015-02-16  1088212    23980   18    2   773559      942   71   -2   14   79
2015-02-23  1088212        0   18    0   774446      887   71    0   14   79
2015-03-02  1088212        0   18    0   775279      833   71    0   14   79
2015-03-09  1088212        0   17   -1   776119      840   71    0   14   79
2015-03-16  1088212        0   17    0   776892      773   71    0   14   79
2015-03-23  1088212        0   17    0   777620      728   71    0   14   79
2015-03-30  1088212        0   17    0   778319      699   72    1   14   79
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_ALL.COM</b><br>
  List counts for all partitions of all logical area names, order by logical 
  area name, on one analysis day from the RMU/Analyze reporting db.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_ALL {dbid} {ana date}
</pre>

  Output sample:<br>

<pre>
Database:         DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
All logical area names
On node:          L15S29

Cardinalities on: 2015-03-30

At: 2015-04-01 13:11:29
--------------------------------------------------------------------------------
LareaId Larea                               Count SareaId Sarea
--------------------------------------------------------------------------------
     12 DBA_MVIEWS                              0       2 DEFAULT_AREA
      2 ENCRYPT_TABLE                           1       2 DEFAULT_AREA
     65 JCCLML$HEARTBEAT                        1       2 DEFAULT_AREA
     66 LISTTAB                                 3       7 DATA_AREA_11
     15 ORA_COMM_TRANID                         1       2 DEFAULT_AREA
     14 ORA_COMM_TRANS                          0       2 DEFAULT_AREA
      3 ORA_OBJECTS                           233       2 DEFAULT_AREA
      4 ORA_OBJECTS_NAME                        3       2 DEFAULT_AREA
     16 ORA_VALID_PROGRAMS                      0       2 DEFAULT_AREA
     19 PRODUCT_PROFILE                         0       2 DEFAULT_AREA
      5 RECYCLEBIN                              0       2 DEFAULT_AREA
     20 ROLE_SYS_PRIVS                          0       2 DEFAULT_AREA
     21 ROLE_TAB_PRIVS                          0       2 DEFAULT_AREA
     10 SESSION_ROLES                           0       2 DEFAULT_AREA
     23 SNAP$                                   0       2 DEFAULT_AREA
     25 SQLSRV_EMPLOYEES                        5       2 DEFAULT_AREA
     26 SQLSRV_INSERT_TABLE                     5       2 DEFAULT_AREA
     11 SQL_CAPABILITY                          3       2 DEFAULT_AREA
     22 SYSTEM_PRIVILEGE_MAP                   32       2 DEFAULT_AREA
     60 TABLE_ALL_DATATYPES                     4       2 DEFAULT_AREA
     73 TABLE_PARTI                           501       7 DATA_AREA_11
     76 TABLE_PARTI                           501       8 DATA_AREA_12
     74 TABLE_PARTI                           500       9 DATA_AREA_21
     77 TABLE_PARTI                           500      10 DATA_AREA_22
     75 TABLE_PARTI                           500      11 DATA_AREA_31
     78 TABLE_PARTI                           500      12 DATA_AREA_32
     79 TABLE_PARTI_IDX                         6      13 INDEX_AREA_1
     80 TABLE_PARTI_IDX                         6      14 INDEX_AREA_2
     81 TABLE_PARTI_IDX                         6      15 INDEX_AREA_3
     70 TABLE_PLACE                           500       4 MIXED_AREA_1
     71 TABLE_PLACE                           500       5 MIXED_AREA_2
     72 TABLE_PLACE                           500       6 MIXED_AREA_3
     67 TABLE_PLACE_HDX                       461       4 MIXED_AREA_1
     68 TABLE_PLACE_HDX                       452       5 MIXED_AREA_2
     69 TABLE_PLACE_HDX                       459       6 MIXED_AREA_3
      9 TOOL_MODULE                             0       2 DEFAULT_AREA
      7 USER$                                   4       2 DEFAULT_AREA
      8 USER$_NAME                              1       2 DEFAULT_AREA
     18 USER_ROLE_PRIVS                         0       2 DEFAULT_AREA
     17 USER_SYS_PRIVS                          0       2 DEFAULT_AREA
     13 USER_TABLESPACES                        1       2 DEFAULT_AREA
      6 V$OPTION                                0       2 DEFAULT_AREA
     31 WAITING_FOR_CNTS                       12      16 STALL_CNTS_AREA
     24 WAITING_FOR_CNTS_IDX                    1      16 STALL_CNTS_AREA
     32 WAITING_FOR_DDLCKS                      0      16 STALL_CNTS_AREA
     27 WAITING_FOR_DDLCKS_IDX                  1      16 STALL_CNTS_AREA
     33 WAITING_FOR_TIMES                      12      16 STALL_CNTS_AREA
     28 WAITING_FOR_TIMES_IDX                   1      16 STALL_CNTS_AREA
--------------------------------------------------------------------------------
                                             6216 Total count
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_CONTAINING.COM</b><br>
  List counts for all partitions of all logical area names CONTAINING
  on one analysis day from the RMU/Analyze reporting db.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_CONTAINING {dbid} {larea name cont} {ana date}
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_DYN.COM</b><br>
  List per partition (fragmented) row count evolution per available
  analysis date for a specific logical area name, from the RMU/Analyze
  reporting database, since a start date.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_DYN {dbid} {larea name} {start date}
</pre>

  Output sample:<br>

<pre>
Database:          DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:           L15S29

Logical area name: TABLE_PARTI
Per partition (fragmented) row count evolution
Since:             2015-03-23

At: 2015-04-02 13:08:37
--------------------------------------------------------------------------------
Date        TotalCnt      Diff   FragCnt  FragDiff Sarea                           SaId LaId
--------------------------------------------------------------------------------
2015-03-23       501         0         0         0 DATA_AREA_11                       7   73
2015-03-23       501         0         0         0 DATA_AREA_12                       8   76
2015-03-23       500         0         0         0 DATA_AREA_21                       9   74
2015-03-23       500         0         0         0 DATA_AREA_22                      10   77
2015-03-23       500         0         0         0 DATA_AREA_31                      11   75
2015-03-23       500         0         0         0 DATA_AREA_32                      12   78
Totals:         3002         0         0         0

2015-03-30       501         0         0         0 DATA_AREA_11                       7   73
2015-03-30       501         0         0         0 DATA_AREA_12                       8   76
2015-03-30       500         0         0         0 DATA_AREA_21                       9   74
2015-03-30       500         0         0         0 DATA_AREA_22                      10   77
2015-03-30       500         0         0         0 DATA_AREA_31                      11   75
2015-03-30       500         0         0         0 DATA_AREA_32                      12   78
Totals:         3002         0         0         0

2015-04-02       251      -250         0         0 DATA_AREA_11                       7   73
2015-04-02       251      -250         0         0 DATA_AREA_12                       8   76
2015-04-02       250      -250         0         0 DATA_AREA_21                       9   74
2015-04-02       250      -250         0         0 DATA_AREA_22                      10   77
2015-04-02       250      -250         0         0 DATA_AREA_31                      11   75
2015-04-02       250      -250         0         0 DATA_AREA_32                      12   78
Totals:         1502     -1500         0         0

--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_ONE.COM</b><br>
  List counts for all partitions of one logical area name on one analysis day
  from the RMU/Analyze reporting db.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_ONE {dbid} {larea name} {ana date}
</pre>

  Output sample:<br>

<pre>
Database:          DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
Logical area name: TABLE_PARTI
On node:           L15S29

Cardinalities on:  2015-04-02

At: 2015-04-02 13:13:41
--------------------------------------------------------------------------------
LareaId     Count SareaId Sarea
--------------------------------------------------------------------------------
     73       251       7 DATA_AREA_11
     76       251       8 DATA_AREA_12
     74       250       9 DATA_AREA_21
     77       250      10 DATA_AREA_22
     75       250      11 DATA_AREA_31
     78       250      12 DATA_AREA_32
--------------------------------------------------------------------------------
             1502 Total count
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_RDB$.COM</b><br>
  List counts for all partitions of all logical area names starting with RDB$
  on one analysis day from the RMU/Analyze reporting db.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_RDB$ {dbid} {ana date}
</pre>

<p>
<b>CPTRDB_ANA_LAREA_COUNTS_STARTING.COM</b><br>
  List counts for all partitions of all logical area names STARTING WITH
  on one analysis day from the RMU/Analyze reporting db.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_COUNTS_STARTING {dbid} {larea name start} {ana date}
</pre>

<p>
<b>CPTRDB_ANA_LAREA_ID.COM</b><br>
  List a logical area id, the content counts of it's storage area and
  related partitions on one analysis day from the RMU/Analyze 
  reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_LAREA_ID {dbid} {larea id} {ana date}
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On:       2015-03-30

Storage area contents and related partitions
For logical area id: 71

At: 2015-04-01 15:05:33
--------------------------------------------------------------------------------
 LaId Larea                                Count  SaId Sarea
--------------------------------------------------------------------------------
   71 TABLE_PLACE                            500     5 MIXED_AREA_2
   63 RDB$SYSTEM_RECORD                        0     5 MIXED_AREA_2
   68 TABLE_PLACE_HDX                        452     5 MIXED_AREA_2
--------------------------------------------------------------------------------
   70 TABLE_PLACE                            500     4 MIXED_AREA_1
   72 TABLE_PLACE                            500     6 MIXED_AREA_3
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_PAGE_SIZE_ALL.COM</b><br>
  List the page size for all storage area names on one analysis day 
  from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_PAGE_SIZE_ALL {dbid} {ana date}
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On:       2015-04-02

Page size (blocks)
For all storage areas

At: 2015-04-02 15:03:51
--------------------------------------------------------------------------------
 SaId Sarea                            PSiz
--------------------------------------------------------------------------------
    7 DATA_AREA_11                        4
    8 DATA_AREA_12                        4
    9 DATA_AREA_21                        4
   10 DATA_AREA_22                        4
   11 DATA_AREA_31                        4
   12 DATA_AREA_32                        4
    2 DEFAULT_AREA                        4
   13 INDEX_AREA_1                        4
   14 INDEX_AREA_2                        4
   15 INDEX_AREA_3                        4
    3 LISTS_AREA                          4
    4 MIXED_AREA_1                        4
    5 MIXED_AREA_2                        4
    6 MIXED_AREA_3                        4
    1 RDB$SYSTEM                          4
   16 STALL_CNTS_AREA                     4
--------------------------------------------------------------------------------
Total number of storage areas: 16
</pre>

<p>
<b>CPTRDB_ANA_PAGE_SIZE_CONT.COM</b><br>
  List the page size for all storage area names CONTAINING 
  on one analysis day from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_PAGE_SIZE_CONT {dbid} {sarea name cont} {ana date}
</pre>

<p>
<b>CPTRDB_ANA_PAGE_SIZE_START.COM</b><br>
  List the page size for all storage area names STARTING WITH 
  on one analysis day from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_PAGE_SIZE_START {dbid} {sarea name start} {ana date}
</pre>

<p>
<b>CPTRDB_ANA_SAREA_ID.COM</b><br>
  List a storage area id, it's contents and related partitions
  on one analysis day from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_SAREA_ID {dbid} {sarea id} {ana date}
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On:       2015-04-02

Storage area contents and related partitions
For storage area id: 11

At: 2015-04-02 15:08:29
--------------------------------------------------------------------------------
 LaId Larea                                Count  SaId Sarea
--------------------------------------------------------------------------------
   75 TABLE_PARTI                            250    11 DATA_AREA_31
--------------------------------------------------------------------------------
   73 TABLE_PARTI                            251     7 DATA_AREA_11
   76 TABLE_PARTI                            251     8 DATA_AREA_12
   74 TABLE_PARTI                            250     9 DATA_AREA_21
   77 TABLE_PARTI                            250    10 DATA_AREA_22
   78 TABLE_PARTI                            250    12 DATA_AREA_32
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_SAREA_NAME.COM</b><br>
  List a storage area name, it's contents and related partitions
  on one analysis day from the RMU/Analyze reporting database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_SAREA_NAME {dbid} {sarea name} {ana date}
</pre>

  Output sample:<br>

<pre>
Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB
On node:  L15S29
On:       2015-03-30

Storage area contents and related partitions
For storage area name: DATA_AREA_22

At: 2015-04-01 15:10:42
--------------------------------------------------------------------------------
 LaId Larea                                Count  SaId Sarea
--------------------------------------------------------------------------------
   77 TABLE_PARTI                            500    10 DATA_AREA_22
--------------------------------------------------------------------------------
   73 TABLE_PARTI                            501     7 DATA_AREA_11
   76 TABLE_PARTI                            501     8 DATA_AREA_12
   74 TABLE_PARTI                            500     9 DATA_AREA_21
   75 TABLE_PARTI                            500    11 DATA_AREA_31
   78 TABLE_PARTI                            500    12 DATA_AREA_32
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_ANA_SAREA_NAME_SIZES.COM</b><br>
  List content count, size and % size for a storage area name,
  on one analysis day from the RMU/Analyze reporting database,
  ordered by logical area size descending.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_ANA_SAREA_NAME_SIZES {dbid} {sarea name} {ana date}
</pre>

  Output sample for a mixed page format storage area:<br>

<pre>
Database: DISK$DATA_23:[SBN_DB]SABIN_TT.RDB
On node:  L15S50
On:       2015-03-16

Content count, size (blocks desc) and % size per logical area name
For storage area: SEASN_TKT_DATA

At: 2015-03-18 10:44:33
--------------------------------------------------------------------------------
SaId LaId                                    Count     Size  %Size
--------------------------------------------------------------------------------
   8 SEASN_TKT_DATA                                 4740438
     Free                                           1059416  22.35
     Overhead                                        726899  15.33
--------------------------------------------------------------------------------
       83 SEASN_TKT_PRSN                   3947296   746055  15.74
       75 SEASN_TKT                        3872656   612666  12.92
      184 SEASN_TKT_MISC                   3599745   307260   6.48
       88 SIMPLE_SEASN_TKT                 3753192   227244   4.79
       82 SEASN_TKT_PRSN_HDX                862627   218982   4.62
       74 SEASN_TKT_HDX                     845439   214822   4.53
       87 SIMPLE_SEASN_TKT_HDX              879298   209483   4.42
      183 SEASN_TKT_MISC_HDX                900551   202147   4.26
       91 TRAIN_RTE_RQSTD                  1025769    98169   2.07
       56 RDB$SYSTEM_RECORD                      0    73371   1.55
       90 TRAIN_RTE_RQSTD_HDX               744818    68092   1.44
       59 BUS_RTE_SLCTD_HDX                 230894     7396   0.16
       93 TRAIN_RTE_SLCTD_HDX               230648     7390   0.16
       64 CMPLX_SEASN_TKT_HDX               230004     7388   0.16
      154 BUS_RTE_RQSTD_HDX                 224738     7088   0.15
       60 BUS_RTE_SLCTD                      47952     5871   0.12
       65 CMPLX_SEASN_TKT                    48182     4893   0.10
       94 TRAIN_RTE_SLCTD                    47952     4589   0.10
      155 BUS_RTE_RQSTD                      44503     4577   0.10
       79 SEASN_TKT_CMPNY                       20        5   0.00
       78 SEASN_TKT_CMPNY_HDX                  115        3   0.00
--------------------------------------------------------------------------------
                                  Totals: 21536399  3027491  63.87
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 37"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 37 -- List Database Objects
</font>
</h3>

<b>CPTRDB_SHOW_STORAGE_AREAS.COM</b><br>
<b>CPTRDB_SHOW_DOMAINS.COM</b><br>
<b>CPTRDB_SHOW_TABLES.COM</b><br>
<b>CPTRDB_SHOW_INDICES.COM</b><br>
<b>CPTRDB_SHOW_USERS.COM</b><br>
<b>CPTRDB_SHOW_THIN_CLIENTS.COM</b><br>
<b>CPTRDB_SHOW_THIN_CLIENTS_BATCH.COM</b><br>
<b>CPTRDB_SHOW_TSN_BLKS.COM</b><br>
<b>CPTRDB_SHOW_AREAS_IDS.COM</b><br>
<b>CPTRDB_SHOW_ONE_PAGE.COM</b><br>
<b>CPTRDB_SHOW_ONE_LOGICAL_AREA.COM</b><br>
<b>CPTRDB_SHOW_ONE_STORAGE_AREA.COM</b><br>
<b>CPTRDB_SHOW_ONE_RECORD_TYPE.COM</b><br>
<b>CPTRDB_SHOW_ONE_INDEX_SET.COM</b><br>
<b>CPTRDB_SHOW_ONE_HASH_INDEX.COM</b><br>
<b>CPTRDB_SHOW_ONE_STORAGE_MAP.COM</b><br>
<b>CPTRDB_EXTRACT_ONE_OBJECT.COM</b><br>
<b>CPTRDB_SHOW_TABLE_METADATA.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
All procedures in this chapter have a interactive usage mode and use the 
current Rdb version on the executor node.

The CPTRDB_SHOW_ONE* procedures can be used to list database objects mentioned
in stall logs or the output of CPTRDB_SHOW_ONE_PAGE.COM, and
display related information from the system tables.

The CPTRDB_SHOW_TABLES.COM and CPTRDB_SHOW_INDICES.COM procedures output
can be used in a basic metadata comparison of two databases with
a simple dcl 
</p>

<pre>
$ DIFFERENCES {output1} {output2}
</pre>

<p>
<b>CPTRDB_SHOW_STORAGE_AREAS.COM</b><br>
  List size, format, page size and extents settings for all storage areas
  of a single database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_STORAGE_AREAS {dbid}
</pre>

  Output sample:<br>

<pre>
Storage areas sizes for database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On node L15S29
At 2015-04-02 15:20:22
--------------------------------------------------------------------------------
Root                              288|DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
--------------------------------------------------------------------------------
Data areas
--------------------------------------------------------------------------------
  7|DATA_AREA_11   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.RDA;1
  8|DATA_AREA_12   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.RDA;1
  9|DATA_AREA_21   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.RDA;1
 10|DATA_AREA_22   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.RDA;1
 11|DATA_AREA_31   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.RDA;1
 12|DATA_AREA_32   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.RDA;1
  2|DEFAULT_AREA   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.RDA;1
 13|INDEX_AREA_1   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.RDA;1
 14|INDEX_AREA_2   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.RDA;1
 15|INDEX_AREA_3   |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.RDA;1
  3|LISTS_AREA     |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.RDA;1
  4|MIXED_AREA_1   |Mixed  |    12056|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.RDA;1
  5|MIXED_AREA_2   |Mixed  |    12056|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.RDA;1
  6|MIXED_AREA_3   |Mixed  |    12056|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.RDA;1
  1|RDB$SYSTEM     |Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.RDA;1
 16|STALL_CNTS_AREA|Uniform|    12004|DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.RDA;1
--------------------------------------------------------------------------------
                               192220 Total size of data areas
                                   16 Total number of data areas
--------------------------------------------------------------------------------
Snapshot areas
--------------------------------------------------------------------------------
 28|DATA_AREA_11   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_11.SNP;1
 29|DATA_AREA_12   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_12.SNP;1
 30|DATA_AREA_21   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_21.SNP;1
 31|DATA_AREA_22   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.SNP;1
 32|DATA_AREA_31   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_31.SNP;1
 33|DATA_AREA_32   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_32.SNP;1
 23|DEFAULT_AREA   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]DEFAULT_AREA.SNP;1
 34|INDEX_AREA_1   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_1.SNP;1
 35|INDEX_AREA_2   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_2.SNP;1
 36|INDEX_AREA_3   |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]INDEX_AREA_3.SNP;1
 24|LISTS_AREA     |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.SNP;1
 25|MIXED_AREA_1   |Mixed  |    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_1.SNP;1
 26|MIXED_AREA_2   |Mixed  |    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_2.SNP;1
 27|MIXED_AREA_3   |Mixed  |    12000|DISK$DATA_29:[CPTRDB_DB_1]MIXED_AREA_3.SNP;1
 22|RDB$SYSTEM     |Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]RDB_SYSTEM.SNP;1
 37|STALL_CNTS_AREA|Uniform|    12000|DISK$DATA_29:[CPTRDB_DB_1]STALL_CNTS_AREA.SNP;1
--------------------------------------------------------------------------------
                               192000 Total size of snapshot areas
                                   16 Total number of snapshot areas
                               384508 Total size of database
--------------------------------------------------------------------------------
Extents, Buffer size 24
                           RDA Pages   %    SNP Pages   %    RDA Blocks      SNP Blocks
--------------------------------------------------------------------------------
DATA_AREA_11   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DATA_AREA_12   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DATA_AREA_21   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DATA_AREA_22   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DATA_AREA_31   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DATA_AREA_32   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
DEFAULT_AREA   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
INDEX_AREA_1   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
INDEX_AREA_2   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
INDEX_AREA_3   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
LISTS_AREA     | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
MIXED_AREA_1   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
MIXED_AREA_2   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
MIXED_AREA_3   | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
RDB$SYSTEM     | 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
STALL_CNTS_AREA| 4| 1988| | 3000| 6000|20| | 3000| 3000|20| | 12000| 24000| | 12000| 12000
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_DOMAINS.COM</b><br>
List all domains and their usage for a single database
</p>

<p>
Domain names referenced in procedures and declared temporary tables are listed
in separate sections after the 'ordinary' tables. Domains without any reference
in tables are marked "*Not Used*".
</p>

<p>
Usage:
</p>

<pre>
$ CPTRDB_SHOW_DOMAINS {dbid}
</pre>

<p>
Output sample:
</p>

<pre>
All Domains And Their Usage For Database:
DSA23:[SSP_DB_VDD]SSP_DB.RDB;1
On Node: L15S29
At:      2018-04-18 15:28:18
--------------------------------------------------------------------------------
Domain|Table|Position|Column
--------------------------------------------------------------------------------
ABRT_CD|CZAM_ABRT|1|ABRT_CD

ACCESS_CONTROL_IDENT|R_ACCESS|3|ACCESS_CONTROL_IDENT

ACCESS_CONTROL_PRIVS|R_ACCESS|4|ACCESS_CONTROL_PRIVS

ACCESS_CONTROL_TYPE|R_ACCESS|2|ACCESS_CONTROL_TYPE

ACCOMMODATION_TYPE|R_EXCHANGE_RATE|6|ACCOMMODATION_TYPE

ACCOUNT_ORG_ID|PROD_COMP|7|ACCOUNT_ORG_ID

ACCOUNT_RCVR_WSTATN_ID|ACCT_UNIT|18|ACCOUNT_RCVR_WSTATN_ID
ACCOUNT_RCVR_WSTATN_ID|ACCT_UNIT_DNR|18|ACCOUNT_RCVR_WSTATN_ID

ACCTUNIT_WAREHOUSE|ACCT_UNIT|15|ACCTUNIT_WAREHOUSE
ACCTUNIT_WAREHOUSE|ACCT_UNIT_DNR|15|ACCTUNIT_WAREHOUSE

ACCT_UNIT_ID|ACCT_UNIT|1|ACCT_UNIT_ID
ACCT_UNIT_ID|ACCT_UNIT_DNR|1|ACCT_UNIT_ID
ACCT_UNIT_ID|BADGE|15|ACCT_UNIT_ID
ACCT_UNIT_ID|CASH_BADGE|2|ACCT_UNIT_ID
ACCT_UNIT_ID|CASH_DESK|1|ACCT_UNIT_ID
ACCT_UNIT_ID|WORK_UNIT|4|ACCT_UNIT_ID
ACCT_UNIT_ID|WORK_UNIT|22|CNTRL_ACCT_UNIT
ACCT_UNIT_ID|WORK_UNIT_DNR|4|ACCT_UNIT_ID
ACCT_UNIT_ID|WORK_UNIT_DNR|22|CNTRL_ACCT_UNIT

ACTVTN_NAME|ENTITY_AUTHZN|5|ACTVTN_NAME

ACTVTY_ID|ACTVTY_NEW|1|ACTVTY_ID
ACTVTY_ID|DMQ_Q_CONT|2|ACTVTY_ID
ACTVTY_ID|NODE_ACTVTY|2|ACTVTY_ID

ACTVTY_INSTNCE_ID|NODE_ACTVTY|5|ACTVTY_INSTNCE_ID

ACTVTY_NEW_ID|*Not Used*

AC_FROM|AGE_CTGRY|4|AC_FROM
AC_FROM|SEFORA_AGE_CTGRY|4|AC_FROM

AC_TO|AGE_CTGRY|5|AC_TO
AC_TO|SEFORA_AGE_CTGRY|5|AC_TO

...

ZONE_ID|NETW_PT|6|ZONE_ID
ZONE_ID|ZONE_T|1|ZONE_ID

ZONE_TSTATN|CITY_NET|17|ZONE_TSTATN
ZONE_TSTATN|TRAINSTATIONS|5|ZONE_TSTATN
ZONE_TSTATN|TSTATN|11|ZONE_TSTATN

ZONE_TSTATN_ID|R_TSTATN|7|ZONE_TSTATN_ID

--------------------------------------------------------------------------------
Domain|Module.Routine|Position|Parameter
--------------------------------------------------------------------------------
STKT_CTGRY_ID|STKT_CTGRY_MODULE.DISPL_STKT_CTGRY|1|STKT_CTGRY_ID

STRING_DTYPE|GET_DCL_DATA.GET_DCL_SYMBOL|0|
STRING_DTYPE|LIB$GET_SYMBOL|2|RESULTANT_STRING
STRING_DTYPE|LIB$SET_SYMBOL|2|VALUE_STRING

SYMBOL_DTYPE|GET_DCL_DATA.GET_DCL_SYMBOL|1|SYMBOL_NAME
SYMBOL_DTYPE|LIB$GET_SYMBOL|1|SYMBOL
SYMBOL_DTYPE|LIB$SET_SYMBOL|1|SYMBOL

--------------------------------------------------------------------------------
Domain|Module|Temporary Table
--------------------------------------------------------------------------------
PRICE_CD|XFERS_LISA_MODULE|PC_LISA
PC_VRSN|XFERS_LISA_MODULE|PC_LISA
ORGNSM_ID|XFERS_LISA_MODULE|ORGNSM_LISA
OR_VRSN|XFERS_LISA_MODULE|ORGNSM_LISA
TSTATN_ID|KEYCARD_REPORT|KEYCARD_TSTATN
TSTATN_ID|KEYCARD_REPORT|KEYCARD_ZONE
TSTATN_ID|KEYCARD_REPORT|KEYCARD_DSTNC
TSTATN_INTER_DSTNC|KEYCARD_REPORT|KEYCARD_DSTNC
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_TABLES.COM</b><br>
  List all tables, their columns and datatypes for a single database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_TABLES {dbid}
</pre>

  Output sample:<br>

<pre>
Tables And Their Columns/Datatypes For Database:
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node: L15S29
At: 2018-10-04 12:12:57
--------------------------------------------------------------------------------
ALL_DATATYPES                  ,1  ,TINYINT_NOSCALE                ,TINYINT
ALL_DATATYPES                  ,2  ,SMALLINT_NOSCALE               ,SMALLINT
ALL_DATATYPES                  ,3  ,INTEGER_NOSCALE                ,INTEGER
ALL_DATATYPES                  ,4  ,BIGINT_NOSCALE                 ,BIGINT
ALL_DATATYPES                  ,5  ,TINYINT_SCALE                  ,TINYINT(2)
ALL_DATATYPES                  ,6  ,SMALLINT_SCALE                 ,SMALLINT(2)
ALL_DATATYPES                  ,7  ,INTEGER_SCALE                  ,INTEGER(2)
ALL_DATATYPES                  ,8  ,BIGINT_SCALE                   ,BIGINT(2)
ALL_DATATYPES                  ,9  ,FLOAT_NOSCALE                  ,DOUBLE PRECISION
ALL_DATATYPES                  ,10 ,FLOAT_24                       ,REAL
ALL_DATATYPES                  ,11 ,FLOAT_53                       ,DOUBLE PRECISION
ALL_DATATYPES                  ,12 ,REAL_NOSCALE                   ,REAL
ALL_DATATYPES                  ,13 ,DOUBLE_PRECISION               ,DOUBLE PRECISION
ALL_DATATYPES                  ,14 ,DECIMAL_NOSCALE                ,INTEGER
ALL_DATATYPES                  ,15 ,DECIMAL_4                      ,SMALLINT
ALL_DATATYPES                  ,16 ,DECIMAL_9                      ,INTEGER
ALL_DATATYPES                  ,17 ,DECIMAL_18                     ,BIGINT
ALL_DATATYPES                  ,18 ,DECIMAL_19                     ,DOUBLE PRECISION
ALL_DATATYPES                  ,19 ,DECIMAL_4_SCALE                ,SMALLINT(2)
ALL_DATATYPES                  ,20 ,DECIMAL_9_SCALE                ,INTEGER(2)
ALL_DATATYPES                  ,21 ,DECIMAL_18_SCALE               ,BIGINT(2)
ALL_DATATYPES                  ,22 ,DECIMAL_19_SCALE               ,DOUBLE PRECISION
ALL_DATATYPES                  ,23 ,NUMERIC_NOSCALE                ,INTEGER
ALL_DATATYPES                  ,24 ,NUMERIC_4                      ,SMALLINT
ALL_DATATYPES                  ,25 ,NUMERIC_9                      ,INTEGER
ALL_DATATYPES                  ,26 ,NUMERIC_18                     ,BIGINT
ALL_DATATYPES                  ,27 ,NUMERIC_19                     ,DOUBLE PRECISION
ALL_DATATYPES                  ,28 ,NUMERIC_4_SCALE                ,SMALLINT(2)
ALL_DATATYPES                  ,29 ,NUMERIC_9_SCALE                ,INTEGER(2)
ALL_DATATYPES                  ,30 ,NUMERIC_18_SCALE               ,BIGINT(2)
ALL_DATATYPES                  ,31 ,NUMERIC_19_SCALE               ,DOUBLE PRECISION
ALL_DATATYPES                  ,32 ,NUMBER_NOSCALE                 ,DOUBLE PRECISION
ALL_DATATYPES                  ,33 ,NUMBER_2                       ,TINYINT
ALL_DATATYPES                  ,34 ,NUMBER_4                       ,SMALLINT
ALL_DATATYPES                  ,35 ,NUMBER_9                       ,INTEGER
ALL_DATATYPES                  ,36 ,NUMBER_18                      ,BIGINT
ALL_DATATYPES                  ,37 ,NUMBER_19                      ,DOUBLE PRECISION
ALL_DATATYPES                  ,38 ,NUMBER_2_SCALE                 ,TINYINT(2)
ALL_DATATYPES                  ,39 ,NUMBER_4_SCALE                 ,SMALLINT(2)
ALL_DATATYPES                  ,40 ,NUMBER_9_SCALE                 ,INTEGER(2)
ALL_DATATYPES                  ,41 ,NUMBER_18_SCALE                ,BIGINT(2)
ALL_DATATYPES                  ,42 ,NUMBER_19_SCALE                ,DOUBLE PRECISION
ALL_DATATYPES                  ,43 ,NUMBER_2_NEGSCALE              ,TINYINT(-2)
ALL_DATATYPES                  ,44 ,NUMBER_4_NEGSCALE              ,SMALLINT(-2)
ALL_DATATYPES                  ,45 ,NUMBER_9_NEGSCALE              ,INTEGER(-2)
ALL_DATATYPES                  ,46 ,NUMBER_18_NEGSCALE             ,BIGINT(-2)
ALL_DATATYPES                  ,47 ,NUMBER_19_NEGSCALE             ,DOUBLE PRECISION
ALL_DATATYPES                  ,48 ,NUMBER_STAR                    ,BIGINT
ALL_DATATYPES                  ,49 ,NUMBER_STAR_SCALE              ,BIGINT(2)
ALL_DATATYPES                  ,50 ,NUMBER_STAR_NEGSCALE           ,BIGINT(-2)
ALL_DATATYPES                  ,51 ,CHAR_1                         ,CHAR(1)
ALL_DATATYPES                  ,52 ,CHARACTER_1                    ,CHAR(1)
ALL_DATATYPES                  ,53 ,CHAR_20                        ,CHAR(20)
ALL_DATATYPES                  ,54 ,CHARACTER_20                   ,CHAR(20)
ALL_DATATYPES                  ,55 ,CHAR_1_MCS                     ,CHAR(1)
ALL_DATATYPES                  ,56 ,CHARACTER_1_MCS                ,CHAR(1)
ALL_DATATYPES                  ,57 ,CHAR_20_MCS                    ,CHAR(20)
ALL_DATATYPES                  ,58 ,CHARACTER_20_MCS               ,CHAR(20)
ALL_DATATYPES                  ,59 ,CHAR_VARYING                   ,VARCHAR(1)
ALL_DATATYPES                  ,60 ,CHARACTER_VARYING              ,VARCHAR(1)
ALL_DATATYPES                  ,61 ,CHAR_VARYING_20                ,VARCHAR(20)
ALL_DATATYPES                  ,62 ,CHARACTER_VARYING_20           ,VARCHAR(20)
ALL_DATATYPES                  ,63 ,CHAR_VARYING_MCS               ,VARCHAR(1)
ALL_DATATYPES                  ,64 ,CHARACTER_VARYING_MCS          ,VARCHAR(1)
ALL_DATATYPES                  ,65 ,CHAR_VARYING_20_MCS            ,VARCHAR(20)
ALL_DATATYPES                  ,66 ,CHARACTER_VARYING_20_MCS       ,VARCHAR(20)
ALL_DATATYPES                  ,67 ,VARCHAR_20                     ,VARCHAR(20)
ALL_DATATYPES                  ,68 ,VARCHAR2_20                    ,VARCHAR(20)
ALL_DATATYPES                  ,69 ,VARCHAR_20_MCS                 ,VARCHAR(20)
ALL_DATATYPES                  ,70 ,VARCHAR2_20_MCS                ,VARCHAR(20)
ALL_DATATYPES                  ,71 ,LONG_VARCHAR                   ,VARCHAR(16383)
ALL_DATATYPES                  ,72 ,RAW_20                         ,VARCHAR(20) UNSPECIFIED
ALL_DATATYPES                  ,73 ,NCHAR1                         ,CHAR(1)
ALL_DATATYPES                  ,74 ,NATIONAL_CHAR                  ,CHAR(1)
ALL_DATATYPES                  ,75 ,NATIONAL_CHARACTER             ,CHAR(1)
ALL_DATATYPES                  ,76 ,NCHAR_20                       ,CHAR(20)
ALL_DATATYPES                  ,77 ,NATIONAL_CHAR_20               ,CHAR(20)
ALL_DATATYPES                  ,78 ,NATIONAL_CHARACTER_20          ,CHAR(20)
ALL_DATATYPES                  ,79 ,NCHAR_VARYING                  ,VARCHAR(1)
ALL_DATATYPES                  ,80 ,NATIONAL_CHAR_VARYING          ,VARCHAR(1)
ALL_DATATYPES                  ,81 ,NATIONAL_CHARACTER_VARYING     ,VARCHAR(1)
ALL_DATATYPES                  ,82 ,NCHAR_VARYING_20               ,VARCHAR(20)
ALL_DATATYPES                  ,83 ,NATIONAL_CHAR_VARYING_20       ,VARCHAR(20)
ALL_DATATYPES                  ,84 ,NATIONAL_CHARACTER_VARYING_20  ,VARCHAR(20)
ALL_DATATYPES                  ,85 ,DATE_VMS                       ,DATE VMS
ALL_DATATYPES                  ,86 ,DATE_ANSI                      ,DATE ANSI
ALL_DATATYPES                  ,87 ,TIME_NOFRAC                    ,TIME(0)
ALL_DATATYPES                  ,88 ,TIME_FRAC                      ,TIME(2)
ALL_DATATYPES                  ,89 ,TIMESTAMP_NOFRAC               ,TIMESTAMP(0)
ALL_DATATYPES                  ,90 ,TIMESTAMP_FRAC                 ,TIMESTAMP(2)
ALL_DATATYPES                  ,91 ,INTRVL_YEAR_NP                 ,INTERVAL YEAR(2)
ALL_DATATYPES                  ,92 ,INTRVL_YEAR_P                  ,INTERVAL YEAR(3)
ALL_DATATYPES                  ,93 ,INTRVL_Y2M_NP                  ,INTERVAL YEAR(2) TO MONTH
ALL_DATATYPES                  ,94 ,INTRVL_Y2M_P                   ,INTERVAL YEAR(3) TO MONTH
ALL_DATATYPES                  ,95 ,INTRVL_M_NP                    ,INTERVAL MONTH(2)
ALL_DATATYPES                  ,96 ,INTRVL_M_P                     ,INTERVAL MONTH(3)
ALL_DATATYPES                  ,97 ,INTRVL_D_NP                    ,INTERVAL DAY(2)
ALL_DATATYPES                  ,98 ,INTRVL_D_P                     ,INTERVAL DAY(3)
ALL_DATATYPES                  ,99 ,INTRVL_D2H_NP                  ,INTERVAL DAY(2) TO HOUR
ALL_DATATYPES                  ,100,INTRVL_D2H_P                   ,INTERVAL DAY(4) TO HOUR
ALL_DATATYPES                  ,101,INTRVL_D2M_NP                  ,INTERVAL DAY(2) TO MINUTE
ALL_DATATYPES                  ,102,INTRVL_D2M_P                   ,INTERVAL DAY(4) TO MINUTE
ALL_DATATYPES                  ,103,INTRVL_D2S_NP_NF               ,INTERVAL DAY(2) TO SECOND(0)
ALL_DATATYPES                  ,104,INTRVL_D2S_NP_F                ,INTERVAL DAY(2) TO SECOND(2)
ALL_DATATYPES                  ,105,INTRVL_D2S_P_NF                ,INTERVAL DAY(4) TO SECOND(0)
ALL_DATATYPES                  ,106,INTRVL_D2S_P_F                 ,INTERVAL DAY(4) TO SECOND(2)
ALL_DATATYPES                  ,107,INTRVL_H_NP                    ,INTERVAL HOUR(2)
ALL_DATATYPES                  ,108,INTRVL_H_P                     ,INTERVAL HOUR(4)
ALL_DATATYPES                  ,109,INTRVL_H2M_NP                  ,INTERVAL HOUR(2) TO MINUTE
ALL_DATATYPES                  ,110,INTRVL_H2M_P                   ,INTERVAL HOUR(4) TO MINUTE
ALL_DATATYPES                  ,111,INTRVL_H2S_NP_NF               ,INTERVAL HOUR(2) TO SECOND(0)
ALL_DATATYPES                  ,112,INTRVL_H2S_NP_F                ,INTERVAL HOUR(2) TO SECOND(2)
ALL_DATATYPES                  ,113,INTRVL_H2S_P_NF                ,INTERVAL HOUR(4) TO SECOND(0)
ALL_DATATYPES                  ,114,INTRVL_H2S_P_F                 ,INTERVAL HOUR(4) TO SECOND(2)
ALL_DATATYPES                  ,115,INTRVL_MIN_NP                  ,INTERVAL MINUTE(2)
ALL_DATATYPES                  ,116,INTRVL_MIN_P                   ,INTERVAL MINUTE(4)
ALL_DATATYPES                  ,117,INTRVL_MIN2S_NP_NF             ,INTERVAL MINUTE(2) TO SECOND(0)
ALL_DATATYPES                  ,118,INTRVL_MIN2S_NP_F              ,INTERVAL MINUTE(2) TO SECOND(2)
ALL_DATATYPES                  ,119,INTRVL_MIN2S_P_NF              ,INTERVAL MINUTE(4) TO SECOND(0)
ALL_DATATYPES                  ,120,INTRVL_MIN2S_P_F               ,INTERVAL MINUTE(4) TO SECOND(2)
ALL_DATATYPES                  ,121,INTRVL_S_NP_NF                 ,INTERVAL SECOND(2,0)
ALL_DATATYPES                  ,122,INTRVL_S_NP_F                  ,INTERVAL SECOND(2,2)
ALL_DATATYPES                  ,123,INTRVL_S_P_NF                  ,INTERVAL SECOND(4,0)
ALL_DATATYPES                  ,124,INTRVL_S_P_F                   ,INTERVAL SECOND(4,2)
ALL_DATATYPES                  ,125,LIST_OF_BYTE_TEXT              ,LIST OF BYTE VARYING AS TEXT
ALL_DATATYPES                  ,126,LIST_OF_BYTE_BIN               ,LIST OF BYTE VARYING AS BINARY
ALL_DATATYPES                  ,127,LONG_COL                       ,LIST OF BYTE VARYING AS TEXT
ALL_DATATYPES                  ,128,LONG_RAW                       ,LIST OF BYTE VARYING AS BINARY
ALL_DATATYPES                  ,129,BIN_1                          ,BINARY(1)
ALL_DATATYPES                  ,130,BIN_VAR_4                      ,VARBINARY(4)

ENCRYPT_TABLE                  ,1  ,CIPHER_TEXT                    ,VARCHAR(24)
ENCRYPT_TABLE                  ,2  ,CIPHER_TEXT_HEX                ,VARCHAR(48)

JCCLML$HEARTBEAT               ,1  ,JCCLML$TIMESTAMP               ,DATE VMS

LISTTAB                        ,1  ,COL1                           ,INTEGER
LISTTAB                        ,2  ,LISTCOL                        ,LIST OF BYTE VARYING AS TEXT

SQLSRV_EMPLOYEES               ,1  ,EMPLOYEE_ID                    ,CHAR(5)

SQLSRV_INSERT_TABLE            ,1  ,FIELD1                         ,CHAR(20)

STALL_RW_CNTS                  ,1  ,STALL_DATE                     ,CHAR(10)
STALL_RW_CNTS                  ,2  ,STALL_TIME                     ,CHAR(2)
STALL_RW_CNTS                  ,3  ,INDIC_RW                       ,CHAR(1)
STALL_RW_CNTS                  ,4  ,STALL_REASON                   ,VARCHAR(198)

STALL_RW_TIMES                 ,1  ,STALL_DATE                     ,CHAR(10)
STALL_RW_TIMES                 ,2  ,STALL_TIME                     ,CHAR(16)
STALL_RW_TIMES                 ,3  ,STALL_PID                      ,CHAR(14)
STALL_RW_TIMES                 ,4  ,INDIC_RW                       ,CHAR(1)
STALL_RW_TIMES                 ,5  ,STALL_REASON                   ,VARCHAR(198)

TABLE_PARTI                    ,1  ,COL1                           ,INTEGER
TABLE_PARTI                    ,2  ,COL2                           ,CHAR(10)
TABLE_PARTI                    ,3  ,COL3                           ,INTEGER

TABLE_PLACE                    ,1  ,COL1                           ,INTEGER
TABLE_PLACE                    ,2  ,COL2                           ,CHAR(10)
TABLE_PLACE                    ,3  ,COL3                           ,INTEGER

TABLE_TRACE                    ,1  ,COL1                           ,INTEGER
TABLE_TRACE                    ,2  ,COL2                           ,CHAR(10)
TABLE_TRACE                    ,3  ,COL3                           ,INTEGER
TABLE_TRACE                    ,4  ,STMT                           ,CHAR(3)

WAITING_FOR_CNTS               ,1  ,STALL_DATE                     ,CHAR(10)
WAITING_FOR_CNTS               ,2  ,STALL_TIME                     ,CHAR(2)
WAITING_FOR_CNTS               ,3  ,STALL_REASON                   ,VARCHAR(132)

WAITING_FOR_DDLCKS             ,1  ,STALL_DATE                     ,CHAR(10)
WAITING_FOR_DDLCKS             ,2  ,STALL_TIME                     ,CHAR(2)
WAITING_FOR_DDLCKS             ,3  ,STALL_REASON                   ,VARCHAR(132)

WAITING_FOR_TIMES              ,1  ,STALL_DATE                     ,CHAR(10)
WAITING_FOR_TIMES              ,2  ,STALL_TIME                     ,CHAR(16)
WAITING_FOR_TIMES              ,3  ,STALL_PID                      ,CHAR(14)
WAITING_FOR_TIMES              ,4  ,STALL_REASON                   ,VARCHAR(132)

--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_INDICES.COM</b><br>
  List all indices and their ASC/DESC segments for a single database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_INDICES {dbid}
</pre>

  Output sample:<br>

<pre>
All Indices And Their Segments For Database:
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node: L15S29
At: 2015-04-02 15:24:30
--------------------------------------------------------------------------------
TABLE_PARTI                    ,TABLE_PARTI_IDX                ,1 ,    ,COL1

TABLE_PLACE                    ,TABLE_PLACE_HDX                ,1 ,    ,COL1

WAITING_FOR_CNTS               ,WAITING_FOR_CNTS_IDX           ,1 ,    ,STALL_DATE
WAITING_FOR_CNTS               ,WAITING_FOR_CNTS_IDX           ,2 ,    ,STALL_TIME
WAITING_FOR_CNTS               ,WAITING_FOR_CNTS_IDX           ,3 ,    ,STALL_REASON

WAITING_FOR_DDLCKS             ,WAITING_FOR_DDLCKS_IDX         ,1 ,    ,STALL_DATE
WAITING_FOR_DDLCKS             ,WAITING_FOR_DDLCKS_IDX         ,2 ,    ,STALL_TIME
WAITING_FOR_DDLCKS             ,WAITING_FOR_DDLCKS_IDX         ,3 ,    ,STALL_REASON

WAITING_FOR_TIMES              ,WAITING_FOR_TIMES_IDX          ,1 ,    ,STALL_DATE
WAITING_FOR_TIMES              ,WAITING_FOR_TIMES_IDX          ,2 ,    ,STALL_TIME
WAITING_FOR_TIMES              ,WAITING_FOR_TIMES_IDX          ,3 ,    ,STALL_PID
WAITING_FOR_TIMES              ,WAITING_FOR_TIMES_IDX          ,4 ,    ,STALL_REASON

--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_USERS.COM</b><br>
  List clusterwide database users and their tsn's in ascending order,
  and [Y|N], clusterwide OpenVMS users.<br>

  The procedure assumes the .RUJ filespec is specified as DISK$*.RUJ
  depending on the definition of the logical RDMS$RUJ.<br>

  The procedure allows to identify a long running read only transaction
  that causes the snapshot files to grow.
</p>

<p>
  The procedure lists per user on multiple lines:
</p>

<pre>
  (Repeating on each line to allow search)
  TSN or 'z' if no transaction
  Nodename
  PID
  Rdb stream id
  ----
  (On seperate lines)
  Output sequence number for sorting on tsn and stable output line sequence
  Transaction type, Last AIJ checkpoint
  User name
  Process name
  Image filespec
  RUJ filespec
  RUJ creation date/time
  RUJ revision date/time
  Blank separator
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_USERS {dbid} [Y|N]
</pre>

  Output sample:<br>

<pre>
0:692851031|L15S52|285FB22F|4|1|Read/Only||
0:692851031|L15S52|285FB22F|4|2|ROBBERECHTS|
0:692851031|L15S52|285FB22F|4|3|ROBBERECHTS|
0:692851031|L15S52|285FB22F|4|4|DSA27:[LISA320.][EXEC]OIA_ACTIVITY.EXE;1|
0:692851031|L15S52|285FB22F|4|5|DISK$DATA_28:[RDMS$RUJ]SABIN_TT$48IT2NQ8O0QANH3P4VMT0E8J9M.RUJ|
0:692851031|L15S52|285FB22F|4|6|19-JAN-2015 08:43:34.45|
0:692851031|L15S52|285FB22F|4|7|19-JAN-2015 08:43:34.46|
0:692851031|L15S52|285FB22F|4|8|
0:692859132|L15S50|27E0C51F|655|1|Read/Only|26746:31705|
0:692859132|L15S50|27E0C51F|655|2|SBN_USER|
0:692859132|L15S50|27E0C51F|655|3|SBN_LISA_0012|
0:692859132|L15S50|27E0C51F|655|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859132|L15S50|27E0C51F|655|5|DISK$DATA_28:[RDMS$RUJ]SABIN_TT$40RSCBL6DKMANH3P4VINK1LRUM.RUJ|
0:692859132|L15S50|27E0C51F|655|6|19-JAN-2015 04:44:52.10|
0:692859132|L15S50|27E0C51F|655|7|19-JAN-2015 04:44:52.11|
0:692859132|L15S50|27E0C51F|655|8|
0:692859132|L15S50|27FE5574|634|1|Read/Only|26746:31604|
0:692859132|L15S50|27FE5574|634|2|SBN_USER|
0:692859132|L15S50|27FE5574|634|3|SBN_LISA_0013|
0:692859132|L15S50|27FE5574|634|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859132|L15S50|27FE5574|634|5|DISK$DATA_28:[RDMS$RUJ]SABIN_TT$40RSCBL6DK1QD13P4VE1JHE9CM.RUJ|
0:692859132|L15S50|27FE5574|634|6|19-JAN-2015 00:16:24.27|
0:692859132|L15S50|27FE5574|634|7|19-JAN-2015 00:16:24.27|
0:692859132|L15S50|27FE5574|634|8|
0:692859132|L15S52|284E370B|11926|1|Read/Only||
0:692859132|L15S52|284E370B|11926|2|SBN_USER|
0:692859132|L15S52|284E370B|11926|3|SBN_LISA_0017|
0:692859132|L15S52|284E370B|11926|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859132|L15S52|284E370B|11926|5|
0:692859132|L15S58|27A62DEB|143|1|Read/Write|26746:33510|
0:692859132|L15S58|27A62DEB|143|2|JDBCMON|
0:692859132|L15S58|27A62DEB|143|3|TS1704|
0:692859132|L15S58|27A62DEB|143|4|DSA90:[000000.JAVA$150.BIN]JAVA$JAVA.EXE;1|
0:692859132|L15S58|27A62DEB|143|5|DISK$DATA_28:[RDMS$RUJ]SABIN_TT$3ASH2NQ8O0RIC13P4VOL6FSJHM.RUJ|
0:692859132|L15S58|27A62DEB|143|6|19-JAN-2015 10:24:07.70|
0:692859132|L15S58|27A62DEB|143|7|19-JAN-2015 10:24:07.71|
0:692859132|L15S58|27A62DEB|143|8|
0:692859132|L15S59|28AF8621|72339|1|Read/Only||
0:692859132|L15S59|28AF8621|72339|2|SBN_USER|
0:692859132|L15S59|28AF8621|72339|3|SBN_LISA_0005|
0:692859132|L15S59|28AF8621|72339|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859132|L15S59|28AF8621|72339|5|
0:692859132|L15S59|28B05A5A|72125|1|Read/Only||
0:692859132|L15S59|28B05A5A|72125|2|SBN_USER|
0:692859132|L15S59|28B05A5A|72125|3|SBN_LISA_0006|
0:692859132|L15S59|28B05A5A|72125|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859132|L15S59|28B05A5A|72125|5|
0:692859394|L15S53|28753924|661|1|Read/Write|26746:31522|
0:692859394|L15S53|28753924|661|2|SBN_USER|
0:692859394|L15S53|28753924|661|3|SBN_LISA_0013|
0:692859394|L15S53|28753924|661|4|DSA27:[LISA320.][EXEC]LISA_SERVER_BASE.EXE;48|
0:692859394|L15S53|28753924|661|5|DISK$DATA_28:[RDMS$RUJ]SABIN_TT$4GOT2NQ8O01QM13P4VGLVBLBVH.RUJ|
0:692859394|L15S53|28753924|661|6|19-JAN-2015 02:47:23.38|
0:692859394|L15S53|28753924|661|7|19-JAN-2015 02:47:23.38|
0:692859394|L15S53|28753924|661|8|
z|L15S50|27E0046A|1|1|No Trans||
z|L15S50|27E0046A|1|2|RDBMON|
z|L15S50|27E0046A|1|3|RDM_ALS72_0002|
z|L15S50|27E0046A|1|4|DSA100:[SYS0.SYSCOMMON.][SYSEXE]RDMALS72.EXE;6|
z|L15S50|27E0046A|1|5|
...
</pre>


<p>
<b>CPTRDB_SHOW_THIN_CLIENTS.COM</b><br>
  Calls CPTRDB_SHOW_THIN_CLIENTS_BATCH.COM
</p>

<p>
  Interactive list all current clients for one thin server on one cluster node.
  The sql statements are split in char(132) lines.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_THIN_CLIENTS {node} {server}
</pre>

  Output sample:<br>

<pre>
 2-APR-2015 15:29:02.87 - Rdb JDBC Thin Server TS1703 Clients From Node L15S58
 
--------------
On Node L15S58
--------------
 
rdbthincontrol> rdbthincontrol> 
RDB$CLIENT_ID                 : 000005FE
RDB$URL                       : clio_db
RDB$USER                      : CLIO_UNIX
RDB$IP                        : 10.55.11.149:35979
RDB$PID                       : 0x27B5CD5E:2FF(666226014:767)
RDB$PID_AT_EXECUTOR           : 0x27B5CD5E:3(666226014:3)
RDB$LAST_SQL                  : 2015-04-02 14:29:04.053 : select bankaccoun0_.BANK_ACCT_ID as BANK1_2_, bankaccoun0_.CLNT_ID as CLNT
13_2_, bankaccoun0_.SEQ_NO as SEQ3_2_, bankaccoun0_.BANK_OFFC_ID as BANK4_2_, bankaccoun0_.BANK_ACCT_NO as BANK14_2_, bankaccoun0_.B
ANK_IBAN_CD as BANK5_2_, bankaccoun0_.BANK_ACCT_OWNER as BANK7_2_, bankaccoun0_.BANK_ACCT_TYPE as BANK8_2_, bankaccoun0_.BANK_ACCT_C
OMMENT as BANK9_2_, bankaccoun0_.TIME_STAMP as TIME10_2_, bankaccoun0_.USER_FNGR_PRNT as USER11_2_, bankaccoun0_.APPLCTN_ID as APPLC
TN12_2_ , dbkey as RDB$JDBC_ROW_ID from CLIO_BANK_ACCTS bankaccoun0_ where (bankaccoun0_.CLNT_ID=3093154 ) order by  bankaccoun0_.SE
Q_NO DESC LIMIT 1
RDB$LAST_ACTION               : 2015-04-02 14:29:04.053 : SET_DEF_TRANS
RDB$LAST_EXCEPTION            : 
RDB$TIME_SINCE_LAST_ACTION    : 0 00:00
RDB$MINUTES_SINCE_LAST_ACTION : 0
RDB$LAST_OPEN                 : 2015-04-02 14:15:27.145
RDB$PID_AT_DB                 : 27B5CD5E:767

RDB$CLIENT_ID                 : 0000060F*
RDB$URL                       : <CONTROL CONNECTION>
RDB$USER                      : jdbcmon
RDB$IP                        : 10.3.130.191:64014
RDB$PID                       : 0x27B5CD5E(666226014)
RDB$PID_AT_EXECUTOR           : 0x27B5CD5E:3(666226014:3)
RDB$LAST_SQL                  : 
RDB$LAST_ACTION               : 2015-04-02 14:29:04.772 : INIT_CONTROL
RDB$LAST_EXCEPTION            : 
RDB$TIME_SINCE_LAST_ACTION    : 0 00:00
RDB$MINUTES_SINCE_LAST_ACTION : 0
RDB$LAST_OPEN                 : 
RDB$PID_AT_DB                 : 
rdbthincontrol> 
</pre>

<p>
<b>CPTRDB_SHOW_THIN_CLIENTS_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_THIN_CLIENTS.COM
</p>

<p>
  Requires the configuration file CPTRDB_CONFIGURATION.REF

  List the current clients for one JDBC thin server on one cluster node.

  The local java environment is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_PARAM|CPTRDB_RESTART_JDBC.
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_RESTART_JDBC|L15S28|DISK$DATA_24:[JAVA$150.COM]JAVA$150_SETUP|RDB$JDBC_COM:TSP1701_CFG_JVM5.XML|rdb4ever|RDBMON|TSP1701|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_RESTART_JDBC
! 2 Execution node
! 3 Java setup
! 4 JDBC config file
! 5 Control password
! 6 Reply to user
! 7 Pool server process name
</pre>

<p>
<b>CPTRDB_SHOW_TSN_BLKS.COM</b><br>
  List the number of users and TSN blocks in use per cluster node for a 
  database.
</p>

<p>
  The procedure enables to fine tune the number of users and thus the number
  of allocated TSN blocks: minimum 28 users per node (one TSN block).
  [As soon as one user connects to the database, one TSN block, describing
  28 users, is assigned to the executor node.]  
</p>

<p>
  This information is also available using
  RMU/Show Statistics "Database Parameter Info|TSNBLK Allocation".
</p>

<p>
  [Note that, if NUMBER OF CLUSTER NODES > 1, at the start of each read only 
  transaction, Rdb scans all TSN blocks to build a active writers list and
  apply the visibility rules, serialized by the SEQBLK lock, at the cost of two
  writes to the root file. This can result in excessive 'waiting for 
  SEQBLK/TSNBLK' stalls.
</p>

<p>
  The critical factor to these stalls is the availability of the root file,
  eventually drowned among other mass I/O's in a SAN Storage Area Network disks
  configuration.
</p>

<p>
  The SEQBLK/TSNBLK stalls can be reduced or eliminated by a number of 
  possible changes to the database environment. 
</p>

<pre>
. Switch to single node, NUMBER OF CLUSTER NODES = 1, using remote access on 
  other nodes of the cluster, which eliminates the root file I/O.

. Use READ WRITE transactions ISOLATION LEVEL READ COMMITTED, instead of 
  READ ONLY transactions, which eliminates the TSN blocks scan.

. Move the root file out of the SAN to a local disk, mounted on all nodes,
  which should improve the accessability of the root file.

. Disable the SAN disaster recovery replication for the root file device.]
</pre>

Usage:<br>

<pre>
$ @CPTRDB_SHOW_TSN_BLKS {dbid}
</pre>

Output sample:<br>

<pre>
Number Of Database Users And TSN Blocks Per Cluster Node
For Database
DSA23:[SBN_DB]SABIN_TT.RDB;1
On Node L15S50
At 2015-02-13 16:28:28
--------------------------------------------------------------------------------
Node   MoniId UsrCnt TsnCnt UsrMax UsrFre
--------------------------------------------------------------------------------
L15S50      1     32      2     56     24
L15S51      2     26      1     28      2
L15S52      3     28      1     28      0
L15S53      4     26      1     28      2
L15S58      5     23      1     28      5
L15S59      6     25      1     28      3
--------------------------------------------------------------------------------
       Totals    160      7    196     36
       Db Max    336     12
         Diff   -176     -5
</pre>

<p>
<b>CPTRDB_SHOW_AREAS_IDS.COM</b><br>
  List an overview of all storage areas and logical areas id's
  for a single database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_AREAS_IDS {dbid}
</pre>

  Output sample:<br>

<pre>
All Storage Areas / Logical Areas Ids
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-06-17 15:35:09
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    1 RDB$SYSTEM
         95|    1|   16|     |     |     |     |RDB$COLLATIONS
        123|    2|     |  123|     |     |     |RDB$COLLATIONS_NDX
         89|    1|    8|     |     |     |     |RDB$CONSTRAINTS
         90|    1|    9|     |     |     |     |RDB$CONSTRAINT_RELATIONS
        118|    2|     |  118|     |     |     |RDB$CON_CONSTRAINT_NAME_X
        119|    2|     |  119|     |     |     |RDB$CR_CONSTRAINT_NAME_NDX
         88|    1|    7|     |     |     |     |RDB$DATABASE
         86|    1|    1|     |     |     |     |RDB$FIELDS
        115|    2|     |  115|     |     |     |RDB$FIELDS_NAME_NDX
         83|    1|    6|     |     |     |     |RDB$FIELD_VERSIONS
         85|    1|    2|     |     |     |     |RDB$INDEX_SEGMENTS
         84|    1|    3|     |     |     |     |RDB$INDICES
        111|    2|     |  111|     |     |     |RDB$NDX_NDX_NAME_NDX
        112|    2|     |  112|     |     |     |RDB$NDX_SEG_NAM_FLD_POS_NDX
        100|    1|   20|     |     |     |     |RDB$PRIVILEGES
        128|    2|     |  128|     |     |     |RDB$PRV_OBJ_SUBOBJ_IDS_X
        127|    2|     |  127|     |     |     |RDB$RCF_CONSTRAINT_NAME_NDX
         82|    1|    4|     |     |     |     |RDB$RELATIONS
         98|    1|   18|     |     |     |     |RDB$RELATION_CONSTRAINTS
         99|    1|   19|     |     |     |     |RDB$RELATION_CONSTRAINT_FLDS
         87|    1|    5|     |     |     |     |RDB$RELATION_FIELDS
        113|    2|     |  113|     |     |     |RDB$REL_REL_NAME_NDX
        116|    2|     |  116|     |     |     |RDB$RFR_REL_NAME_FLD_ID_NDX
        126|    2|     |  126|     |     |     |RDB$RLC_CONSTRAINT_NAME_NDX
          1|    5|     |     |     |     |    1|RDB$SEGMENTED_STRINGS
         92|    1|   13|     |     |     |     |RDB$STORAGE_MAPS
         93|    1|   14|     |     |     |     |RDB$STORAGE_MAP_AREAS
        121|    2|     |  121|     |     |     |RDB$STO_MAP_AREA_MAP_NDX
        120|    2|     |  120|     |     |     |RDB$STO_MAP_MAP_NAM_NDX
        114|    2|     |  114|     |     |     |RDB$VER_REL_ID_VER_NDX
         91|    1|   12|     |     |     |     |RDB$VIEW_RELATIONS
        117|    2|     |  117|     |     |     |RDB$VIEW_VIEW_NAME_NDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    2 DEFAULT_AREA
         12|    1|  146|     |     |     |     |DBA_MVIEWS
          2|    1|   74|     |     |     |     |ENCRYPT_TABLE
         65|    1|   45|     |     |     |     |JCCLML$HEARTBEAT
         15|    2|     |   15|     |     |     |ORA_COMM_TRANID
         14|    1|  148|     |     |     |     |ORA_COMM_TRANS
          3|    1|  131|     |     |     |     |ORA_OBJECTS
          4|    2|     |    4|     |     |     |ORA_OBJECTS_NAME
         16|    1|  149|     |     |     |     |ORA_VALID_PROGRAMS
         19|    1|  152|     |     |     |     |PRODUCT_PROFILE
        135|    2|     |  135|     |     |     |RDB$GPRF_GRANTEE_ID_ID_NDX
        107|    1|   27|     |     |     |     |RDB$GRANTED_PROFILES
         94|    1|   15|     |     |     |     |RDB$INTERRELATIONS
        122|    2|     |  122|     |     |     |RDB$INTER_OBJ_SUBOBJ_NDX
        101|    1|   21|     |     |     |     |RDB$MODULES
        129|    2|     |  129|     |     |     |RDB$MOD_NAME_NDX
        110|    1|   31|     |     |     |     |RDB$OBJECT_SYNONYMS
        138|    2|     |  138|     |     |     |RDB$OBJSYN_NAME_NDX
        132|    2|     |  132|     |     |     |RDB$OUTL_NAME_NDX
        103|    1|   23|     |     |     |     |RDB$PARAMETERS
        131|    2|     |  131|     |     |     |RDB$PARAM_ROUT_ID_POS_NDX
        134|    2|     |  134|     |     |     |RDB$PRF_TYPE_NAME_NDX
        106|    1|   26|     |     |     |     |RDB$PROFILES
        104|    1|   24|     |     |     |     |RDB$QUERY_OUTLINES
        102|    1|   22|     |     |     |     |RDB$ROUTINES
        130|    2|     |  130|     |     |     |RDB$ROUT_NAME_NDX
        105|    1|   25|     |     |     |     |RDB$SEQUENCES
        133|    2|     |  133|     |     |     |RDB$SEQ_SEQ_NAME_NDX
        125|    2|     |  125|     |     |     |RDB$TRG_ACT_ID_NAM_NDX
        124|    2|     |  124|     |     |     |RDB$TRG_TRIGGER_NAME_NDX
         96|    1|   17|     |     |     |     |RDB$TRIGGERS
         97|    1|   30|     |     |     |     |RDB$TRIGGER_ACTIONS
        108|    1|   28|     |     |     |     |RDB$TYPES
        109|    1|   29|     |     |     |     |RDB$TYPE_FIELDS
        137|    2|     |  137|     |     |     |RDB$TYP_FLD_TYP_ID_NDX
        136|    2|     |  136|     |     |     |RDB$TYP_TYP_NAM_NDX
          5|    1|  138|     |     |     |     |RECYCLEBIN
         20|    1|  153|     |     |     |     |ROLE_SYS_PRIVS
         21|    1|  154|     |     |     |     |ROLE_TAB_PRIVS
         10|    1|  144|     |     |     |     |SESSION_ROLES
         23|    1|  156|     |     |     |     |SNAP$
         25|    1|  160|     |     |     |     |SQLSRV_EMPLOYEES
         26|    1|  161|     |     |     |     |SQLSRV_INSERT_TABLE
         11|    1|  145|     |     |     |     |SQL_CAPABILITY
         22|    1|  155|     |     |     |     |SYSTEM_PRIVILEGE_MAP
         60|    1|   41|     |     |     |     |TABLE_ALL_DATATYPES
          9|    1|  143|     |     |     |     |TOOL_MODULE
          7|    1|  141|     |     |     |     |USER$
          8|    2|     |    8|     |     |     |USER$_NAME
         18|    1|  151|     |     |     |     |USER_ROLE_PRIVS
         17|    1|  150|     |     |     |     |USER_SYS_PRIVS
         13|    1|  147|     |     |     |     |USER_TABLESPACES
          6|    1|  139|     |     |     |     |V$OPTION
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    3 LISTS_AREA
         61|    5|     |     |     |     |   61|RDB$SEGMENTED_STRINGS
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    4 MIXED_AREA_1
         62|    4|     |     |     |   62|     |RDB$SYSTEM_RECORD
         70|    1|   42|     |     |     |     |TABLE_PLACE
         67|    3|     |     |   67|     |     |TABLE_PLACE_HDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    5 MIXED_AREA_2
         63|    4|     |     |     |   63|     |RDB$SYSTEM_RECORD
         71|    1|   42|     |     |     |     |TABLE_PLACE
         68|    3|     |     |   68|     |     |TABLE_PLACE_HDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    6 MIXED_AREA_3
         64|    4|     |     |     |   64|     |RDB$SYSTEM_RECORD
         72|    1|   42|     |     |     |     |TABLE_PLACE
         69|    3|     |     |   69|     |     |TABLE_PLACE_HDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    7 DATA_AREA_11
         66|    1|   44|     |     |     |     |LISTTAB
         73|    1|   43|     |     |     |     |TABLE_PARTI
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    8 DATA_AREA_12
         76|    1|   43|     |     |     |     |TABLE_PARTI
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    9 DATA_AREA_21
         74|    1|   43|     |     |     |     |TABLE_PARTI
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   10 DATA_AREA_22
         77|    1|   43|     |     |     |     |TABLE_PARTI
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   11 DATA_AREA_31
         75|    1|   43|     |     |     |     |TABLE_PARTI
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   12 DATA_AREA_32
         78|    1|   43|     |     |     |     |TABLE_PARTI
         30|    1|  848|     |     |     |     |TABLE_TRACE
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   13 INDEX_AREA_1
         29|    2|     |   29|     |     |     |TABLE_PARTI_IDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   14 INDEX_AREA_2
         33|    2|     |   33|     |     |     |TABLE_PARTI_IDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   15 INDEX_AREA_3
         35|    2|     |   35|     |     |     |TABLE_PARTI_IDX
--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
   16 STALL_CNTS_AREA
         32|    1|  907|     |     |     |     |WAITING_FOR_CNTS
         24|    2|     |   24|     |     |     |WAITING_FOR_CNTS_IDX
         34|    1|  906|     |     |     |     |WAITING_FOR_DDLCKS
         27|    2|     |   27|     |     |     |WAITING_FOR_DDLCKS_IDX
         37|    1|  908|     |     |     |     |WAITING_FOR_TIMES
         28|    2|     |   28|     |     |     |WAITING_FOR_TIMES_IDX
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_PAGE.COM</b><br>
  List and dump one data or snapshot page for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_PAGE {dbid} {s_area_nbr} {page_nbr} [DATA|SNAP]
</pre>

  Output samples:<br>

<pre>
*     On Node L15S50
* Dump of Live area SEASN_TKT_DATA
*     Database: DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;1
*     Filename: DISK$DATA_25:[SBN_DB]SEASN_TKT_DATA.RDA;1
*     Time Stamp
               00B0F736 810F1060  000A  time stamp = 21-SEP-2016 02:15:36.66
*     Free Bytes/Locked
                       0000 05C8  0012  1480 free bytes, 0 locked
*     Lines
                            001E  0016  30 lines
*     SPAM Page
*     Bitmap Page
*     Pointer/Data Segment
*     Record Type/Fragment/Empty
                       0000 0000  0024  line 3: empty
                       0000 0000  0030  line 6: empty
                       0000 0000  0034  line 7: empty
                       0000 0000  0048  line 12: empty
                       0000 0000  0054  line 15: empty
                       0000 0000  0060  line 18: empty
                       0000 0000  0064  line 19: empty
                       0000 0000  0068  line 20: empty
                       0000 0000  006C  line 21: empty
                       0000 0000  0070  line 22: empty
                       0000 0000  0074  line 23: empty
                            0048  06D0  line 29 (56:1000:29) record type 72
                            0026  06FC  line 17 (56:1000:17) record type 38
                            0025  0720  line 16 (56:1000:16) record type 37
                            0023  0782  line 13 (56:1000:13) record type 35
                            0048  07D8  line 11 (56:1000:11) record type 72
                            0027  0832  line 9 (56:1000:9) record type 39
                            0026  0868  line 5 (56:1000:5) record type 38
                            0025  088C  line 4 (56:1000:4) record type 37
                            0023  08F4  line 1 (56:1000:1) record type 35
                            0048  09A6  line 27 (56:1000:27) record type 72
                            0026  09CE  line 26 (56:1000:26) record type 38
                            0025  09F2  line 25 (56:1000:25) record type 37
                            0023  0A5C  line 24 (56:1000:24) record type 35
*     Index Set
*     Level
*     Hash Index
                       005A 2005  080A  line 10: bucket for hash index 90
                       00B7 2005  094A  line 28: bucket for hash index 183
                       0057 2005  0AB2  line 14: bucket for hash index 87
                       0052 2005  0B0E  line 8: bucket for hash index 82
                       004A 2005  0B6A  line 2: bucket for hash index 74
*     System Record
                            2001  0BC6  line 0 (56:1000:0) SYSTEM record
*     Storage Set Type
                         004A 07  0BCB  7 bytes, storage set type 74
                         0052 07  0BD2  7 bytes, storage set type 82
                         0057 07  0BD9  7 bytes, storage set type 87
                         00B7 07  0BE0  7 bytes, storage set type 183
                         005A 07  0BE7  7 bytes, storage set type 90
*     Logical Area
*     Snap Page Pointer
                        00005E81  0BEE  snap page pointer 24193
*     Live Page Pointer
Output RDB$PROCS:PAGE_8_1000_SBN_DB_L15S50_20161020.LIS_20OCT111520
</pre>

<pre>
*     On Node L15S50
* Dump of Live area CLNTS_SIDS
*     Database: DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB;1
*     Filename: DISK$DATA_23:[CLIO_DB]CLNTS_SIDS.RDA;1
*     Time Stamp
               00B24634 49822C2A  000A  time stamp = 21-NOV-2017 09:33:44.00
*     Free Bytes/Locked
                       0000 000E  0012  14 free bytes, 0 locked
*     Lines
                            0002  0016  2 lines
*     SPAM Page
*     Bitmap Page
*     Pointer/Data Segment
*     Record Type/Fragment/Empty
*     Node Size
                                  ....  total B-tree node size: 988
                                  ....  total B-tree node size: 988
*     Index Set
                       0095 200D  0036  line 1 (3:304309:1) index: set 149
                       0095 200D  0412  line 0 (3:304309:0) index: set 149
*     Level
                            8200  0044  level 1, full suffix
                            8200  0420  level 1, full suffix
*     Hash Index
*     System Record
*     Storage Set Type
*     Logical Area
                            0095  07F6  logical area 149
*     Snap Page Pointer
                        000000FA  07EE  snap page pointer 250
*     Live Page Pointer
Output RDB$PROCS:PAGE_3_304309_CLIO_DB_L15S50_20171129.LIS_29NOV162400
</pre>

<p>
  The output file contains the full RMU/Dump page dump.
</p>

<p>
<b>CPTRDB_SHOW_ONE_LOGICAL_AREA.COM</b><br>
  List one logical area id for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_LOGICAL_AREA {dbid} {logical_area_id}
</pre>

  Output sample:<br>

<pre>
Logical Area Id 77
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-04-02 15:44:05
--------------------------------------------------------------------------------
RDB$LOGICAL_AREAS
01 rdb$logical_area_id
02 rdb$logical_area_name
03 rdb$record_type
04 rdb$record_length
05 rdb$area_id
06 rdb$threshold1_percent
07 rdb$threshold2_percent
08 rdb$threshold3_percent
09 rdb$flags
10 rdb$ordered_hash_offset
--------------------------------------------------------------------------------
77|TABLE_PARTI|1|37|10|0|0|0|0|0|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_STORAGE_AREA.COM</b><br>
  List one storage area id for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_STORAGE_AREA {dbid} {storage_area_id}
</pre>

  Output sample:<br>

<pre>
Storage Area Id 10
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-04-02 15:47:23
--------------------------------------------------------------------------------
RDB$STORAGE_AREAS
01 rdb$area_id
02 rdb$linked_area_id
03 rdb$area_name
04 rdb$page_size
05 rdb$page_length
06 rdb$max_page_free_space
07 rdb$max_segment_length
08 rdb$max_row_length
09 rdb$clump_page_count
10 rdb$spam_interval
11 rdb$pages_per_spam_page_p1
12 rdb$cache_id

01 rdb$initial_allocation
02 rdb$current_allocation
03 rdb$extend_count
04 rdb$last_extend
05 rdb$area_min_extent
06 rdb$area_max_extent
07 rdb$area_percent_extent

01 rdb$journal_sequence
02 rdb$sequence
03 rdb$last_backup

01 rdb$area_file
--------------------------------------------------------------------------------
10|31|DATA_AREA_22|4|2048|2006|1988|1988|6|3468|3469|0|
3000|3001|0|1858-11-17 00:00:00|3000|6000|20|
0|1|2015-04-02 00:35:00|
DISK$DATA_29:[CPTRDB_DB_1]DATA_AREA_22.RDA;1|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_RECORD_TYPE.COM</b><br>
  List one record type id for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_RECORD_TYPE {dbid} {record_type_id} 
</pre>

  Output sample:<br>

<pre>
Record Type Id 43
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-04-02 15:52:22
--------------------------------------------------------------------------------
RDB$RELATIONS
01 rdb$relation_id
02 rdb$relation_name
03 rdb$storage_id
04 rdb$system_flag
05 rdb$flags
06 rdb$cardinality

01 rdb$relation_creator
02 rdb$created
03 rdb$last_altered

RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$index_name
04 rdb$flags
05 rdb$vertical_partition_index
06 rdb$vertical_partition_name

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$area_name
03 rdb$partition_name
04 rdb$ordinal_position
05 rdb$storage_id
06 rdb$index_id
07 rdb$flags
08 rdb$vertical_partition_index
--------------------------------------------------------------------------------
43|TABLE_PARTI|0|0|0|751|
RDBMON|2013-10-04 15:43:34|2013-12-03 16:06:47|

TABLE_PARTI_MAP|TABLE_PARTI||4|1|VRP_P001|
TABLE_PARTI_MAP|TABLE_PARTI||4|2|VRP_P002|

TABLE_PARTI_MAP|DATA_AREA_11|SYS_P00073|1|73|0|0|1|
TABLE_PARTI_MAP|DATA_AREA_21|SYS_P00074|2|74|0|0|1|
TABLE_PARTI_MAP|DATA_AREA_31|SYS_P00075|3|75|0|0|1|
TABLE_PARTI_MAP|DATA_AREA_12|SYS_P00076|1|76|0|0|2|
TABLE_PARTI_MAP|DATA_AREA_22|SYS_P00077|2|77|0|0|2|
TABLE_PARTI_MAP|DATA_AREA_32|SYS_P00078|3|78|0|0|2|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_INDEX_SET.COM</b><br>
  List one index set id for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_INDEX_SET {dbid} {index_set_id}
</pre>

  Output sample:<br>

<pre>
Index Set Id 79
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-04-02 15:57:39
--------------------------------------------------------------------------------
RDB$INDICES
01 rdb$index_id
02 rdb$index_name
03 rdb$relation_name
04 rdb$unique_flag
05 rdb$flags
06 rdb$cardinality

07 rdb$index_creator
08 rdb$created
09 rdb$last_altered

RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$index_name
04 rdb$flags
05 rdb$vertical_partition_index
06 rdb$vertical_partition_name

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$area_name
03 rdb$partition_name
04 rdb$ordinal_position
05 rdb$storage_id
06 rdb$index_id
07 rdb$flags
08 rdb$vertical_partition_index
--------------------------------------------------------------------------------
0|TABLE_PARTI_IDX|TABLE_PARTI|1|4096|0|
RDBMON|2013-10-04 15:43:35|2014-11-27 15:11:06|

TABLE_PARTI_IDX|||-32768|0||

TABLE_PARTI_IDX|INDEX_AREA_1|SYS_P00079|1|0|79|0|0|
TABLE_PARTI_IDX|INDEX_AREA_2|SYS_P00080|2|0|80|0|0|
TABLE_PARTI_IDX|INDEX_AREA_3|SYS_P00081|3|0|81|0|0|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_HASH_INDEX.COM</b><br>
  List one hashed index id for a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_HASH_INDEX {dbid} {system_record_id} {hash_index_id}
</pre>

  Output sample:<br>

<pre>
System Record Id 63
Hash Index Id    68
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29

At 2015-04-02 16:01:48
--------------------------------------------------------------------------------
RDB$INDICES
01 rdb$index_id
02 rdb$index_name
03 rdb$relation_name
04 rdb$unique_flag
05 rdb$flags
06 rdb$cardinality

07 rdb$index_creator
08 rdb$created
09 rdb$last_altered

RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$index_name
04 rdb$flags
05 rdb$vertical_partition_index
06 rdb$vertical_partition_name

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$area_name
03 rdb$partition_name
04 rdb$ordinal_position
05 rdb$storage_id
06 rdb$index_id
07 rdb$flags
08 rdb$vertical_partition_index
--------------------------------------------------------------------------------
0|TABLE_PLACE_HDX|TABLE_PLACE|1|1|0|
RDBMON|2013-10-04 15:43:34|2014-11-27 15:20:25|

TABLE_PLACE_HDX|||-32768|0||

TABLE_PLACE_HDX|MIXED_AREA_1|SYS_P00067|1|62|67|0|0|
TABLE_PLACE_HDX|MIXED_AREA_2|SYS_P00068|2|63|68|0|0|
TABLE_PLACE_HDX|MIXED_AREA_3|SYS_P00069|3|64|69|0|0|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_ONE_STORAGE_MAP.COM</b><br>
  List all logical areas for a given table or index name of a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_ONE_STORAGE_MAP {dbid} [TABLE|INDEX] {object name}
</pre>

  Output samples:<br>

<pre>
Storage Map For
TABLE       TABLE_PARTI
Of Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node     L15S29

At 2015-04-02 16:06:04
--------------------------------------------------------------------------------
RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$vertical_partition_index
04 rdb$vertical_partition_name
05 rdb$index_name
06 rdb$flags
07 format
08 compression
09 partitioning

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$storage_id
03 rdb$partition_name
04 rdb$area_name
05 rdb$ordinal_position
06 rdb$vertical_partition_index
07 rdb$index_id
08 rdb$flags
09 rdb$root_dbk
10 sarea_id
--------------------------------------------------------------------------------
TABLE_PARTI_MAP|TABLE_PARTI|1|VRP_P001||4|Format Uniform|Compression Enabled|Partitioning Not Updatable|
TABLE_PARTI_MAP|TABLE_PARTI|2|VRP_P002||4|Format Uniform|Compression Enabled|Partitioning Not Updatable|
--------------------------------------------------------------------------------
TABLE_PARTI_MAP|73|SYS_P00073|DATA_AREA_11|1|1|0|0|0:0:0|7|
TABLE_PARTI_MAP|74|SYS_P00074|DATA_AREA_21|2|1|0|0|0:0:0|9|
TABLE_PARTI_MAP|75|SYS_P00075|DATA_AREA_31|3|1|0|0|0:0:0|11|
TABLE_PARTI_MAP|76|SYS_P00076|DATA_AREA_12|1|2|0|0|0:0:0|8|
TABLE_PARTI_MAP|77|SYS_P00077|DATA_AREA_22|2|2|0|0|0:0:0|10|
TABLE_PARTI_MAP|78|SYS_P00078|DATA_AREA_32|3|2|0|0|0:0:0|12|
--------------------------------------------------------------------------------

...

Storage Map For
TABLE       TABLE_PLACE
Of Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node     L15S29

At 2015-04-02 16:07:41
--------------------------------------------------------------------------------
RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$vertical_partition_index
04 rdb$vertical_partition_name
05 rdb$index_name
06 rdb$flags
07 format
08 compression
09 partitioning

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$storage_id
03 rdb$partition_name
04 rdb$area_name
05 rdb$ordinal_position
06 rdb$vertical_partition_index
07 rdb$index_id
08 rdb$flags
09 rdb$root_dbk
10 sarea_id
--------------------------------------------------------------------------------
TABLE_PLACE_MAP|TABLE_PLACE|0||TABLE_PLACE_HDX|5|Format Mixed|Compression Enabled|Partitioning Not Updatable|
--------------------------------------------------------------------------------
TABLE_PLACE_MAP|70|SYS_P00070|MIXED_AREA_1|1|0|0|0|0:0:0|4|
TABLE_PLACE_MAP|71|SYS_P00071|MIXED_AREA_2|2|0|0|0|0:0:0|5|
TABLE_PLACE_MAP|72|SYS_P00072|MIXED_AREA_3|3|0|0|0|0:0:0|6|
--------------------------------------------------------------------------------

...

Storage Map For
INDEX       TABLE_PARTI_IDX
Of Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node     L15S29

At 2015-04-02 16:09:00
--------------------------------------------------------------------------------
RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$vertical_partition_index
04 rdb$vertical_partition_name
05 rdb$index_name
06 rdb$flags
07 format
08 compression
09 partitioning

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$storage_id
03 rdb$partition_name
04 rdb$area_name
05 rdb$ordinal_position
06 rdb$vertical_partition_index
07 rdb$index_id
08 rdb$flags
09 rdb$root_dbk
10 sarea_id
--------------------------------------------------------------------------------
TABLE_PARTI_IDX||0|||-32768||||
--------------------------------------------------------------------------------
TABLE_PARTI_IDX|0|SYS_P00079|INDEX_AREA_1|1|0|79|0|79:10:0|13|
TABLE_PARTI_IDX|0|SYS_P00080|INDEX_AREA_2|2|0|80|0|80:10:0|14|
TABLE_PARTI_IDX|0|SYS_P00081|INDEX_AREA_3|3|0|81|0|81:10:0|15|
--------------------------------------------------------------------------------

...

Storage Map For
INDEX       TABLE_PLACE_HDX
Of Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node     L15S29

At 2015-04-02 16:10:54
--------------------------------------------------------------------------------
RDB$STORAGE_MAPS
01 rdb$map_name
02 rdb$relation_name
03 rdb$vertical_partition_index
04 rdb$vertical_partition_name
05 rdb$index_name
06 rdb$flags
07 format
08 compression
09 partitioning

RDB$STORAGE_MAP_AREAS
01 rdb$map_name
02 rdb$storage_id
03 rdb$partition_name
04 rdb$area_name
05 rdb$ordinal_position
06 rdb$vertical_partition_index
07 rdb$index_id
08 rdb$flags
09 rdb$root_dbk
10 sarea_id
--------------------------------------------------------------------------------
TABLE_PLACE_HDX||0|||-32768||||
--------------------------------------------------------------------------------
TABLE_PLACE_HDX|62|SYS_P00067|MIXED_AREA_1|1|0|67|0|-1:-1:-1|4|
TABLE_PLACE_HDX|63|SYS_P00068|MIXED_AREA_2|2|0|68|0|-1:-1:-1|5|
TABLE_PLACE_HDX|64|SYS_P00069|MIXED_AREA_3|3|0|69|0|-1:-1:-1|6|
--------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_EXTRACT_ONE_OBJECT.COM</b><br>
  RMU/Extract one wildcard object from a database.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_EXTRACT_ONE_OBJECT {dbid} {item} {wildcard object}
</pre>

  Output sample:<br> 
  (All indices containing 'TABLE')<br>

<pre>
set verify;
set language ENGLISH;
set default date format 'SQL92';
set quoting rules 'SQL92';
set date format DATE 001, TIME 001;

attach 'filename DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB';

set transaction read write reserving
    TABLE_PARTI for EXCLUSIVE WRITE;
create unique index TABLE_PARTI_IDX
    on TABLE_PARTI (
    COL1
        asc)
    type is SORTED RANKED
    node size 1988
    usage UPDATE
    store 
        using (COL1)
            in INDEX_AREA_1
                with limit of (500)
            in INDEX_AREA_2
                with limit of (1000)
            in INDEX_AREA_3
                with limit of (1500);
 
commit work;
 
set transaction read write reserving
    TABLE_PLACE for EXCLUSIVE WRITE;
create unique index TABLE_PLACE_HDX
    on TABLE_PLACE (
    COL1)
    type is HASHED SCATTERED
    store 
        using (COL1)
            in MIXED_AREA_1
                with limit of (500)
            in MIXED_AREA_2
                with limit of (1000)
            in MIXED_AREA_3
                with limit of (1500);
 
commit work;
</pre>

<p>
<b>CPTRDB_SHOW_TABLE_METADATA.COM</b><br>
  List all metadata objects related to one table.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_TABLE_METADATA {dbid} {table name}
</pre>

  Output sample:<br>

<pre>
All Related Metadata For Table
TABLE_PARTI
Of Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29
At: 2015-04-03 11:26:50
--------------------------------------------------------------------------------
Storage map:
  TABLE_PARTI_MAP

Views:

Indices:
  TABLE_PARTI_IDX

Triggers:

Modules/Routines:
  LOAD_TABLES                    LOAD_TABLE_PARTI

Constraints:
  TABLE_PARTI_PK

Domains/Collating Sequences:
  SQL$10CHR
  SQL$INT

Outlines:

--------------------------------------------------------------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38 -- Tune Indices To Queries
</font>
</h3>

<b>CPTRDB_INDEX_NODE_SIZES.COM</b><br>
<b>CPTRDB_UNLOAD.COM</b><br>
<b>CPTRDB_UNLOAD_GEN.COM</b><br>
<b>CPTRDB_LOAD.COM</b><br>
<b>CPTRDB_LOAD_GEN.COM</b><br>
<b>CPTRDB_LOAD_PLACE.COM</b><br>
<b>CPTRDB_COLLECT_OPTIMIZER_STAT.COM</b><br>
<b>CPTRDB_SHOW_OPTIMIZER_STAT.COM</b><br>
<b>CPTRDB_PREFIX_CARDINALITY.COM</b><br>
<b>CPTRDB_ANALYZE_INDEX.COM</b><br>
<b>CPTRDB_ANALYZE_AREA.COM</b><br>
<b>CPTRDB_ANALYZE_PLACEMENT.COM</b><br>
<b>CPTRDB_DBKEYS_GROUPBY_PAGE.COM</b><br>
<b>CPTRDB_SELECT_GRPBY_GEN.COM</b><br>
<b>CPTRDB_CREATE_INDEX.COM</b><br>
<b>CPTRDB_QUERY.COM</b><br>
<b>CPTRDB_CLIO_FULL_ADDRESS.COM</b><br>

<p>
The procedures in this chapter can be used in the iterating process of loading 
equivalent production volumes of data into a test database, create candidate
indices for the target queries, and evaluate their prefix cardinalities,
physical structure, size, number of levels, selectivity, optimizer behavior and 
performance impact.   

The performance improvements by correctly tuned indices can be huge,
and provide the fastest gains, with a minimum effort, in the smallest
laps of time, before investigation of other causes for slow queries.
Tuning indices is not a mathematical exact science but this try and error
effort will pay back rapidly. 
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.1 -- Identify Potential Problem Areas
</font>
</h3>

<p>
  The RMU/Show Statistics logical area overview screens for tables and
  indices, ordered by record or leaf fetches, over a single business day,
  can provide a good indication of potential problem areas. The same
  (hopefully) reduced numbers afterwards, are the only valid proof of
  a successfull index tuning effort. If not, the application probably behaves
  in a different way than you expected, or there was a serious oversight
  in the diagnosis. Failure is not excluded and you may be forced to
  return to the previous index definitions.
</p>

  Start the 'observation' business day using<br>

<pre>
$ RMU/Show Statistics/time=1[/reset] {db}
</pre>

<p>
  and write the sorted logical area overview screens at the end of the day
  for later reference.
</p>

<pre>
Node: L15S50 (1/6/6)   Oracle Rdb V7.2-500 Perf. Monitor  3-NOV-2015 15:34:51.18
Rate: 3.00 Seconds   Logical Area Overview (Btree Ind   Elapsed: 251 17:24:13.67
Page: 1 of 4          DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;1           Mode: Online
--------------------------------------------------------------------------------
Logical.Area.Name... leaf fetches leaf inserti leaf removal    discarded CurTot
STKT_PRSN_LAST_NAME_     36669188        85101            0            0
SEASN_TKT_VALDTN_IDX      8432940       445297        24191            0
FULL_SLS_IDX.LISA_SA      5255103      4573416            0            0
SEASN_TKT_TRACE_IDX.      3790301       536270      1890362          385
SEASN_TKT_VALDTN_TOL      1047807         5913            0            0
SEASN_TKT_OIA_IDX.SE       686223       259112            0            0
WEB_SEASN_TKT_REF_ID       586754         2499            0            0
FULL_SLS_MOBIB_IDX.T       581630       266806            0            0
SEASN_TKT_VALDTN_IDX       327879       448565            0            0
SEASN_TKT_MOBIB_IDX.       189310        29465            0            0
FDLTY_STKT_IDX.FDLTY       151647        58104            0            0
SEASN_TKT_MOBIB_STKT        92836        29451            0            0
FDLTY_STKT_PRSN_IDX.        87304        58072            0            0
FDLTY_STKT_PREVSTKT_        80503        58050          332            0
STKTV_RPRTTN_IDX.FUL        61989       406618            0            0
SEASN_TKT_PRSN_PTNOV        55196        85095            0            0
FDLTY_SLS_IDX.FDLTY_        54841         6828            0            0
--------------------------------------------------------------------------------
</pre>

  Monitor individual indices/tables using the tools menu.<br>
  
<pre>
Press key "!" for the tools menu
Toggle "Display all logical areas"
    to "Display application logical areas"
Press "!"
"Logical Area menu filter"
Enter *{NAME}* in uppercase
"Logical Area Overview (Tables)"
"Logical Area Statistics"
"Select Logical Area"
</pre>

<pre>
Node: L15S50 (1/6/6)   Oracle Rdb V7.2-500 Perf. Monitor  3-NOV-2015 15:36:16.40
Rate: 3.00 Seconds          Logical Area Statistics     Elapsed: 251 17:25:38.89
Page: 1 of 1          DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;1           Mode: Online
--------------------------------------------------------------------------------
                Btree STKT_PRSN_LAST_NAME_IDX in SEASN_TKT_SIDS
statistic.........      rate.per.second............. total....... average......
name..............      max..... cur..... avg....... count....... per.trans....
  
node fetches                   3        0        0.0     36750202           0.2
 leaf fetches                  0        0        0.0     36669190           0.2
 dup. fetches                  0        0        0.0            0           0.0
index lookups                  0        0        0.0            0           0.0
index scans                    0        0        0.0        27885           0.0
 primary entries               1        0        0.0   3589481819          28.3
 dup. entries                  0        0        0.0            0           0.0
node insertions                0        0        0.0        85350           0.0
 root insertions               0        0        0.0            0           0.0
 leaf insertions               0        0        0.0        85102           0.0
 dup. insertions               0        0        0.0            0           0.0
node creations                 0        0        0.0          248           0.0
 root splits                   0        0        0.0            0           0.0
 leaf creations                0        0        0.0          244           0.0
--------------------------------------------------------------------------------
</pre>

<p>
  The 'primary entries' value indicates that the index is not that selective,
  as large parts of the level 1 leaf nodes are read.

  The number of node fetches per index scan is high.

  Investigate the prefix cardinalities for the suboptimal index.
</p>

<pre>
$ @CPTRDB_PREFIX_CARDINALITY {dbid} {table_name}
</pre>

<pre>
Prefix Cardinalities For Index STKT_PRSN_LAST_NAME_IDX
Unique
Table Cardinality: 3501478
--------------------------------------------------------------------------------
84|SYS_P00084|Sorted|2900|SEASN_TKT_SIDS|9|Uniform|6|3012|
--------------------------------------------------------------------------------
1        LAST_NAME                      2934887
2        SEASN_TKT_ID                   0
--------------------------------------------------------------------------------
</pre>

<p>
  At a first glance, the index is not sorted ranked and the node size 2900 is
  smaller than the max segment size 3012 of the storage area. Per page 112
  bytes are spoiled.

  Save the index analysis for later reference and discover more.
</p>

<pre>
------------------------------------------------------------------------------
 Indices for database  - DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;
 Created 10-NOV-2015 11:43:21.60
------------------------------------------------------------------------------
 Index STKT_PRSN_LAST_NAME_IDX for relation SEASN_TKT_PRSN duplicates not allowed
 Max Level: 4, Nodes: 41403, Used/Avail: 69181873/118743804 (58%), Keys: 4075275, Records: 4033873
     Total Comp/Uncomp IKEY Size: 100349738/179312100, Compression Ratio: 0.56

     Level: 4, Nodes: 1, Used/Avail: 50/2868 (1%), Keys: 3, Records: 0
     Level: 3, Nodes: 3, Used/Avail: 4471/8604 (52%), Keys: 278, Records: 0
     Level: 2, Nodes: 278, Used/Avail: 477854/797304 (59%), Keys: 41121, Records: 0
     Level: 1, Nodes: 41121, Used/Avail: 68699498/117935028 (58%), Keys: 4033873, Records: 4033873
------------------------------------------------------------------------------
</pre>

  The index uses key suffix compression.<br>

<pre>
STKT_PRSN_LAST_NAME_IDX         with column LAST_NAME
                                and column SEASN_TKT_ID
  No Duplicates allowed
  Type is Sorted
  Key suffix compression is ENABLED (Min run length 2)
  Node size 2900
  Percent fill 70
 Store clause:          STORE in SEASN_TKT_SIDS
</pre>

  The prefix cardinalities are not correct.<br>

  After a RMU/Collect:<br>

<pre>
Optimizer Statistics collected for table : SEASN_TKT_PRSN
  Cardinality            : 4033933
Index name : STKT_PRSN_LAST_NAME_IDX
  Index Cardinality      : 0
  Segment Column                 Prefix cardinality
    LAST_NAME                       413900
    SEASN_TKT_ID                    0
Done writing stats.... at 10-NOV-2015 12:03:25.37
</pre>

<pre>
Prefix Cardinalities For Index STKT_PRSN_LAST_NAME_IDX
Unique
Table Cardinality: 4033933
--------------------------------------------------------------------------------
84|SYS_P00084|Sorted|2900|SEASN_TKT_SIDS|9|Uniform|6|3012|
--------------------------------------------------------------------------------
1        LAST_NAME                      413900
2        SEASN_TKT_ID                   0
--------------------------------------------------------------------------------
</pre>

<p>
  Conclusion and target for index STKT_PRSN_LAST_NAME_IDX.<br>

  To make the index more selective, read less nodes per scan, and read
  smaller parts at the leaf level, test with:<br> 
    sorted ranked<br>
    node size 3012<br>
    min run length > 2
</p>

<p>
  The results of the daily stall and deadlock logs analysis by the procedures<br>
  CPTRDB_STALL_CNTS_ALL.COM<br>
  CPTRDB_STALL_TIMES_ALL.COM</br>
  CPTRDB_DDLCK_CNTS_ALL.COM</br>
  also provide a useful entry point for investigation of performance issues.
</p>

<pre> 
CPTRDB - Stall Times Greater Than One Second From Node L15S50
For Database: DISK$DATA_25:[C170_DB]C170_DB.RDB
On Node:      L15S58
Since:        5-NOV-2015
Before:       6-NOV-2015
Alarm:        6
At:            6-NOV-2015 05:00:11.68
------------------------------------------------------------------------------------------------------------------------------------
2015-11-05|04:48:40.0166782|27A39DB6:28302|    3|record 84:33701:0 (EX)|
2015-11-05|04:48:43.8416782|27A93685:27803|    3|record 84:33701:0 (EX)|
2015-11-05|04:48:49.0746782|27A26F6E:28399|    2|record 84:33701:0 (EX)|
2015-11-05|05:19:48.8662582|27A39DB6:28306|    3|record 84:33701:0 (EX)|
2015-11-05|05:19:52.9292582|27A93685:27807|    3|record 84:33701:0 (EX)|
2015-11-05|05:19:57.9902582|27A26F6E:28403|    2|record 84:33701:0 (EX)|
2015-11-05|05:20:01.6732582|27A50083:28231|    2|record 84:33701:0 (EX)|
2015-11-05|08:16:38.9676682|27A795F5:28577|   24|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|08:17:04.5526682|27A26F6E:28759|    7|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|08:17:13.7746682|27A50083:28580|    3|record 84:33701:0 (EX)|
2015-11-05|09:06:02.7924682|27A39DB6:29081|    3|record 79:305211:0 (EX)|
2015-11-05|09:08:24.1204682|27A39DB6:29131|    2|page 1:1286 (PR)|
2015-11-05|09:16:51.9503482|27A93685:28756|   27|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|09:17:20.8323482|27A66531:29265|   11|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|09:17:33.4863482|27A39DB6:29290|   10|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|09:17:45.7953482|27B4AE52:28844|    4|record 84:33701:0 (EX)|
2015-11-05|09:17:52.4543482|27A795F5:29212|    3|record 84:33701:0 (EX)|
2015-11-05|09:17:57.8513482|27A39DB6:29294|    4|record 84:33701:0 (EX)|
2015-11-05|09:18:04.5783482|27A39BA1:29270|    5|record 84:33701:0 (EX)|
2015-11-05|09:18:11.1543482|27A39DB6:29296|    9|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|09:46:54.2021582|27B4AE52:29121|   38|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|09:47:33.0621582|27A93685:29043|    4|record 84:33701:0 (EX)|
2015-11-05|09:47:39.7701582|27A39BA1:29550|    6|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|10:16:58.2793682|27A66531:29907|   23|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|10:17:22.9753682|27A39BA1:29925|    7|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|10:17:31.4313682|27A93685:29419|    2|record 84:33701:0 (EX)|
2015-11-05|10:48:18.3125782|27A39DB6:30451|    2|page 1:378 (PW)|
2015-11-05|11:17:16.3622382|27A66531:30813|   34|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|11:17:51.2052382|27A50083:30671|    8|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|11:18:00.8662382|27A39DB6:30849|   12|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|11:18:13.5832382|27A26F6E:31056|    4|record 84:33701:0 (EX)|
2015-11-05|11:18:42.5122382|27B3F949:31134|    2|page 1:378 (PW)|
2015-11-05|11:47:52.0025682|27B4AE52:30839|   38|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|12:08:03.4837382|27A93685:31061|    2|record 69:0:-4 (CW)|
2015-11-05|12:17:51.6477382|27A39BA1:31647|   20|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|12:47:44.4102282|27B4AE52:31469|   26|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|13:18:37.9869482|27A852D7:32176|   33|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|13:19:11.9780082|27A795F5:32243|   13|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|13:19:27.3505182|27B3F949:32520|    3|record 84:33701:0 (EX)|
2015-11-05|13:20:48.2525182|27B3F949:32533|    3|record 79:305211:0 (EX)|
2015-11-05|14:18:11.1709582|27B3F949:33183|   25|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|14:18:36.4989582|27A852D7:32841|    3|record 84:33701:0 (EX)|
2015-11-05|14:18:42.2829582|27A26F6E:33151|    4|record 84:33701:0 (EX)|
2015-11-05|14:46:00.3531882|27B4AE52:32851|    3|record 63:217115:0 (EX)|
2015-11-05|14:48:18.2231882|27A795F5:33214|   36|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|15:17:43.2841782|27A39BA1:33621|   13|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|15:17:57.6241782|27A26F6E:33857|   13|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|15:18:08.6201782|27A93685:33161|    2|record 63:217115:0 (EX)|
2015-11-05|15:18:11.7891782|27B4AE52:33279|    2|record 84:33701:0 (EX)|
2015-11-05|15:18:17.2421782|27A26F6E:33859|    3|record 84:33701:0 (EX)|
2015-11-05|15:47:25.2257682|27B3F949:34225|   28|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|15:47:54.0207682|27A66531:34014|    2|record 84:33701:0 (EX)|
2015-11-05|15:48:00.2707682|27A26F6E:34192|    4|record 84:33701:0 (EX)|
2015-11-05|15:48:25.1517682|27A852D7:33973|    2|page 1:378 (PW)|
2015-11-05|16:17:10.5120082|27A852D7:34099|   30|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|16:17:46.3450082|27A795F5:34169|    7|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|17:16:46.2761382|27A795F5:34352|   32|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|17:17:19.9551382|27A39DB6:34382|    2|record 84:33701:0 (EX)|
2015-11-05|17:17:23.2351382|27A93685:33882|    8|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|17:46:48.8739982|27A66531:34338|   35|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|18:06:04.8745382|27A66531:34358|   20|database key scope (PR)|*Exceeded Send*
2015-11-05|18:17:07.3468482|27A93685:33928|   39|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|18:17:47.8868482|27A39BA1:34396|    4|record 84:33701:0 (EX)|
2015-11-05|18:17:53.8358482|27A66531:34371|    2|record 84:33701:0 (EX)|
2015-11-05|18:17:56.5238482|27A39DB6:34426|    2|record 84:33701:0 (EX)|
2015-11-05|18:47:26.6881082|27A26F6E:34568|    2|record 84:33701:0 (EX)|
2015-11-05|19:47:33.6987982|27A50083:34254|   29|record 84:33701:0 (EX)|*Exceeded Send*
2015-11-05|20:17:28.1509382|27A50083:34264|    2|record 84:33701:0 (EX)|
2015-11-05|20:17:32.8609382|27B3F949:34619|    2|record 84:33701:0 (EX)|
2015-11-05|20:17:35.3979382|27A795F5:34435|    2|record 84:33701:0 (EX)|
2015-11-05|20:17:41.1859382|27A852D7:34364|    2|record 84:33701:0 (EX)|
2015-11-05|20:17:46.7609382|27A66531:34397|    2|record 84:33701:0 (EX)|
------------------------------------------------------------------------------------------------------------------------------------
Total number of stall groups:      72
Total number of stall seconds:    772

 6-NOV-2015 05:00:15.54 *Stall times exceeded C170_DB L15S58 20151105*
 6-NOV-2015 05:00:15.54 *Stall times send     C170_DB L15S58 20151105*
</pre> 

<p>
  In this case index/logical_area_84 clearly has a contention problem which 
  can be explained by it's prefix cardinalities and physical index structure.
</p>

<pre>
Prefix Cardinalities For Index C170_GLOB_ACTIVE_CPLNG_IDX
Duplicates Allowed
Table Cardinality: 3982663
Index Cardinality: 4
--------------------------------------------------------------------------------
84|SYS_P00084|Sorted Ranked|1988|C170_DATA_IDX|6|Uniform|4|1988|
--------------------------------------------------------------------------------
1        C170_GLOB_ACTIVE_CPLNG_IND     0
--------------------------------------------------------------------------------
</pre>

  The index contains only four distinct values.<br>

<pre>
------------------------------------------------------------------------------
 Indices for database  - DISK$DATA_25:[C170_DB]C170_DB.RDB;
 Created  9-NOV-2015 12:23:43.19
------------------------------------------------------------------------------
 Index C170_GLOB_ACTIVE_CPLNG_IDX for relation C170 duplicates allowed
 Max Level: 2, Nodes: 5, Used/Avail: 4140/9780 (42%), Keys: 8, Records: 0
     Duplicate nodes: 2935, Used/Avail: 4421958/5740860 (77%), Keys: 4, Maps: 2952, Records: 3982710

     Level: 2, Nodes: 1, Used/Avail: 70/1956 (3%), Keys: 4, Records: 0
     Level: 1, Nodes: 4, Used/Avail: 4070/7824 (52%), Keys: 4, Records: 0
------------------------------------------------------------------------------
</pre>

  The physical index structure has only five nodes.<br>

<pre>
Node: L15S58 (1/6/6)   Oracle Rdb V7.2-500 Perf. Monitor 10-NOV-2015 11:23:23.49
Rate: 1.00 Second           Logical Area Statistics     Elapsed: 392 12:39:05.10
Page: 1 of 1          DISK$DATA_25:[C170_DB]C170_DB.RDB;1           Mode: Online
--------------------------------------------------------------------------------
               Btree C170_GLOB_ACTIVE_CPLNG_IDX in C170_DATA_IDX
statistic.........      rate.per.second............. total....... average......
name..............      max..... cur..... avg....... count....... per.trans....
  
node fetches                   0        0        0.0       954394           0.0
 leaf fetches                  0        0        0.0         1645           0.0
 dup. fetches                  0        0        0.0       951317           0.0
index lookups                  0        0        0.0            0           0.0
index scans                    0        0        0.0         1434           0.0
 primary entries               0        0        0.0            0           0.0
 dup. entries                  0        0        0.0            0           0.0
node insertions                0        0        0.0       440336           0.0
 root insertions               0        0        0.0            0           0.0
 leaf insertions               0        0        0.0            0           0.0
 dup. insertions               0        0        0.0       440336           0.0
node creations                 0        0        0.0          242           0.0
 root splits                   0        0        0.0            0           0.0
 leaf creations                0        0        0.0            0           0.0
--------------------------------------------------------------------------------
</pre>

<p>
  The number of index scans per day is very low, so as global conclusion,
  the index C170_GLOB_ACTIVE_CPLNG_IDX is a candidate to be dropped, or
  extended with other columns, or fusioned with another index, depending
  on the application logic and behavior.  
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.2 -- Index Design Guidelines
</font>
</h3>

<p>
The runtime use of a sorted index can be seen as a vertical descent from
the top level node to the level one base, followed by a horizontal scan
across the leaf nodes. The overall goal of the tuning effort is to
make this 'triangle' as small as possible, reading as few index nodes as
possible, starting from which data the optimizer 'knows' about, out of
the analysis of the query.
</p>

<p>
A number of best practice rules apply.
</p>

<p>
  Select a limited number of queries to tune for, based on frequency,
  business impact, online human users, batch jobs required elapsed time,
  actual io behavior, user complaints etc. The indices cannot match 
  every possible query that may be active on the database.
</p>

<p>
  Try to split up the queries in 'type of access' groups that serve a
  clearly different access path, and design a suitable index for each group:
  daytime online versus nighttime batch mode, per business department etc.
</p>

<p>
  (Especially online) queries should be able to be resolved within the 
  index. That is, all columns of the WHERE clause should be present in the
  index, so that there is no need to read data to evaluate a single
  condition. This is a common cause of elevated data reads. Data reads
  should only be done to return the actual results of the query, once the
  dbkey list is established. Successfull tuning of indices with more
  than 20 segments, including all 'indicator' columns, is feasible.
</p>

<p>
  Consider to limit the list of columns selected and/or add columns to the
  index so that a 'index only retrieval' is possible and avoid data reads
  completely. Be aware if the application logic relies on the uniqueness  
  of the index and eventualy add a (verb time) unique constraint for
  the initial segments.
</p>

<p>
  Evaluate the need for a ORDER BY clause as this forces the build of the
  complete result set before returning the rows, unless a suitable index
  provides the ordering. Eventually move the ordering to the application
  code.
</p>

<p>
  Avoid indices where the leading segments have a low cardinality as they have
  a low selectivity and will cause too many leaf level nodes (primary entries)
  to be read. (Runtime triangle too large).
</p>

<p>
  Avoid multiple indices with only one or a few columns that have
  a low cardinality. They cause contention on insert/update and may
  confuse the dynamic optimizer to consider them a possible path that will
  be abandoned anyway, and results in wasted io.
</p>

<p>
  Avoid multiple similar indices with the same leading segments, as they may
  all (falsely) look attractive to the dynamic optimizer and result in wasted
  io.
</p>

<p>
  Create all (at least duplicates allowed) indices as SORTED RANKED and  
  choose a node size equal to the max segment size. For example, node 
  size 1988 for a 4 blocks page size is a good default to start with. 
  Take also into account the buffer size and disk cluster size.
</p>

<p>
  [Although in general physically bigger, SORTED RANKED indices have
  a number of advantages. All nodes, including duplicate nodes, have the
  same size. Duplicate dbkeys are stored in compressed bitmaps and long
  chains of small duplicate nodes at the leaf level are avoided.
  Each node contains (not 100% exact) information about the number of
  nodes and dbkeys 'below', so that the optimizer can make a better choice
  for a index in the 'Estim' phase, where the top levels of 'interesting'
  indices are read. The leaf level nodes contain the exact dbkey counts,
  used in SELECT COUNT queries.]
</p>

<p>
  Avoid placement via hashed indices unless realy required for performance,
  when the data has to be fetched in one single IO.
  Consider 'non placement via' hashed indices in separate mixed areas,
  in parallel to uniform data areas. They provide more flexibility
  to recreate in case mixed areas become too full, and page collisions  
  start to hamper performance. The cost is on average one more IO to fetch the
  data row but this may be acceptable in many cases.
</p>

<p>
  The ordering of the index segments is crucial, and this is the toughest part.
</p>

<p>
  Place columns with a equality condition first, from low cardinality to 
  high cardinality or from high selectivity to lower selectivity. 
  Columns used in small selective range specifications are also good
  candidates to come in the first group, and allow to eliminate the bulk of the
  data right from the start of the index traversal. For example
  FROM and TO validity dates, if the application always looks for recent data,
  and seldom considers historical data. 
</p>

<p>
  As a second group place columns with a non equality condition from low 
  cardinality to higher cardinality, to limit the index physical size. 
</p>

<p>
  As a third group place columns that are only there to complete the WHERE 
  clause and avoid data reads for their evaluation. At this point the bulk
  of the result set dbkeys should already have been established by the
  selection in group one and two. 
</p>
  
<p>
  The order of the segments within each column group in the index definition
  is subject to the testing. Test and retest every index change, with
  a data volume equivalent to production, using the procedures supplied
  in this chapter. On each iteration evaluate the optimizer strategy,
  performance data, prefix cardinalities, physical size, shape and number
  of levels for the candidate index. Use the CPTRDB_SELECT_GRPBY_GEN.COM
  procedure to investigate the cardinalities and data distribution
  of column groups. Experiment several column orders within the third group,
  as they can have a big impact on the physical structure and size
  of the index.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.3"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.3 -- Index Node Sizes
</font>
</h3>

<p>
<b>CPTRDB_INDEX_NODE_SIZES.COM</b><br>
  Calculate all index node sizes upto a maximum page size and a maximum target
  number of index nodes per page.
</p>
  
<pre>
Parameters: P1, integer, max page size blocks
            P2, integer, max target number of index nodes per page
</pre>

<p>
  Note that as of Rdb V7.2, the maximum buffer size is 128 blocks,
  the maximum page size is 63 blocks and the maximum number of global
  buffers is 1,048,576 (= POWER(2,20)).
  As of Rdb V7.3-100 the maximum buffer size is 256 blocks.
</p>

Usage:<br>

<pre>
$ @CPTRDB_INDEX_NODE_SIZES 12 4
</pre>

Output sample:<br>

<pre>
CPTRDB - Index Node Sizes
On Node L15S29
At 2016-01-19 13:03:04

   Page
   Size            Node
 Blocks   Bytes    Size
                      1       2       3       4 Number Of Nodes Per Page
--------------------------------------------------------------------------------
      1     512     452     221     144     105
      2    1024     964     477     314     233
      3    1536    1476     733     485     361
      4    2048    1988     989     656     489
      5    2560    2500    1245     826     617
      6    3072    3012    1501     997     745
      7    3584    3524    1757    1168     873
      8    4096    4036    2013    1338    1001
      9    4608    4548    2269    1509    1129
     10    5120    5060    2525    1680    1257
     11    5632    5572    2781    1850    1385
     12    6144    6084    3037    2021    1513
--------------------------------------------------------------------------------
</pre>

<p>
This table lists the index node sizes in function of the page size
and the target number of nodes per page, in a uniform page format storage 
area. For one node per page the index node size is the max segment size for 
this page size. 
</p>

<p>
The max segment size for a given page size is determined by the snaphot
page structure layout, as a snapshot page has a larger footer region (live page
pointer + 4 bytes, max tsn + 4 bytes) and a larger line index (live line 
pointer + 2 bytes) than a data page. So a data page with a max segment size
index node will always have 10 free bytes.
</p>

<p>
Data and snapshot page header, line index and footer layout structures for
a max segment size node size (1988 in a 4 blocks page):
</p>

Data page:<br>

<pre>
                   000D 0000000A  0000  page 10, physical area 13
                        26DE8637  0006  checksum = 26DE8637
               00B0205B D8B0C3CD  000A  time stamp = 22-DEC-2015 16:11:15.06
                       0000 000A  0012  10 free bytes, 0 locked
                            0001  0016  1 line
                       07C4 002A  0018  line 0: offset 002A, 1988 bytes

                        0025F3B5  001C  line 0: TSN 2487221

            00000000000000000000  0020  free space '..........'

                                  ....  total B-tree node size: 1988
                       001D 200D  002A  line 0 (13:10:0) index: set 29
........
                        0000002A  07EE  snap page pointer 42
                        0025F4D0  07F2  snap pointer TSN 2487504
                            001D  07F6  logical area 29
                        00000001  07F8  page sequence number 1
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
</pre>

Snap page:<br>

<pre>
                   400D 0000002A  0000  page 42, physical area 16397
                        D877C64D  0006  checksum = D877C64D
               00B0205B D8B075AD  000A  time stamp = 22-DEC-2015 16:11:15.06
                       0000 0000  0012  0 free bytes, 0 locked
                            0001  0016  1 line
                       07C4 0022  0018  line 0: offset 0022, 1988 bytes

                        0025F3B5  001C  line 0: TSN 2487221

                            0000  0020  line 0 -> live line: 0

                                  ....  total B-tree node size: 1988
                       001D 200D  0022  line 0 (13:10:0) index: set 29
.......
                        0000000A  07E6  live page pointer 10
                        0025F4D0  07EA  max TSN 2487504
                        FFFFFFFF  07EE  snap page pointer -1
                        00000000  07F2  snap pointer TSN 0
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
</pre> 

The overhead within a snapshot page consists of (in bytes):<br>

<pre>
. Fixed header: 24
. Fixed footer: 26
. Per line    : 10

For a 4 blocks page the max segment size is:
(512 * 4) - 24 - 26 - 10 = 1988

For a 6 blocks page the max segment size is:
(512 * 6) - 24 - 26 - 10 = 3012

For 2 nodes per page on a 4 blocks page, the node size is:
( (512 * 4) - 24 - 26 - (2 * 10) ) / 2 = 989

For 2 nodes per page on a 6 blocks page, the node size is:
( (512 * 6) - 24 - 26 - (2 * 10) ) / 2 = 1501

For 4 nodes per page on a 12 blocks page, the node size is:
( (512 * 12) - 24 - 26 - (4 * 10) ) / 4 = 1513.5 (trunced to 1513)
</pre>

<p>
Below the page header of a 4 blocks snapshot page with 2 index nodes of
988 bytes each. 
</p>

<pre>
                   4003 00000A6A  0000  page 2666, physical area 16387
                        8F8106E6  0006  checksum = 8F8106E6
               00B03305 670E6B98  000A  time stamp = 15-JAN-2016 10:10:19.79
                       0000 0002  0012  2 free bytes, 0 locked
                            0002  0016  2 lines
                       03DC 040A  0018  line 0: offset 040A, 988 bytes
                       03DC 002E  001C  line 1: offset 002E, 988 bytes

                        02246953  0020  line 0: TSN 35940691
                        02245086  0024  line 1: TSN 35934342

                            0000  0028  line 0 -> live line: 0
                            0001  002A  line 1 -> live line: 1

                            0000  002C  free space '..'

                                  ....  total B-tree node size: 988
                       005B 200D  002E  line 1 (3:823115:1) index: set 91
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.4"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.4 -- Logical Area Thresholds
</font>
</h3>

<p>
While discussing page structure layouts.
</p>

<p>
Logical area thresholds assist Rdb in the search for a feasible data page with
large enough free space when attempting to insert a new row.  
</p>

<p>
They allow to determine at which fullness percentage a data page will be 
considered full, and will no longer be a candidate page for inserts during
a search for free space.
</p>

<p>
They can also be used to reserve space for future in place growth of rows and
avoid fragmentation. [Once a dbkey is assigned to a data row, the dbkey never 
changes.]
</p>

<p>
Logical area thresholds are defined as a list of three integer values 
(T1,T2,T3) such as (70,80,90) which express a percentage of the maximum free 
space of a data page for a given storage area. 
</p>

<p>
The maximum free space can be retrieved as column RDB$MAX_PAGE_FREE_SPACE in 
the information table RDB$STORAGE_AREAS or as MAX_FREE_LEN in the output of 
RMU/DUMP/HEADER/OPTION=DEBUG {dbid}.
</p>

<p>
The maximum size of a segment that can be stored on a data page can be
retrieved as column RDB$MAX_SEGMENT_LENGTH in the information table
RDB$STORAGE_AREAS or as MAX_NEW_SEG_LEN in the output of
RMU/DUMP/HEADER/OPTION=DEBUG {dbid}.
</p>

<p>
The three values divide the data page in four fullness level areas 0,1,2,3
as illustrated below.
</p>

<pre>
---------------- Max free space ----
Fullness level 3 
---------------- Threshold % 3
Fullness level 2                <---- Actual fullness, Page threshold 2 
---------------- Threshold % 2
Fullness level 1 
---------------- Threshold % 1
Fullness level 0 
---------------- Data page base ----
</pre>

<p>
Depending on the location of the actual fullness of a data page within one of
the fullness areas, the 'page threshold' is said to be 0, 1, 2 or 3.
At threshold 3, a data page is considered full and is no longer a candidate
page for inserts.
</p>

<p>
For uniform page format storage areas the three values threshold list
(T1,T2,T3) is an attribute of each individual logical area (partition) within
the storage area.
</p>

<p>
For mixed page format storage areas the three values threshold list (T1,T2,T3)
is an attribute of the storage area and applies to all data pages across all
logical areas within the storage area.
</p>

<p>
The fullness threshold of each page is recorded in the Space Management SPAM
pages that describe the contents of a series of data pages (the SPAM interval). 
The first page of a storage area is always a SPAM page.
</p>

<p>
For uniform page format storage areas the SPAM page also indicates for each
'clump' to which logical area it belongs. A clump is the buffer size number of
pages and is the minimum allocation for a logical area.
</p>

<p>
[Note that in general, as to I/O size, Rdb reads buffers and writes pages.
Hence the (not enforced) requirement that the buffer size should be a multiple
of all pages sizes present across the database, in order to avoid the 
unefficient reading of buffers that are not completely filled. Multiples of 12
are popular buffer sizes as they allow for page sizes of 2, 3, 4, 6 and 12.]
</p>

<p>
In the SPAM page extract below, for a buffer size of 24 blocks and a page size
of 4 blocks, the clump size is 6 pages. 
</p>

<p>
Extracts of a SPAM page in a uniform page format storage area:
</p>

<pre>
-- The SPAM page has threshold and clump information
*------------------------------------------------------------------------------
                   0007 00000001  0000  page 1, physical area 7 (space mgmt)
                        3B927D97  0006  checksum = 3B927D97
               00000000 00000000  000A  time stamp = 17-NOV-1858 00:00:00.00
                       0000 0001  0012  1 free byte, 0 locked

00000000000000000FFF000000000FFF  0016  pages 2-7: threshold 3
                                        pages 8-25: threshold 0
                                        pages 26-31: threshold 3
                                        pages 32-65: threshold 0
00000000000000000000000000000000  0026  pages 66-129: threshold 0
......
                            0242  0379  578 clumps
                            0049  037B  pages 2-7, logical area 73
                            0049  037D  pages 8-13, logical area 73
                            8FA0  037F  pages 14-19, deleted by TID 4000
                            8FA0  0381  pages 20-25, deleted by TID 4000
                            0042  0383  pages 26-31, logical area 66
                            0042  0385  pages 32-37, logical area 66
                            0000  0387  pages 38-43, logical area 0
                            0000  0389  pages 44-49, logical area 0
......
*------------------------------------------------------------------------------
</pre>

<p>
Full dump of a SPAM page in a mixed page format storage area:
</p>

<pre>
-- The SPAM page has only threshold information and no clump information
*------------------------------------------------------------------------------
                   0004 00000001  0000  page 1, physical area 4 (space mgmt)
                        07B40005  0006  checksum = 07B40005
               00000000 00000000  000A  time stamp = 17-NOV-1858 00:00:00.00
                       0000 07B4  0012  1972 free bytes, 0 locked

00000000000000000000000000000000  0016  pages 2-65: threshold 0
00000000000000000000000000000000  0026  pages 66-129: threshold 0
00000000000000000000000000000000  0036  pages 130-193: threshold 0
                    000000000000  0046  pages 194-217: threshold 0

00000000000000000000000000000000  004C  MBZ free '................'
                                  ::::  (122 duplicate lines)
                        00000000  07FC  MBZ free '....'
*------------------------------------------------------------------------------
</pre>

<p>
The runtime use of the logical area thresholds can be expressed as:
'In order to insert a storage segment of this (compressed) length (including
overhead bytes, named NEED_LEN) I need to find a page that is not full and has
at least this free space available, which requires a maximum threshold of
2, 1 or 0'.
</p>

<p>
Rdb stores the thresholds as percentage of the maximum free space for a data
page in the metadata, but runtime calculates offsets into the free space per
threshold value as (T3(%) * MAX_FREE_SPACE) named SPAM_T3 and
(T2(%) * MAX_FREE_SPACE) named SPAM_T2, for easier comparison.
</p>

<p>
These byte counts are used in the algorithm below to determine the page
threshold to search for, based on: 'To fit into the free space available, the
maximum threshold should be one of (2,1,0)'.
Pages with a threshold of 3, are not considered as candidate pages for insert.
</p>

<pre>
if      (MAX_FREE_SPACE - NEED_LEN) >= SPAM_T3 then
  NEEDED_THRESHOLD = 2
else if (MAX_FREE_SPACE - NEED_LEN) >= SPAM_T2 then
  NEEDED_THRESHOLD = 1
else
  NEEDED_THRESHOLD = 0
;
</pre>

<p>
Below a not to scale graphical representation of a (60,80,90) threshold
for a maximum free space of 1000, and variable segment sizes.
</p>

<pre>
A  50 bytes segment requires a maximum threshold of 2.
A 150 bytes segment requires a maximum threshold of 1.
A 350 bytes segment requires a maximum threshold of 0.
A 450 bytes segment requires a maximum threshold of 0.

                                NEED_LEN
                                   50   150   350   450
----------- MAX_FREE_SPACE 1000 ----- ----- ----- -----
                                  |     |     |     |
Threshold 3                     <----   |     |     |
                                        |     |     |
----------- T3% 90  SPAM_T3 900         |     |     |
                                        |     |     |
Threshold 2                           <----   |     |
                                              |     |
----------- T2% 80  SPAM_T2 800               |     |
                                              |     |
Threshold 1                                 <----   |
                                                    |
----------- T1% 60          600                     |
                                                    |
Threshold 0                                       <----

----------- Data page base    0
</pre>

<p>
The three threshold percentage values are in general calculated based on the
minimum, average and maximum (compressed) length of the storage segments that
have to be stored in this (uniform) logical area or (mixed) storage area.
</p>

<p>
In uniform page format storage areas the default is (0,0,0). For mixed
page format storage areas the default is (70,85,95).
</p>

<p>
The actual threshold values can be observed as columns RDB$THRESHOLD1_PERCENT,
RDB$THRESHOLD2_PERCENT and RDB$THRESHOLD3_PERCENT in the information tables
RDB$LOGICAL_AREAS and RDB$STORAGE_AREAS.
</p>

<p>
For (uniform) logical areas in the dump of the AIP Area Inventory Pages: 
</p>

<pre>
$ RMU/Dump/Larea=RDB$AIP {dbid} 

                                        entry #6
                        00000002  0186  first area bitmap page 2
                       0007 0049  018A  logical area 73, physical area 7
                              0B  018E  area name length 11 bytes
000000000049545241505F454C424154  018F  area name 'TABLE_PARTI.....'
  000000000000000000000000000000  019F  area name '...............'
                        001E8EE0  01AE  snaps enabled TSN 2002656
                            001A  01B2  record length 26 bytes
                        00000004  01B4  entry resides on page 4
                              01  01B8  entry is in use
                            0000  01B9  MBZ '..'
                          000000  01BB  thresholds are (0,0,0)
                              00  01BE  MBZ '.'
                              01  01BF  record type data table
                              00  01C0  MBZ '.'
</pre>

<p>
For (uniform) logical areas using:
</p>

<pre>
$ RMU/Show AIP {dbid} {l_area_name} 
$ RMU/Show AIP {dbid} /Larea={l_area_id} 

Logical area name TABLE_PARTI
Type: TABLE
Logical area 73 in uniform physical area 7
Physical area name DATA_AREA_11
Record length: 26
Thresholds are (0, 0, 0)
AIP page number: 4
ABM page number: 2
Snapshot Enabled TSN: 2002656
</pre>

<p>
For mixed page format storage areas, in the output of: 
</p>

<pre>
$ RMU/Dump/Header/Options=Debug {dbid}

      - Thresholds are 70%, 85%, and 95%
THRESHOLD = (70., 85., 95.)
</pre>

<p>
When no thresholds are specfied for (uniform) logical areas, which defaults to
(0,0,0), Rdb calculates one single offset value T1=T2=T3 into the free space as
</p>

<pre>
MAX_FREE_SPACE - {record_length}
</pre>

<p>
The {record_length} is the nominal record length (including overhead bytes) as
stored in the AIP pages and listed in RMU/Show AIP for the logical area.
</p>

<p>
Default, the threshold of a uniform page changes from 0 to 3 when the total
number of bytes used exceeds this limit.
</p>

<p>
So default and also when only one threshold value is specified as (T1,100,100)
only two fullness level areas are definded, 0 for "free space available" and
3 for "full"
</p>

<p>
Default (0,0,0)
</p>

<pre>
---------------- Max free space  ----
Fullness level 3                     <-- Nominal record length
---------------- Computed by Rdb ----
Fullness level 0 
---------------- Data page base  ----
</pre>

<p>
(T1,100,100)
</p>

<pre>
---------------- Max free space  ----
Fullness level 3                     <-- Avg compressed length
---------------- Threshold % 1   ----
Fullness level 0 
---------------- Data page base  ----
</pre>

<p>
[For mixed page format storage areas which host a hashed index or have a
PLACEMENT VIA hashed index storage map specified, the relational engine 
provides, on insert, a target page to the storage subsystem. For uniform
page format storage areas no target page is being used. (Even for PLACEMENT VIA
sorted index storage maps, where an attempt is made to store an index node
as close as possible to it's adjacent nodes ?)]
</p>

<p>
For uniform page format storage areas (and mixed page format storage areas
without a target page ?), when looking for free space to insert a row, 
Rdb scans the space management SPAM pages in forward direction, starting from 
the latest insert or delete location for this user and logical area, or pages 
in the user's buffers, or the first SPAM interval and data pages for the 
storage area.
</p>

<p>
For uniform page format storage areas, the forward search uses the information 
from the AIP Area Inventory Pages and ABM Area Bitmap Pages to quickly identify
the SPAM pages of interest for this logical area, and the clump information 
in the SPAM pages to locate the individual pages of the logical area.
</p>

<p>
[As of Rdb V7.2-00, the forward search for free space in a uniform page format
storage area has been optimized for users on the same node. See the release
note at the end of this chapter.]
</p>

<p>
For mixed page format storage areas where a candidate page is specified, 
Rdb starts the search from the target page supplied by the relational 
interface, applying a 'First Fit, Closest to Candidate' algorithm, alternating
buffer reads after and before the candidate buffer, for all pages in the SPAM
interval of the target page.
</p>

<p>
The search consists in looking for a page with the needed threshold in the 
SPAM page, where the actual (compressed) length of the storage segment fits 
into the free space available length as defined by the thresholds. 
</p>

<p>
If the (compressed) row fits on the candidate page, the row is inserted, 
otherwise the 'Pages Checked' statistic is incremented, and the search 
continues across the next SPAM intervals in forward direction, for both
uniform and mixed page format storage areas.
</p>

<p>
If, for a uniform page format storage area the end of the storage area has 
been reached, and no feasible page has been found across all SPAM intervals to
store the new row, the storage area is extended and a new clump (buffersize
number of pages) is allocated to the logical area to insert the row.
</p>

<p>
If, for a mixed page format storage area with a target page specified, 
the end of the storage area has been reached, the search switches to the first
SPAM interval of the storage area, and continues upto the SPAM interval of the
target page. If still unsuccessful, the storage area is extended to store the
row.
</p>

<p>
In a second step, the fullness threshold in the SPAM page has to be updated,
for the data page that hosted the insert. 
</p>

<p>
If no logical area thresholds are defined, the single threshold computed by Rdb 
based on the nominal record length applies. If the nominal record length still
fits, the threshold in the SPAM page remains at 0, otherwise the threshold in
the SPAM page is updated to 3, and the data page is considered full and no
longer available for inserts.  
</p>

<p>
If logical area thresholds are defined, the threshold in the SPAM page is 
updated according to the location of the new actual fullness of the page
within the defined fullness level areas. 
</p>

<p>
Assuming no free space reservation for future in place growth of the rows, 
and a threshold of (T1,100,100) based on the average compressed length, the
SPAM page threshold is updated to 3 (full) only if the free space on the
page is now smaller than the average compressed length of a row for this 
logical area. 
</p>

<p>
Below a not to scale, graphical representation of a (T1,100,100) logical area
threshold for a 4 blocks data page, and a average compressed row length of 97
bytes.
</p>

<pre>
-------------- RDB$MAX_PAGE_FREE_SPACE   2006
               RDB$MAX_SEGMENT_LENGTH    1988

(1 row)        average compressed length   97

-------------- logical area threshold %    95
                                           trunc(((2006 - 97)/2006) * 100)

(19 rows)

-------------- data page (4 blocks)         0
</pre>

<p>
In order to fill data pages upto a maximum number of rows, calculate the T1 
logical area threshold percentage as: 
</p>

<pre>
trunc(((max_free_space - avg_compressed_length) / max_free_space) * 100)
</pre>

<p>
To define a (T1,T2,T3) threshold, repeat this calculation using the
minimum, average and maximum (compressed) lengths of the data segments
to be stored.
</p>

<p>
For uniform page format storage areas the RDB$MAX_SEGMENT_LENGTH is a few 
bytes smaller and more conservative than the RDB$MAX_PAGE_FREE_SPACE but
yields similar threshold percentages. 
</p>

<p>
Lower the logical area T3 threshold percentage, if free space has to be reserved
for future in place growth of the rows and avoid fragmentation, starting from
the theoretical expected number of (compressed) rows and the (compressed) 
extension length per row on the data page.
</p>

<p>
Note that if no logical area thresholds are defined, each data page will have
a left over unused free space of approximately the nominal uncompressed
length of a row for this logical area. This may not be acceptable for 'long'
rows that on average have a high degree of compression, and will leave
a lot of space spoiled.
</p>

<p>
Use the procedure CPTRDB_DBKEYS_GROUPBY_PAGE.COM to investigate the
distribution of the data rows of a single table across the pages of it's
logical area(s). Observe one individual page using CPTRDB_SHOW_ONE_PAGE.COM
</p>

<p>
For uniform page format storage areas, the logical area thresholds are
specified in the SQL [CREATE|ALTER] STORAGE MAP statements:
</p>

<pre>
CREATE STORAGE MAP {map_name}
FOR {table_name}
COMPRESSION ENABLED
STORE IN {storage_area_name}
         (THRESHOLDS ARE ({integer},{integer},{integer}));
</pre>

<p>
The parentheses around the THRESHOLDS ARE clause indicate that the threshold
only applies to this single storage area.
</p>

<p>
In the ALTER STORAGE MAP statement the THRESHOLDS clause can only be specified
for new storage areas that are added to the storage map, and not for storage
areas that are already part of the storage map. 
</p>

<p>
Note that, as opposed to popular belief, LIST OF BYTE VARYING (segmented
string, blob), by definition uncompressed data with variable segment sizes, do
NOT have to be stored in mixed page format storage areas, in order to apply
(T1,T2,T3) logical area thresholds. The [CREATE|ALTER] STORAGE MAP STORE LISTS
statement for the single lists storage map, accepts a threshold clause for 
logical areas in uniform storage areas, as illustrated in the mini test below.
</p>

<pre>
create database file boem.rdb
create storage area lists_area;
create table tab1 (col1 list of byte varying as text);

create storage map lists_map
store lists
in lists_area (thresholds are (70,80,90)) for (tab1.col1)
in rdb$system;

commit;
</pre>

<p>
$ rmu/show aip boem.rdb rdb$segmented_strings
</p>

<pre>
Logical area name RDB$SEGMENTED_STRINGS
Type: LARGE OBJECT
Logical area 58 in uniform physical area 2
Physical area name LISTS_AREA
Record length: 155
Thresholds are (70, 80, 90)
AIP page number: 3
ABM page number: 2
Snapshot Enabled TSN: 34
</pre>

<p>
The RMU/Set AIP command is used to modify some attributes of an existing
logical area. It cannot be used to add or delete a logical area.
This command can be used to correct the record length, thresholds
and name of a logical area described by an AIP entry. It can also
be used to rebuild the SPAM pages for a logical area stored in
UNIFORM page format areas so that threshold settings for a page
correctly reflect the definition of the table.
</p>

<p>
See also the RMU/Repair Spam command for information on
rebuilding SPAM pages for MIXED areas.
</p>

<pre>
[From the Rdb V7.2-00 Release Notes:

2.1.5 Deleted Space in Uniform Areas Not Reclaimed by Other Users

In prior releases of Oracle Rdb, when rows were deleted from a table stored 
in a uniform storage area, other database users would not be aware that space 
was made available and could extend the storage area when inserting additional
rows in the table even though free space was available.

This release of Oracle Rdb introduces a mechanism that allows database users 
on the same cluster node to share information regarding the availability of 
free space. 

When a user chooses a location to store new rows, the location is stored in 
the database global section so that other users can use that location as a 
starting point when searching for available space. When a user deletes rows 
from a table, if the location of the deleted rows is closer to the beginning 
of the storage area than the last page used for an insert then the starting 
page for the next insert is updated to the location of the lowest page that had 
rows deleted.]
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.5"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.5 -- Scanning Space Management SPAM Pages
</font>
</h3>

<p>
For uniform page format storage areas, when scanning the SPAM pages of
interest for a particular logical area, Rdb runs across three levels of
information, to achieve this in the most efficient way.
</p>

<p>
The logical area RDB$AIP located in the RDB$SYSTEM storage area, contains the 
AIP Area Inventory Pages which list per storage_area/logical_area pair the first
ABM Area Bitmap Page for this logical area.
</p>

Observe the AIP Area Inventory Pages using:<br>

<pre>
$ RMU/DUMP/LAREA=RDB$AIP

                                        entry #6
                        00000002  0186  first area bitmap page 2
                       0007 0049  018A  logical area 73, physical area 7
                              0B  018E  area name length 11 bytes
000000000049545241505F454C424154  018F  area name 'TABLE_PARTI.....'
  000000000000000000000000000000  019F  area name '...............'
                        001E8EE0  01AE  snaps enabled TSN 2002656
                            001A  01B2  record length 26 bytes
                        00000004  01B4  entry resides on page 4
                              01  01B8  entry is in use
                            0000  01B9  MBZ '..'
                          000000  01BB  thresholds are (0,0,0)
                              00  01BE  MBZ '.'
                              01  01BF  record type data table
                              00  01C0  MBZ '.'
</pre>

<p>
The bitmaps in the ABM Area Bitmap Pages list the SPAM pages of interest that 
contain threshold and clump information for this logical area in the current 
storage area.
</p>

Observe the first ABM Area Bitmap Page using:<br>

<pre>
$ @CPTRDB_SHOW_ONE_PAGE cptrdb_db_1 7 2 data 

                   0007 00000002  0000  page 2, physical area 7
                        4309F376  0006  checksum = 4309F376
               00ADA4A0 F2BEDFB8  000A  time stamp =  4-OCT-2013 15:43:34.52
                       0000 0004  0012  4 free bytes, 0 locked

                        00000003  0016  next area bitmap page 3
                        00000000  001A  max set bit index 0
                        00000000  001E  MBZ '....'
                        00003E60  0022  bitvector count 15968

00000000000000000000000000000001  0026  bitvector '................'
00000000000000000000000000000000  0036  bitvector '................'
                                  ::::  (122 duplicate lines)
        000000000000000000000000  07E6  bitvector '............'

                        00000000  07F2  MBZ '....'

                            8049  07F6  bitmap page for logical area 73
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
</pre>

<p>
Finally the Space Management SPAM pages list the threshold and clump 
information. 
</p>

<p>
Note that the first page of a storage area is always a SPAM page. The first 
clump starting with page 2 contains always ABM pages.
</p>

Observe the first SPAM page using:<br>

<pre>
$ @CPTRDB_SHOW_ONE_PAGE cptrdb_db_1 7 1 data 

                   0007 00000001  0000  page 1, physical area 7 (space mgmt)
                        E7A27C96  0006  checksum = E7A27C96
               00000000 00000000  000A  time stamp = 17-NOV-1858 00:00:00.00
                       0000 0001  0012  1 free byte, 0 locked

00000000000000000FFF000FFF000FFF  0016  pages 2-7: threshold 3
                                        pages 8-13: threshold 0
                                        pages 14-19: threshold 3
                                        pages 20-25: threshold 0
                                        pages 26-31: threshold 3
                                        pages 32-65: threshold 0
00000000000000000000000000000000  0026  pages 66-129: threshold 0
00000000000000000000000000000000  0036  pages 130-193: threshold 0
...
00000000000000000000000000000000  0356  pages 3330-3393: threshold 0
00000000000000000000000000000000  0366  pages 3394-3457: threshold 0
                          000000  0376  pages 3458-3469: threshold 0

                            0242  0379  578 clumps
                            0049  037B  pages 2-7, logical area 73
                            0049  037D  pages 8-13, logical area 73
                            8F4C  037F  pages 14-19, deleted by TID 3916
                            8FA0  0381  pages 20-25, deleted by TID 4000
                            0042  0383  pages 26-31, logical area 66
                            0042  0385  pages 32-37, logical area 66
                            0000  0387  pages 38-43, logical area 0
                            0000  0389  pages 44-49, logical area 0
                            0000  038B  pages 50-55, logical area 0
...
                            0000  07F9  pages 3452-3457, logical area 0
                            0000  07FB  pages 3458-3463, logical area 0
                            0000  07FD  pages 3464-3469, logical area 0

                              00  07FF  MBZ free '.'
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.6"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.6 -- Procedures Usage
</font>
</h3>

<p>
<b>CPTRDB_UNLOAD.COM</b><br>
  RMU/Unload one or more tables of a database in delimited text format.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------
$ dbid           = "CPTRDB_DB_1"
$ tabid          = "TABLE_PARTI"
$ trans_type     = "READ_ONLY"
$ optim_type     = "SEQUENTIAL"
$ stats_interval = "6"
$!------------------------------
</pre>

<p>
  The unload and record definition output files are created in the 
  CPT$RDB_DATA directory.
</p>

<p>
<b>CPTRDB_UNLOAD_GEN.COM</b><br>
  Generate a DCL command procedure to RMU/Unload all user tables in delimited
  text format for a given database.<br>
  Eventually delete the unloaded rows.
</p>

<pre>
Parameters: P1, dbid, varchar(255)
</pre>

  Usage:<br> 

<pre>
$ @CPTRDB_UNLOAD_GEN {dbid}

$ @CPTRDB_UNLOAD_GEN cptrdb_db_1
Output
CPT$RDB:UNL456_UNL_CPTRDB_DB_1_L15S29_20190802.COM_02AUG162456
CPT$RDB:UNL456_UNL_CPTRDB_DB_1.COM
</pre>

  Output sample:<br>

<pre>
$!
$! Generated By CPTRDB On Node L15S29 At 2019-08-02 16:24:56
$! For Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$!
$ set nover
$ on error then goto exit_procedure
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$ set output_rate=00:00:05
$!
$ say := write sys$output
$!
$ set proc/name="CPTRDB UNL"
$ show process
$ say " "
$!
$ dbid   = "CPTRDB_DB_1"
$ datdir = "CPT$RDB_DATA:"
$!
$ limit_to            = "100"
$ optimize            = "SEQUENTIAL"
$ statistics_interval = "5"
$ debug_options       = "OFFSET"
$!
$! -- if /DELETE_ROWS
$ transaction_type = "PROTECTED"
$ commit_every     = "10"
$ row_count        = "10"
$ flush            = "ON_COMMIT"
$!
$ say "-- 1 --"
$ say "-- ''f$time()' --"
$ say "-- TABLE_PARTI --"
$ say " "
$!
$ rmu/unload -
  /virtual_fields -
  /record_definition=( -
  file='datdir'TABLE_PARTI.RRD, -
  format=delimited_text, prefix="", suffix="", separator="|", -
  terminator="#", null="NULL", trim=trailing) -
  /debug_options=('debug_options') -
  /transaction_type='transaction_type' -
  /optimize='optimize'  -
  /statistics_interval='statistics_interval' -
  /limit_to='limit_to' -
  /delete_rows -
  /commit_every='commit_every' -
  /row_count='row_count' -
  /flush='flush' -
  'dbid' -
  TABLE_PARTI -
  'datdir'TABLE_PARTI.UNL
$ say " "
$!
...
$exit_procedure:
$ set nover
$ exit
</pre>

  Run logfile sample:<br>

<pre>
$ @cptrdb_submit l15s29 UNL456_UNL_CPTRDB_DB_1
$ Logfile CPT$RDB_LOGS:UNL_CPTRDB_DB_1_L15S29_20190802.LOG_02AUG162944

-- 1 --
--  2-AUG-2019 16:29:44.72 --
-- TABLE_PARTI --

%RMU-I-DATRECERA,   100 data records erased.
%RMU-I-DATRECUNL,   100 data records unloaded  2-AUG-2019 16:29:44.86.
 
-- 2 --
--  2-AUG-2019 16:29:44.88 --
-- TABLE_PLACE --

%RMU-I-DATRECERA,   100 data records erased.
%RMU-I-DATRECUNL,   100 data records unloaded  2-AUG-2019 16:29:45.09.
 
-- 3 --
--  2-AUG-2019 16:29:45.11 --
-- TABLE_TRACE --

%RMU-I-DATRECERA,   0 data records erased.
%RMU-I-DATRECUNL,   0 data records unloaded  2-AUG-2019 16:29:45.21.
</pre> 

<p>
<b>CPTRDB_LOAD.COM</b><br>
  RMU/Load one or more 'non placement via' tables of a database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------------------------------------------------------
$ dbid           = "CPTRDB_DB_1"
$ tabid          = "TABLE_PARTI"
$ trans_type     = "EXCLUSIVE"
$ commit_step    = "250"
$ stats_interval = "ON_COMMIT"
$ unl_file       = "CPT$RDB_DATA:TABLE_PARTI_L15S29_20150609.UNL_09JUN131423"
$!------------------------------------------------------------------------------
</pre>
 
<p>
  The load and record definition input files are read from the CPT$RDB_DATA 
  directory. 
  The eventual exception file is created in the CPT$RDB_DATA directory.
</p>

<p>
<b>CPTRDB_LOAD_GEN.COM</b><br>
  Generate a DCL command procedure to RMU/Load all user tables from delimited
  text format data for a given database.
</p>

<pre>
Parameters: P1, dbid, varchar(255)
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_LOAD_GEN {dbid}

$ @CPTRDB_LOAD_GEN cptrdb_db_1
Output
CPT$RDB:LOAD56_LOAD_CPTRDB_DB_1_L15S29_20190805.COM_05AUG144052
CPT$RDB:LOAD56_LOAD_CPTRDB_DB_1.COM
</pre>

  Output sample:<br>

<pre>
$!
$! Generated By CPTRDB On Node L15S29 At 2019-08-05 14:40:52
$! For Database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$!
$ set nover
$ on error then goto exit_procedure
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$ set output_rate=00:00:05
$!
$ say := write sys$output
$!
$ set proc/name="CPTRDB LOAD"
$ show process
$ say " "
$!
$ dbid   = "CPTRDB_DB_1"
$ datdir = "CPT$RDB_DATA:"
$!
$ limit_to            = "100"
$ transaction_type    = "PROTECTED"
$ commit_every        = "50"
$ row_count           = "50"
$ statistics_interval = "ON_COMMIT"
$!
$ say "-- 1 --"
$ say "-- ''f$time()' --"
$ say "-- TABLE_PARTI --"
$ say " "
$!
$ rmu/load/log -
  /record_definition=( -
  file='datdir'TABLE_PARTI.RRD, -
  format=delimited_text, prefix="", suffix="", separator="|", -
  terminator="#", null="NULL", -
  exception='datdir'TABLE_PARTI.EXC) -
  /limit_to='limit_to' -
  /transaction_type='transaction_type' -
  /commit_every='commit_every' -
  /row_count='row_count' -
  /log_commits -
  /statistics_interval='statistics_interval' -
  'dbid' -
  TABLE_PARTI -
  'datdir'TABLE_PARTI.UNL
$ say " "
$!
...
$exit_procedure:
$ set nover
$ exit
</pre>

  Run logfile sample:<br>

<pre>
$ @cptrdb_submit l15s29 LOAD56_LOAD_CPTRDB_DB_1
Logfile CPT$RDB_LOGS:LOAD_CPTRDB_DB_1_L15S29_20190805.LOG_05AUG144607

-- 1 --
--  5-AUG-2019 14:46:07.96 --
-- TABLE_PARTI --

%RMU-I-DATRECSTO,   50 data records stored  5-AUG-2019 14:46:08.08.
--------------------------------------------------------------------------------
 ELAPSED:    0 00:00:00.08  CPU: 0:00:00.06  BUFIO: 91  DIRIO: 83  FAULTS: 751 
 50 data records read from input file.
  50 records loaded before last commit.
  0 records loaded in current transaction.
  0 records written to exception file before last commit.
  0 records written to exception file in current transaction.
--------------------------------------------------------------------------------
%RMU-I-DATRECSTO,   100 data records stored  5-AUG-2019 14:46:08.09.
--------------------------------------------------------------------------------
 ELAPSED:    0 00:00:00.09  CPU: 0:00:00.06  BUFIO: 91  DIRIO: 85  FAULTS: 762 
 100 data records read from input file.
  100 records loaded before last commit.
  0 records loaded in current transaction.
  0 records written to exception file before last commit.
  0 records written to exception file in current transaction.
--------------------------------------------------------------------------------

-- 2 --
--  5-AUG-2019 14:46:08.11 --
-- TABLE_PLACE --

%RMU-I-DATRECSTO,   50 data records stored  5-AUG-2019 14:46:08.23.
--------------------------------------------------------------------------------
 ELAPSED:    0 00:00:00.07  CPU: 0:00:00.08  BUFIO: 67  DIRIO: 54  FAULTS: 713 
 50 data records read from input file.
  50 records loaded before last commit.
  0 records loaded in current transaction.
  0 records written to exception file before last commit.
  0 records written to exception file in current transaction.
--------------------------------------------------------------------------------
%RMU-I-DATRECSTO,   100 data records stored  5-AUG-2019 14:46:08.25.
--------------------------------------------------------------------------------
 ELAPSED:    0 00:00:00.09  CPU: 0:00:00.09  BUFIO: 67  DIRIO: 184  FAULTS: 721 
 100 data records read from input file.
  100 records loaded before last commit.
  0 records loaded in current transaction.
  0 records written to exception file before last commit.
  0 records written to exception file in current transaction.
--------------------------------------------------------------------------------
...
</pre>

<p>
<b>CPTRDB_LOAD_PLACE.COM</b><br>
  RMU/Load one or more 'placement via hashed index' tables of a database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------------------------------------------------------
$ dbid           = "CPTRDB_DB_1"
$ tabid          = "TABLE_PLACE"
$ trans_type     = "EXCLUSIVE"
$ commit_step    = "250"
$ stats_interval = "ON_COMMIT"
$ unl_file       = "CPT$RDB_DATA:TABLE_PLACE_L15S29_20150609.UNL_09JUN124016"
$!------------------------------------------------------------------------------
</pre>

<p>
  The load and record definition input files are read from the
  CPT$RDB_DATA directory.
  The intermediate PLACE_ONLY output/input file is created/read in the
  CPT$RDB_DATA directory.
  The eventual exception file is created in the CPT$RDB_DATA directory.
</p>

<p>
<b>CPTRDB_COLLECT_OPTIMIZER_STAT.COM</b><br>
  RMU/Collect optimizer statistics for a hardcoded database, table and/or index.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------
$ dbid       = "CPTRDB_DB_1"
$ tableid    = "TABLE_PLACE"
$ indexid    = "TABLE_PLACE_HDX"
$ trans_type = "READ_ONLY"
$!------------------------------
</pre>

<p>
<b>CPTRDB_SHOW_OPTIMIZER_STAT.COM</b><br>
  Interactive list the optimizer statistics for one database and table.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_OPTIMIZER_STAT {dbid} {table name}
</pre>

<p>
<b>CPTRDB_PREFIX_CARDINALITY.COM</b><br>
  List the index prefix cardinalities for all indices of one table 
  for a single database.
</p>

<p>
  The prefix cardinality is the number of unique values for segment1,
  segment1 and segment2 combined, segment1 segment2 segment3 combined, etc.
  This is a measure for the selectivity of the segment order.
</p>

  Interactive usage:<br>

<pre>
$ @CPTRDB_PREFIX_CARDINALITY {dbid} {table name}
</pre>

  The procedure lists also per partition:<br>

<pre>
  Logical area id
  Partition name
  Index type
  Node size
  Storage area name
  Storage area id
  Page format
  Page size
  Max segment length
</pre>

  Output sample:<br>

<pre>
Prefix Cardinalities For Index CLIO_LNK_KEYS_HDX
Unique
Table Cardinality: 9262609
--------------------------------------------------------------------------------
92|SYS_P00092|Hashed Scattered|215|CLIO_LNK_KEYS_MIXED|12|Mixed|4|1988|
--------------------------------------------------------------------------------
1        LNK_KEY_ID                     0
--------------------------------------------------------------------------------

Prefix Cardinalities For Index CLIO_LNK_KEYS_INTRN_KEY_IDX
Duplicates Allowed
Table Cardinality: 9262609
Index Cardinality: 6664328
--------------------------------------------------------------------------------
89|SYS_P00089|Sorted Ranked|988|CLNTS_SIDS|3|Uniform|4|1988|
--------------------------------------------------------------------------------
1        INTRN_KEY_ID                   3485319
2        INTRN_KEY_TYPE_ID              3485319
3        XTRN_KEY_TYPE_ID               0
--------------------------------------------------------------------------------
</pre>

<p>
  Note that INTRN_KEY_TYPE_ID has only one distinct value, as the prefix
  cardinality remains unchanged.
</p>

<p>
<b>CPTRDB_ANALYZE_INDEX.COM</b><br>
  RMU/Analyze one or more indices for a single database
  and list their physical structure, size and levels.


  The /PARTITIONS qualifier is a new feature in Rdb v7.3
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------
$ dbid       = "CPTRDB_DB_1"
$ idx1       = "TABLE_PARTI_IDX"
$ idx2       = "TABLE_PLACE_HDX"
$ trans_type = "READ_ONLY"
$!------------------------------
</pre>

<p>
<b>CPTRDB_ANALYZE_AREA.COM</b><br>
  RMU/Analyze one or more storage areas for a single database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------
$ dbid   = "CPTRDB_DB_1"
$ sarea1 = "DATA_AREA_11"
$ sarea2 = "DATA_AREA_12"
$ sarea3 = "INDEX_AREA_1"
$!-----------------------
</pre>

<p>
<b>CPTRDB_ANALYZE_PLACEMENT.COM</b><br>
  RMU/Analyze/Placement one hardcoded 'placement via' hashed index for a
  single database and evaluate the minimum and maximum number of io's
  required to read a data row.

  The /PARTITIONS qualifier is a new feature in Rdb v7.3 .
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------
$ dbid  = "CPTRDB_DB_1"
$ hdxid = "TABLE_PLACE_HDX"
$!-------------------------
</pre>

<p>
<b>CPTRDB_DBKEYS_GROUPBY_PAGE.COM</b><br>
  List the row dbkeys counts, group by page and average number of rows per
  page for a single database and hardcoded table.

  Refer to the chapter
  <a href="#Chapter 34">§ -- 34 -- Placement Via Hashed Index And Vertical/Horizontal Partitioning</a> 
  for more details on this procedure.
</p>

<p>
<b>CPTRDB_SELECT_GRPBY_GEN.COM</b><br>
  Generate a DCL/SQL command procedure to list the GROUP BY counts
  for a given database of one table and up to 4 of it's columns.

  The generated procedure can be submitted in batch, unchanged with no editing
  required, using CPTRDB_SUBMIT.COM.

  The goal is to provide data distribution information on the number
  of unique values, when investigating (the order of) index segments.
</p>

  Usage interactive:<br>

<pre>
Parameters: P1  dbid
            P2  table name
            P3  column name 1
            P4  [NONE | column name 2]
            P5  [NONE | column name 3]
            P6  [NONE | column name 4]

All six parameters are required.
</pre>

  Usage for one column:<br>

<pre>
$ @CPTRDB_SELECT_GRPBY_GEN {dbid} {table} {col1}  none none none
</pre>

<p>
  Two identical command files are generated, named<br> 
  GRPBY6_GRPBY_{table_name}.COM, to be submitted in batch<br>
  GRPBY6_GRPBY_{table_name}.COM_ddmmmhhmmss, for later reference<br>

  The char(7) prefix "GRPBY6_" is stripped off by CPTRDB_SUBMIT.COM 
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} GRPBY6_GRPBY_{table_name}
</pre>

  The log and output filenames adhere to the toolset naming conventions:<br>
  GRPBY_{table_name}_{nodeid}_yyyymmdd.LOG_ddmmmhhmmss in CPT$RDB_LOGS:<br>
  GRPBY_{table_name}_{nodeid}_yyyymmdd.LIS_ddmmmhhmmss in CPT$RDB_LISTS:<br>

<p>
Run and output samples:
</p>

<p>
$ @CPTRDB_SELECT_GRPBY_GEN cptrdb_db_1 table_parti col2 none none none<br>
Output CPT$RDB:GRPBY6_GRPBY_TABLE_PARTI.COM[_12AUG111841]
</p>

<pre>
$ set nover
$ on error then goto exit_procedure
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$ set output_rate=00:00:05
$!
$ say := write sys$output
$!
$ outdir = "CPT$RDB_LISTS:"
$!
$ set proc/name="CPTRDB GRPBY"
$ show process
$ say " "
$!
$ @sys$share:rdb$setver 7.3
$ say " "
$!
$ dbid  = "CPTRDB_DB_1"
$ tabid = "TABLE_PARTI"
$!
$ define sql$database -
  DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$!
$ nodeid = f$getsyi("nodename")
$!
$ refdate  = f$cvtime("today","comparison","date")
$ yyyy_ref = f$extract(0,4,"''refdate'")
$ mm_ref   = f$extract(5,2,"''refdate'")
$ dd_ref   = f$extract(8,2,"''refdate'")
$ refout   = yyyy_ref + mm_ref + dd_ref
$!
$ dd_out  = f$cvtime("today","comparison","day")
$ mmm_out = f$cvtime("today","absolute",  "month")
$ hh_out  = f$cvtime(,"comparison","hour")
$ mm_out  = f$cvtime(,"comparison","minute")
$ ss_out  = f$cvtime(,"comparison","second")
$ dateout = dd_out + mmm_out + hh_out + mm_out + ss_out
$!
$ filename = "GRPBY_''tabid'_''nodeid'_''refout'"
$ filename = f$extract(0,39,"''filename'")
$!
$ define rdms$debug_flags_output 'outdir''filename'.LIS_'dateout'
$ sql := $sql$
$ sql

set flags 'trace, noprefix'

declare transaction read only;

-- set noexecute;

begin

declare :grp_cnt   integer = 0;
declare :total_cnt integer = 0;

trace ' ';
trace 'GROUP BY Counts';
trace 'For Table   ','TABLE_PARTI                    ';
trace 'And Columns ','COL2                           ';
trace '            ','NONE                           ';
trace '            ','NONE                           ';
trace '            ','NONE                           ';
trace 'For Database';
trace 'DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1                                  ';
trace 'On Node ','L15S29';
trace 'At ', current_date, ' ', current_time;

trace '------------------------------------------------------------------',
'--------------';

for :rec1 as select
 count(*) as cnt
,COL2
from TABLE_PARTI
group by
 COL2
-- having count(*) > 1000
do
  set :grp_cnt   = :grp_cnt + 1;
  set :total_cnt = :total_cnt + :rec1.cnt;

  trace
    substring(right_align(:rec1.cnt) from 6 for 7), '|'
   ,:rec1.COL2                           , ' ';

end for;

trace '------------------------------------------------------------------',
'--------------';

trace 'Total Number of Groups: ', substring(right_align(:grp_cnt)   from 6 for 7);
trace 'Total Number of Rows:   ', substring(right_align(:total_cnt) from 6 for 7);
trace ' ';

end;

$!
$ set file/trunc 'outdir''filename'.lis_'dateout'
$!
$ username = f$getjpi("","username")
$ reply/user='username' -
      "Output ''outdir'''filename'.LIS_''dateout'"
$!
$ say "Output ''outdir'''filename'.LIS_''dateout'"
$ say " "
$!
$exit_procedure:
$ deass sql$database
$ deass rdms$debug_flags_output
$ set nover
$ exit
</pre>

<p>
$ @cptrdb_submit l15s29 GRPBY6_GRPBY_TABLE_PARTI<br>
Logfile CPT$RDB_LOGS:GRPBY_TABLE_PARTI_L15S29_20160812.LOG_12AUG111924<br>
Output CPT$RDB_LISTS:GRPBY_TABLE_PARTI_L15S29_20160812.LIS_12AUG111924
</p>

<pre>
GROUP BY Counts
For Table   TABLE_PARTI
And Columns COL2
            NONE
            NONE
            NONE
For Database
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
On Node L15S29
At 2016-08-12 11:19:24
--------------------------------------------------------------------------------
    275|azertyuiop
      1|bbbbb
     23|qsdfghjklm
--------------------------------------------------------------------------------
Total Number of Groups:       3
Total Number of Rows:       299
</pre>

<p>
<b>CPTRDB_CREATE_INDEX.COM</b><br>
  (Re)Create one or more (candidate) indices for a single database.
  Be sure to execute drop and create in separate sql sessions to
  reclaim free space.

  Extract index definitions into the CPT$RDB_DATA directory using
  CPTRDB_EXTRACT_ONE_OBJECT.COM
</p>

<p>
<b>CPTRDB_QUERY.COM</b><br>
  List optimizer strategy and performance data for a single query and database.

  Fit the test query sql source into the procedure and submit in batch
  to register the job statistics, next to the query statistics.

  The most usefull debugflags are activated and recorded in the
  output file FLAGS_{dbid}_{node}_yyyymmdd.LIS_ddmmmhhmmss.
</p>

  The activated debug flags are:<br>

<pre>
  -- Always
  database
  transaction
  chrono_flag(2)
  strategy
  detail(2)
  execution(5)
  request_names
  index_partitions

  -- Eventually
  estimates
  outline

  -- For ALTER STORAGE MAP
  stomap_stats
  index_stats
</pre>

<p>
  Study the flags output file until you realy understand in which way the 
  query is being resolved !

  Below an example of a bad strategy that reads all client addresses
  sequentially and the outline to cure the problem. The culprit is
  that the selectivity of the last name is ignored by the optimizer,
  and the addresses table contains 2.6+ million rows.

  The query in human words is:
  "How many customers live in postal code '1300' with a last name starting
   with 'D' and a first name starting wit 'SY' ?"

  Always rephrase a query request in human words until the customer agrees,
  before writing any code !
</p>

<pre>
 ATTACH #1,  6-JUL-2012 12:52:45.03     ~S#0009
Tables:
  0 = CLIO_CLNTS
  1 = CLIO_CLNT_ADR
  2 = CLIO_CITIES
Aggregate: 0:COUNT (0.CLNT_ID)
             Bool: NOT MISSING (0.CLNT_ID)
Conjunct: <agg1> <> 0
Match    (Agg Outer Join) 
  Outer loop 
    Sort: 0.CLNT_ID(a)
    Conjunct: (0.LAST_NAME STARTING WITH 'D') AND (0.FIRST_NAME STARTING WITH 
              'SY')
    Leaf#01 BgrOnly 0:CLIO_CLNTS Card=3066154
      Bool: 0.BLCKNG_TYPE_ID <> 1
      BgrNdx1 CLIO_CLNTS_LASTFIRST_BIRTH_IDX [1:1] Fan=12
        Keys: 0.LAST_NAME STARTING WITH 'D'
        Bool: 0.FIRST_NAME STARTING WITH 'SY'
    (index scan#2)
  Inner loop 
    Aggregate: 1:COUNT-ANY (<subselect>)
    Sort: 1.CLNT_ID(a)
    Conjunct: 1.CITY_ID = 2.CITY_ID
    Match 
      Outer loop 
        Sort: 2.CITY_ID(a)
        Leaf#03 BgrOnly 2:CLIO_CITIES Card=71015
          Bool: 2.POST_CD = '1300'
          BgrNdx1 CLIO_CITIES_POSTCD_IDX [1:1] Fan=33
            Keys: 2.POST_CD = '1300'
        (index scan#4)
      Inner loop 
        Temporary relation 
        Sort: 1.CITY_ID(a)
        Conjunct: 1.VLDTY_ADR_FLG = 'N'
        Get     Retrieval sequentially of relation 1:CLIO_CLNT_ADR 

...

create outline OUTLINE_ONLINE_ADDRESSES
id '10DD250FD2118C3299BA791F5DC335F8'
mode 0
as (
  query (
    subquery (
      CLIO_CLNTS 0       access path index       CLIO_CLNTS_LASTFIRST_BIRTH_IDX
        join by cross to
      CLIO_CLNT_ADR 1    access path index       CLIO_CLNT_ADR_CLNT_HDX
        join by cross to
      CLIO_CITIES 2      access path index       CLIO_CITIES_IDX
      )
    )
  )
compliance mandatory;
</pre>

<p>
<b>CPTRDB_CLIO_FULL_ADDRESS.COM</b><br>
  List full addresses for a given last name from the clio database.
</p>

<p>
  This template procedure illustrates the use of nested FOR loops, and taking 
  into account existing indices, for a request logic similar to the query
  above, to obtain lightning fast performance. Basically it applies the
  strategy of the outline, but with a lot more of flexibility than a
  single sql join statement.

  Make sure to apply the most selective condition in the outer loop
  (here last_name, which the optimizer failed to determine) and join to the 
  inner loops using the indices available.

  This approach also allows to apply more complex logic that cannot
  be expressed in a single sql (join) statement, the use of intermediate 
  results in temporary tables or singleton selects as is done here
  on the countries table.
</p>

  The strategy is:<br>

<pre>
 ATTACH #1,  7-AUG-2014 12:23:08.37
~T Compile transaction (4) on db: 1
~T Transaction Parameter Block: (len=2)
0000 (00000) TPB$K_VERSION = 1 
0001 (00001) TPB$K_READ (read only)
 ATTACH #1,  7-AUG-2014 12:23:08.40     ~S#0007
Tables:
  0 = CLIO_COUNTRIES
Firstn: 1
Get     Retrieval by index of relation 0:CLIO_COUNTRIES
  Index name  CLIO_COUNTRIES_IDX [1:1]  (index scan#1)   Direct lookup 
    Keys: 0.CNTRY_ID = <var0>
 ATTACH #1,  7-AUG-2014 12:23:08.40     ~S#0008
Tables:
  0 = CLIO_CITIES
Conjunct: 0.POST_CD = <var0>
Get     Retrieval by index of relation 0:CLIO_CITIES
  Index name  CLIO_CITIES_IDX [1:1]     (index scan#1)   Direct lookup 
    Keys: 0.CITY_ID = <var1>
 ATTACH #1,  7-AUG-2014 12:23:08.40     ~S#0009
Tables:
  0 = CLIO_CLNT_ADR
Sort: 0.VLDTY_DATE(d)
Leaf#01 BgrOnly 0:CLIO_CLNT_ADR Card=2615217
  Bool: (0.CLNT_ID = <var0>) AND (0.VLDTY_ADR_FLG = 'N')
  BgrNdx1 CLIO_CLNT_ADR_CLNT_HDX [1:1] Fan=1
    Keys: 0.CLNT_ID = <var0>
(index scan#2)
 ATTACH #1,  7-AUG-2014 12:23:08.40     ~S#0010
Tables:
  0 = CLIO_CLNTS
Sort: 0.FIRST_NAME(a), 0.CLNT_ID(a)
Leaf#01 BgrOnly 0:CLIO_CLNTS Card=2640406
  Bool: 0.LAST_NAME = <var0>
  BgrNdx1 CLIO_CLNTS_LASTFIRST_BIRTH_IDX [1:1] Fan=12
    Keys: 0.LAST_NAME = <var0>
(index scan#2)
 ATTACH #1,  7-AUG-2014 12:23:08.41
~T Start_transaction (4) on db: 1, db count=1
~Estim  CLIO_CLNTS_LASTFIRST_BIRTH_IDX Ranked: Nodes=12, Min=109, Est=174 True > Mixed IO=0
~Estim  RLEAF Cardinality=  2.2814170E+06
~E#0010.01(1) Estim   Index/Estimate 1/174
~E#000A.2 Start Area CLIO_CLNTS_LASTFIRST_BIRTH_IDX (0)
~E#0010.01(1) BgrNdx1 EofData  DBKeys=202  Fetches=0+0  RecsOut=0 #Bufs=202
~E#0010.01(1) Fin     Buf      DBKeys=202  Fetches=0+0  RecsOut=202
~Estim  CLIO_CLNT_ADR_CLNT_HDX Hashed: Nodes=0, Est=1 Precise IO=0
~E#0009.01(1) Estim   Index/Estimate 1/1
~E#0009.2 Start Area CLIO_CLNT_ADR_CLNT_HDX (0)
~E#0009.01(1) BgrNdx1 EofData  DBKeys=1  Fetches=0+0  RecsOut=0 #Bufs=1
~E#0009.01(1) Fin     Buf      DBKeys=1  Fetches=0+0  RecsOut=1
~Estim  CLIO_CLNT_ADR_CLNT_HDX Hashed: Nodes=0, Est=1 Precise IO=0
~E#0009.01(2) Estim   Index/Estimate 1/1
~E#0009.2 Start Area CLIO_CLNT_ADR_CLNT_HDX (0)
~E#0009.01(2) BgrNdx1 EofData  DBKeys=1  Fetches=0+0  RecsOut=0 #Bufs=1
~E#0009.01(2) Fin     Buf      DBKeys=1  Fetches=0+0  RecsOut=1
~Estim  CLIO_CLNT_ADR_CLNT_HDX Hashed: Nodes=0, Est=1 Precise IO=0
~E#0009.01(3) Estim   Index/Estimate 1/1
~E#0009.2 Start Area CLIO_CLNT_ADR_CLNT_HDX (0)
~E#0009.01(3) BgrNdx1 EofData  DBKeys=1  Fetches=0+0  RecsOut=0 #Bufs=1
~E#0009.01(3) Fin     Buf      DBKeys=1  Fetches=0+0  RecsOut=1
~Estim  CLIO_CLNT_ADR_CLNT_HDX Hashed: Nodes=0, Est=1 Precise IO=0
~E#0009.01(4) Estim   Index/Estimate 1/1
~E#0009.2 Start Area CLIO_CLNT_ADR_CLNT_HDX (0)
~E#0009.01(4) BgrNdx1 EofData  DBKeys=1  Fetches=0+0  RecsOut=0 #Bufs=1
~E#0009.01(4) Fin     Buf      DBKeys=1  Fetches=0+0  RecsOut=1
~Estim  CLIO_CLNT_ADR_CLNT_HDX Hashed: Nodes=0, Est=2 Precise IO=0
~E#0009.01(5) Estim   Index/Estimate 1/2
~E#0009.2 Start Area CLIO_CLNT_ADR_CLNT_HDX (0)
~E#0009.01(5) BgrNdx1 EofData  DBKeys=2  Fetches=0+0  RecsOut=0 #Bufs=2
~E#0009.01(5) Fin     Buf      DBKeys=2  Fetches=0+0  RecsOut=1
...
 ATTACH #1,  7-AUG-2014 12:23:08.82
~T Commit_transaction (4) on db: 1
</pre>

  The job performance results on the nth run with data in the buffers:<br>

<pre>
  RDBMON       job terminated at  7-AUG-2014 12:23:08.87
  Accounting information:
  Buffered I/O count:                483      Peak working set size:      26992
  Direct I/O count:                  176      Peak virtual size:         238192
  Page faults:                      2649      Mounted volumes:                0
  Charged CPU time:        0 00:00:00.32      Elapsed time:       0 00:00:01.01
</pre>

<p>
  Well done Rdb !
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.7"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.7 -- Collect Optimizer Statistics
</font>
</h3>

<b>CPTRDB_COLLECT_STAT_BATCH.COM</b><br>
<b>CPTRDB_COLLECT_STAT_WEEKLY.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b><br>

<p>
The procedures in this chapter, allow to collect optimizer statistics at
regular time intervals for a series of databases.
</p>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_COLLECT_STAT_BATCH.COM</b><br>
Called from CPTRDB_COLLECT_STAT_WEEKLY.COM
</p>

<p>
  RMU/Collect cardinality and storage optimizer statistics for one database 
  on one node. The output file is default created in the CPT$RDB_ANA: directory.
</p>
  
<pre>
Parameters: P1, dbid,        varchar(255), database to be collected
            P2, Rdb version, char(3),      [7.2|7.3]
</pre>

  Output sample:<br>

<pre>
Start loading tables... at  4-OCT-2016 15:40:09.22
Done loading tables.... at  4-OCT-2016 15:40:09.25
Start loading indexes... at  4-OCT-2016 15:40:09.25
Done loading indexes.... at  4-OCT-2016 15:40:09.31
Start collecting btree index stats... at  4-OCT-2016 15:40:09.36
Done collecting btree index stats.... at  4-OCT-2016 15:40:09.39
Start collecting table & hash index stats... at  4-OCT-2016 15:40:09.39
Done collecting table & hash index stats.... at  4-OCT-2016 15:40:09.62
Start calculating stats... at  4-OCT-2016 15:40:09.62
Done calculating stats.... at  4-OCT-2016 15:40:09.62
Start writing stats... at  4-OCT-2016 15:40:09.64
...
------------------------------------------------------------------------------
 
Optimizer Statistics collected for table : TABLE_PARTI
 
  Cardinality            : 299                 
  Row clustering factor  : 0.0535117
 
Index name : TABLE_PARTI_IDX
  Index Cardinality      : 0                   
  Segment Column                 Prefix cardinality
    COL1                            299                 
    COL2                            0                   
  Average Depth          : 1.6666667
  Key clustering factor  : 0.0100334
  Data clustering factor : 0.0066890
 
------------------------------------------------------------------------------
 
Optimizer Statistics collected for table : TABLE_PLACE
 
  Cardinality            : 100                 
  Row clustering factor  : 15.0000000
 
Index name : TABLE_PLACE_HDX
  Index Cardinality      : 0                   
  Key clustering factor  : 1.0000000
  Data clustering factor : 1.0000000
 
------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_COLLECT_STAT_WEEKLY.COM</b><br>
Calls CPTRDB_COLLECT_STAT_BATCH.COM per database
</p>

<p>
  Weekly collect optimizer statistics for a series of databases, identified
  in the configuration file CPTRDB_CONFIGURATION.REF by the keywords
  CPT$RDB_DATABASE|CPTRDB_COLLECT_STAT
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_COLLECT_STAT|CPTRDB_DB_1|7.3|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_COLLECT_STAT
! 2 Database
! 3 Rdb version
! 4 Execution node
</pre>

<p>
  The reschedule node and reschedule time are retrieved from the configuration
  file CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|CPTRDB_COLLECT_STAT_WEEKLY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_COLLECT_STAT_WEEKLY|L15S29|TOMORROW +6-04:30|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_COLLECT_STAT_WEEKLY
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 38.8"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 38.8 -- Database Key Scope And RMU/Reclaim
</font>
</h3>

<b>CPTRDB_RECLAIM_AREA.COM</b><br>

<p>
The DBKEY SCOPE IS [TRANSACTION|ATTACH] clause in the SQL ATTACH string
for a user, determines if line numbers on data pages of the database can
be reused.
</p>

<p>
When a user is active in mode TRANSACTION, the default, the dbkey of a row 
deleted by this user can be reused by other users after the COMMIT of the 
current transaction.
</p>

<p>
[During a read write transaction the statement consistency and row level 
locking apply and a dbkey is only visible to the user handling this line.
Rdb does not implement 'dirty read' and prevents the visibility of uncommited
data to other users.] 
</p>

<p>
When the database key scope mode is set to ATTACH by any user of the database,
no line numbers on any page of the database will be reused.
</p>

<p>
The ATTACH mode guarantees to the user that a reread by dbkey of a row 
will return the data linked to this dbkey, or the updated value of the data
linked to this dbkey, or 'not found' if meanwhile the row has been deleted.
The line number will not be reused to store a different row on the page.
</p>
 
<p>
Note that the ATTACH mode is only useful if dbkeys are passed by the
application code from one code path to another across transaction boundaries.
</p>

<p>
In this context two rules are enforced. At any point in time all active users
must apply the same dbkey scope mode, and as soon as one (new) user becomes 
active in the ATTACH mode, all other active users have to switch to the
ATTACH mode. 
</p>

<p>
This negociation between users occurs on transaction boundaries and is 
implemented using the single 'database key scope lock'. Each user requests the 
database key scope lock in his 'intended' mode at the start of every read 
write transaction.
</p>

<p>
A user holding the lock in CW (Concurrent Write) is applying the TRANSACTION 
mode, which is the default, while a user requesting the lock in the 
incompatible PR (Protected Read) mode is asking to start a transaction in the 
ATTACH mode. 
</p>

<p>
In environments that (erroneously) allow the two modes to coexist, which should
be avoided, this negociation between users can lead to excessive stall times
'waiting for database key scope' as is illustrated in the stall log extract
below.
</p>

<pre>
26-OCT-2016 10:19:10.8507612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
   State... Process.ID Process.name... Lock.ID. Rq Gr Queue "database key scope"
   Blocker: 296005B6   SBN_LISA_0010   541F0C36    CW Grant
   Blocker: 296005B6   SBN_LISA_0010   1C2D9AA9    CW Grant
   Waiting: 29600688   SBN_LISA_0017   181B77AB PR    Wait
26-OCT-2016 10:19:11.8557612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:12.8577612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:13.8597612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:14.8617612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:15.8627612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:16.8647612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:17.8667612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:18.8687612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:19.8707612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
26-OCT-2016 10:19:20.8727612 29600688:3895 26-OCT-2016 10:19:09.9577612 waiting for database key scope (PR)
</pre>

<p>
The SBN_LISA_0017 process, requesting to start in ATTACH mode (PR), is stalled
for eleven seconds while the SBN_LISA_0010 process is active in TRANSACTION 
mode (CW). Once the SBN_LISA_0010 process terminates it's transaction and the 
SBN_LISA_0017 process has acquired the database key scope lock in PR, all 
other subsequent new transactions will have to switch to the ATTACH mode. 
</p>

<p>
The scenario below indicates that only the users who explicitly request the
ATTACH mode when they arrive on the database are holding the key scope lock in
Protected Read (PR). The existing default users in TRANSACTION mode, holding
the lock in Concurrent Write (CW), or new default users, are 'quietly' 
converted to the ATTACH mode and do not hold the key scope lock.
</p>

<p>
When the last ATTACH mode user has left the database, the default user also
'quietly' returns to the TRANSACTION mode, holding the key scope lock in
Concurrent Write (CW) after a subsequent read write transaction.
</p>

<pre>
Rdb V7.3-200

$ create/directory/owner=system {dev}:[MF_PERSONNEL]
$ set def {dev}:[MF_PERSONNEL]
$ @sql$sample:personnel sql m
$ define/sys/exec mfp_db {dev}:[MF_PERSONNEL]MF_PERSONNEL.RDB
$ rmu/open mfp_db

-- Session 1
$ @cptrdb_attach mfp_db
Default transaction is read only
SQL$DATABASE is MFP_DB
$ sql
SQL> set transaction read write;
SQL> commit;

$ rmu/show lock/resource_type=dbkey_scope mfp_db

--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 1,  Parent Lock ID: 3D0670A6,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F6116E4  23002D34  0001007B            CW        GRANT     23002D34  0001007B
--------------------------------------------------------------------------------

    - 1 active database user on this node
      - 2F6116E4:1 - _FTA4:, RDBMON
        - attached 25-JAN-2017 15:15:28.97 (elapsed 0 00:03:00)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE

-- Session 2
SQL> attach 'file mfp_db dbkey scope attach';
SQL> set transaction read write;
SQL> commit;

--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 1,  Parent Lock ID: 1A07360C,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------

    - 2 active database users on this node
      - 2F6116E4:1 - _FTA4:, RDBMON
        - attached 25-JAN-2017 15:15:28.97 (elapsed 0 00:08:01)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F611349:1 - _FTA5:, RDBMON
        - attached 25-JAN-2017 15:20:53.45 (elapsed 0 00:02:37)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE

-- Session 3
SQL> attach 'file mfp_db dbkey scope attach';
SQL> set transaction read write;
SQL> commit;

--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 2,  Parent Lock ID: 1A07360C,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F61184E  13061A59  0001007B            PR        GRANT     13061A59  0001007B
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 2,  Parent Lock ID: 1C041546,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F61184E  13061A59  0001007B            PR        GRANT     13061A59  0001007B
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------

    - 3 active database users on this node
      - 2F6116E4:1 - _FTA4:, RDBMON
        - attached 25-JAN-2017 15:15:28.97 (elapsed 0 00:13:04)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F611349:1 - _FTA5:, RDBMON
        - attached 25-JAN-2017 15:20:53.45 (elapsed 0 00:07:39)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F61184E:1 - _FTA6:, RDBMON
        - attached 25-JAN-2017 15:26:15.84 (elapsed 0 00:02:17)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE

-- Session 4
SQL> attach 'file mfp_db dbkey scope attach';
SQL> set transaction read write;
SQL> commit;

--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 3,  Parent Lock ID: 1A07360C,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F611CD6  74069C01  0001007B            PR        GRANT     74069C01  0001007B
2F61184E  13061A59  0001007B            PR        GRANT     13061A59  0001007B
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 3,  Parent Lock ID: 1C041546,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F611CD6  74069C01  0001007B            PR        GRANT     74069C01  0001007B
2F61184E  13061A59  0001007B            PR        GRANT     13061A59  0001007B
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 3,  Parent Lock ID: 20074ECE,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F611CD6  74069C01  0001007B            PR        GRANT     74069C01  0001007B
2F61184E  13061A59  0001007B            PR        GRANT     13061A59  0001007B
2F611349  150543CB  0001007B            PR        GRANT     150543CB  0001007B
--------------------------------------------------------------------------------

    - 4 active database users on this node
      - 2F6116E4:1 - _FTA4:, RDBMON
        - attached 25-JAN-2017 15:15:28.97 (elapsed 0 00:17:33)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F611349:1 - _FTA5:, RDBMON
        - attached 25-JAN-2017 15:20:53.45 (elapsed 0 00:12:09)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F61184E:1 - _FTA6:, RDBMON
        - attached 25-JAN-2017 15:26:15.84 (elapsed 0 00:06:47)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
      - 2F611CD6:1 - _FTA7:, RDBMON
        - attached 25-JAN-2017 15:30:38.21 (elapsed 0 00:02:24)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE

-- Session 4 
SQL> exit;

-- Session 3 
SQL> exit;

-- Session 2 
SQL> exit;

-- Session 1
SQL> set transaction read write;
SQL> commit;

--------------------------------------------------------------------------------
Resource Name: database key scope
Granted Lock Count: 1,  Parent Lock ID: 3D0670A6,   Lock Access Mode: Executive,
Resource Type: Global,  Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2F6116E4  11053E74  0001007B            CW        GRANT     11053E74  0001007B
--------------------------------------------------------------------------------

    - 1 active database user on this node
      - 2F6116E4:1 - _FTA4:, RDBMON
        - attached 25-JAN-2017 15:15:28.97 (elapsed 0 00:25:49)
        - image DSA2:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
</pre>

<p>
This means that the ATTACH mode may remain enforced on the whole database for 
a prolonged period until some point in time occurs where no users are 
active in ATTACH mode. Note that even when no ATTACH mode users are
active, not all line numbers of previous sessions will be reclaimed, depending 
on the ordinal position of the line (last line or not) and the type of
modification on the page (delete or update of a line with/without a change in
size of the row). This can be called a 'lazy garbage collection' by the
subsequent users after the last ATTACH mode user has left the database.   
</p>

<p>
The enforcement of the ATTACH mode has a direct impact on the layout structure
of data pages across the whole database. The 'not reuse' of line numbers
is implemented during the space and line reclamation of a target page that
hosted a subsequent successful modification or erase of storage segments. 
</p>

<p>
The garbage collection within a single data page consists of a number of
actions.
</p>

<p>
In both key scope mode TRANSACTION and ATTACH the data section of the page is
reclaimed and the locked space upfront the data section becomes free space.
</p>

<p>
In key scope mode TRANSACTION the line index entries of deleted lines that
were marked "locked by {TID}" are now marked "empty", the line and TSN index
entries are reclaimed if possible and their allocation is added to the free
space. The first available line number is assigned to a new line.
</p>

<p>
In key scope mode ATTACH the line and TSN index entries are NOT reclaimed and
the line index entries of deleted lines remain "locked by {TID}". The next
highest line number is assigned to a new line.
</p>

<p>
This difference in behavior of the garbage collection introduces the potential
for line and TSN index entries to pile up over time and occupy a significant
part of the data pages across the whole database, as soon as one or more 
ATTACH mode transactions are active on the database
</p>

<p>
[Note that the TID 'Transaction Identification Number' acronym is misleading
as it is basically a smallint ATTACH identifier which is recycled over time.
The TSN 'Transaction Sequence'Number' consists of two integer values and
is unique across the lifetime of the database or until the execution of 
RMU/Repair/Initialize=Tsns which causes a complete rewrite of all data pages 
across the whole database]
</p>

<p>
Refer to My Oracle Support Document Id 62672.1 'RDBPROD: Locked Free Space
Collection Algorithm for Oracle Rdb 7.X' for a in depth discussion of the
algorithms applied during the process of space and line reclamation of a
data page. 
</p>

<p>
The RMU/Reclaim command allows database keys of deleted rows to
be rapidly reset in one or more storage areas. The RMU Reclaim
command reads and updates all pages in a storage area, and, where
possible, releases locked lines and locked free space so that
they are available for later allocation.
</p>

<p>
The DELETE | INSERT | RMU/Reclaim scenario's below illustrate the structure layout
changes of a single data page in both dbkey scope modes TRANSACTION and ATTACH.
They are based on the example database MF_PERSONNEL where the favorite employee 
Toliver each time is dropped and recreated. 
</p>

<pre>
Rdb V7.3-200

$ create/directory/owner=system {dev}:[MF_PERSONNEL]
$ set def {dev}:[MF_PERSONNEL]
$ @sql$sample:personnel sql m
$ define/sys/exec mfp_db {dev}:[MF_PERSONNEL]MF_PERSONNEL.RDB
$ rmu/open mfp_db

$ deass sqlini
$ define sql$database mfp_db

SQL> @cptrdb_get_dcl_data
SQL> @sql$sample:info_tables
SQL> commit;

SQL> select dbkey from employees where LAST_NAME = 'Toliver';
                  DBKEY
                79:38:1

$ @CPTRDB_SHOW_AREAS_IDS mfp_db

--------------------------------------------------------------------------------
Sarea Larea   AIP Recrd Index  Hash Systm Segme
   Id    Id  Type  Type   Set Index Recrd Strng
--------------------------------------------------------------------------------
    2 EMPIDS_LOW
         79|    1|   32|     |     |     |     |EMPLOYEES
         76|    3|     |     |   76|     |     |EMPLOYEES_HASH
         85|    1|   35|     |     |     |     |JOB_HISTORY
         82|    3|     |     |   82|     |     |JOB_HISTORY_HASH
         57|    4|     |     |     |   57|     |RDB$SYSTEM_RECORD

SQL> sh trigger EMPLOYEE_ID_CASCADE_DELETE
...
  (DELETE FROM JOB_HISTORY JH WHERE JH.EMPLOYEE_ID =
   EMPLOYEES.EMPLOYEE_ID)
     FOR EACH ROW
...

$ @CPTRDB_SHOW_ONE_PAGE mfp_db 2 38 data

-- Original page
-- Employees   has 1 row
-- Job_history has 2 rows
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        00828729  0006  checksum = 00828729
               00B14955 2AEE0477  000A  time stamp =  3-JAN-2017 14:21:41.90
                       0000 064A  0012  1610 free bytes, 0 locked
                            0007  0016  7 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       0052 0788  001C  line 1: offset 0788, 82 bytes
                       0020 0768  0020  line 2: offset 0768, 32 bytes
                       002B 073C  0024  line 3: offset 073C, 43 bytes
                       0020 071C  0028  line 4: offset 071C, 32 bytes
                       0025 06F6  002C  line 5: offset 06F6, 37 bytes
                       005C 069A  0030  line 6: offset 069A, 92 bytes

                        000000C0  0034  line 0: TSN 192
                        00000060  0038  line 1: TSN 96
                        00000060  003C  line 2: TSN 96
                        000000C0  0040  line 3: TSN 192
                        000000C0  0044  line 4: TSN 192
                        000000C0  0048  line 5: TSN 192
                        000000C0  004C  line 6: TSN 192

00000000000000000000000000000000  0050  free space '................'
                                  ::::  (99 duplicate lines)
            00000000000000000000  0690  free space '..........'

                            2007  069A  line 6: duplicate hash node.
                                  ....  total duplicate node size: 92
              FFFF FFFFFFFF FFFF  069C  duplicate overflow -1:-1:-1
                            0010  06A4  hash duplicate list 16 bytes
              0055 00000026 0005  06A6   duplicate record 85:38:5
              0055 00000026 0003  06AE   duplicate record 85:38:3

                            0023  06F6  line 5 (57:38:5) record type 35
                         00 0001  06F8  Control information
                                  ....  32 bytes of static data
8E57000052474D443436313030000111  06FB   data '...00164DMGR..W.'
C838323230304E4D424D09008889B96D  070B   data 'm¹....MBMN00228È'
                              00  071B  padding '.'

                       0052 2005  071C  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 32
              FFFF FFFFFFFF FFFF  0720  bucket overflow -1:-1:-1
                              00  0728  flags 0
                        00000002  0729  duplicate count 2
              FFAE 00000026 0006  072D   duplicate node 82:38:6
                              06  0735   key len: 6 bytes
                    343631303000  0736   key: '.00164'

                            0023  073C  line 3 (57:38:3) record type 35
                         00 0001  073E  Control information
                                  ....  38 bytes of static data
2957C0004D4750533436313030000124  0741   data '$..00164SPGM.ÀW)'
4D42434D0089B8A463ED400000885D51  0751   data 'Q]...@íc¤¸..MCBM'
                    C03436313030  0761   data '00164À'
                              00  0767  padding '.'

                       004C 2005  0768  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 32
              FFFF FFFFFFFF FFFF  076C  bucket overflow -1:-1:-1
                              00  0774  flags 0
                        00000001  0775  duplicate count 1
              004F 00000026 0001  0779   pointer 79:38:1
                              06  0781   key len: 6 bytes
                    343631303000  0782   key: '.00164'

                            0020  0788  line 1 (57:38:1) record type 32
                         00 0001  078A  Control information
                                  ....  77 bytes of static data
86726576696C6F54343631303000010D  078D   data '...00164Toliver.'
5020363431411120846E69766C410420  079D   data ' .Alvin. .A146 P'
4307209B6563616C50206C6C656E7261  07AD   data 'arnell Place. .C'
31383330484E12208B6175726F636F68  07BD   data 'hocorua. .NH0381'
      00F03100630F72B31C00004D37  07CD   data '7M...³r.c.1ð.'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        FFFFFFFF  07EE  snap page pointer -1
                        000000C0  07F2  snap pointer TSN 192
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------

-- Dbkey scope transaction
-- Delete employees row
-- Job_history rows deleted by trigger

SQL> delete from employees where dbkey = _dbkey'79:38:1';
1 row deleted
SQL> commit;
%RDB-E-INTEG_FAIL, violation of constraint RESUMES_FOREIGN1 caused operation to fail
-RDB-F-ON_DB, on database DSA29:[MF_PERSONNEL_DB]MF_PERSONNEL.RDB;1
SQL> rollback;

SQL> alter table resumes disable constraint RESUMES_FOREIGN1;
SQL> commit;
SQL> exit;

SQL> delete from employees where dbkey = _dbkey'79:38:1';
1 row deleted
SQL> commit;

$ @CPTRDB_SHOW_ONE_PAGE mfp_db 2 38 data

-- Page after delete
-- Only system record and hash buckets remain
-- The deleted line index entries are marked "locked by {TID}"
--                                offset set to "0000"
--                                length set to TID of delete attach
-- The locked space is moved upfront the data section
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        A8959E54  0006  checksum = A8959E54
               00B14957 C7D4518B  000A  time stamp =  3-JAN-2017 14:40:24.13
                       0124 064A  0012  1610 free bytes, 292 locked
                            0007  0016  7 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       000F 0000  001C  line 1: locked by 15
                       000D 07CC  0020  line 2: offset 07CC, 13 bytes
                       000F 0000  0024  line 3: locked by 15
                       000D 07BE  0028  line 4: offset 07BE, 13 bytes
                       000F 0000  002C  line 5: locked by 15
                       000F 0000  0030  line 6: locked by 15

                        000000C0  0034  line 0: TSN 192
                        00000166  0038  line 1: TSN 358
                        00000166  003C  line 2: TSN 358
                        00000166  0040  line 3: TSN 358
                        00000166  0044  line 4: TSN 358
                        00000166  0048  line 5: TSN 358
                        00000166  004C  line 6: TSN 358

000F000F000F000F000F000F000F000F  0050  locked space '................'
                                  ::::  (17 duplicate lines)
                        000F000F  0170  locked space '....'
00000000000000000000000000000000  0174  free space '................'
                                  ::::  (99 duplicate lines)
            00000000000000000000  07B4  free space '..........'

                       0052 2005  07BE  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07C2  bucket overflow -1:-1:-1
                              00  07CA  flags 0
                              34  07CB  padding '4'

                       004C 2005  07CC  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07D0  bucket overflow -1:-1:-1
                              00  07D8  flags 0
                              34  07D9  padding '4'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        00000166  07F2  snap pointer TSN 358
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------

-- Dbkey scope transaction
-- Insert employees row on same page

SQL> insert into employees (employee_id,last_name) values ('00164','Toliver');
1 row inserted
SQL> commit;

$ @CPTRDB_SHOW_ONE_PAGE mfp_db 2 38 data

-- The successful insert causes garbage collection on the page
-- Line 1 is reused for the new data row (first available line)
-- Line 3 line index is marked "empty" 
--                   offset and length set to "0000"
-- Line 5 and 6 trailing line and TSN index entries are reclaimed
-- Locked space upfront the data section becomes free space 
-- The allocation of the reclaimed line and TSN entries is added to the free space
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        4BDCCFDA  0006  checksum = 4BDCCFDA
               00B1495A 79DE9FAB  000A  time stamp =  3-JAN-2017 14:59:41.83
                       0000 074A  0012  1866 free bytes, 0 locked
                            0005  0016  5 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       0022 078A  001C  line 1: offset 078A, 34 bytes
                       0020 07BA  0020  line 2: offset 07BA, 32 bytes
                       0000 0000  0024  line 3: empty
                       000D 07AC  0028  line 4: offset 07AC, 13 bytes

                        000000C0  002C  line 0: TSN 192
                        00000169  0030  line 1: TSN 361
                        00000169  0034  line 2: TSN 361
                        00000166  0038  line 3: TSN 358
                        00000166  003C  line 4: TSN 358

000F000F000F000F000F000F000F000F  0040  free space '................'
                                  ::::  (18 duplicate lines)
000000000000000000000000000F000F  0170  free space '................'
00000000000000000000000000000000  0180  free space '................'
                                  ::::  (95 duplicate lines)
            00000000000000000000  0780  free space '..........'

                            0020  078A  line 1 (57:38:1) record type 32
                         00 0001  078C  Control information
                                  ....  29 bytes of static data
86726576696C6F54343631303000010D  078F   data '...00164Toliver.'
      04F44E0200873F0020C8008920  079F   data ' ..È .?...Nô.'

                       0052 2005  07AC  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07B0  bucket overflow -1:-1:-1
                              00  07B8  flags 0
                              34  07B9  padding '4'

                       004C 2005  07BA  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 32
              FFFF FFFFFFFF FFFF  07BE  bucket overflow -1:-1:-1
                              00  07C6  flags 0
                        00000001  07C7  duplicate count 1
              004F 00000026 0001  07CB   pointer 79:38:1
                              06  07D3   key len: 6 bytes
                    343631303000  07D4   key: '.00164'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        00000169  07F2  snap pointer TSN 361
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------

-- Dbkey scope transaction
-- RMU/Reclaim after delete

$ rmu/reclaim/log/area=empids_low mfp_db
%RMU-I-RCLMAREA, Reclaiming area EMPIDS_LOW
%RMU-I-RCLMPRCT, 53 pages processed of 53 total pages for area EMPIDS_LOW, approximately 100 %
 ELAPSED:    0 00:00:00.01  CPU: 0:00:00.02  BUFIO: 26  DIRIO: 29  FAULTS: 258

$ @CPTRDB_SHOW_ONE_PAGE mfp_db 2 38 data

-- Page after RMU/Reclaim
-- RMU/Reclaim has the same effects as a subsequent successful insert
-- Line 1 is also marked "empty"
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        AD27900A  0006  checksum = AD27900A
               00B14A24 BE865557  000A  time stamp =  4-JAN-2017 15:07:35.35
                       0000 077E  0012  1918 free bytes, 0 locked
                            0005  0016  5 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       0000 0000  001C  line 1: empty
                       000D 07CC  0020  line 2: offset 07CC, 13 bytes
                       0000 0000  0024  line 3: empty
                       000D 07BE  0028  line 4: offset 07BE, 13 bytes

                        000000C0  002C  line 0: TSN 192
                        00000161  0030  line 1: TSN 353
                        00000161  0034  line 2: TSN 353
                        00000161  0038  line 3: TSN 353
                        00000161  003C  line 4: TSN 353

000B000B000B000B000B000B000B000B  0040  free space '................'
                                  ::::  (18 duplicate lines)
000000000000000000000000000B000B  0170  free space '................'
00000000000000000000000000000000  0180  free space '................'
                                  ::::  (98 duplicate lines)
    0000000000000000000000000000  07B0  free space '..............'

                       0052 2005  07BE  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07C2  bucket overflow -1:-1:-1
                              00  07CA  flags 0
                              34  07CB  padding '4'

                       004C 2005  07CC  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07D0  bucket overflow -1:-1:-1
                              00  07D8  flags 0
                              34  07D9  padding '4'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        00000161  07F2  snap pointer TSN 353
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------

-- Dbkey scope ATTACH 
-- From two different sessions
-- Session 1 remains on database

-- Session1
SQL> alter table resumes disable constraint RESUMES_FOREIGN1;
SQL> commit;
SQL> exit;

SQL> attach 'file mfp_db dbkey scope attach';
SQL> delete from employees where dbkey = _dbkey'79:38:1';
1 row deleted
SQL> commit;
-- Remains on database

-- Session 2
SQL> insert into employees (employee_id,last_name) values ('00164','Toliver');
1 row inserted
SQL> commit;

$ @CPTRDB_SHOW_ONE_PAGE mfp_db 2 38 data

-- Page after delete and insert 
-- The insert does not trigger garbage collection for the line and tsn index
-- The deleted line index extries remain "locked by {TID}"
-- The new row is inserted into the new line 7 (next highest line) 
-- The locked space becomes free space
-- The data section is reclaimed
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        26FE7981  0006  checksum = 26FE7981
               00B14961 20EE762B  000A  time stamp =  3-JAN-2017 15:47:19.09
                       0000 0732  0012  1842 free bytes, 0 locked
                            0008  0016  8 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       000B 0000  001C  line 1: locked by 11
                       0020 07BA  0020  line 2: offset 07BA, 32 bytes
                       000B 0000  0024  line 3: locked by 11
                       000D 07AC  0028  line 4: offset 07AC, 13 bytes
                       000B 0000  002C  line 5: locked by 11
                       000B 0000  0030  line 6: locked by 11
                       0022 078A  0034  line 7: offset 078A, 34 bytes

                        000000C0  0038  line 0: TSN 192
                        00000161  003C  line 1: TSN 353
                        00000163  0040  line 2: TSN 355
                        00000161  0044  line 3: TSN 353
                        00000161  0048  line 4: TSN 353
                        00000161  004C  line 5: TSN 353
                        00000161  0050  line 6: TSN 353
                        00000163  0054  line 7: TSN 355

000B000B000B000B000B000B000B000B  0058  free space '................'
                                  ::::  (16 duplicate lines)
00000000000B000B000B000B000B000B  0168  free space '................'
00000000000000000000000000000000  0178  free space '................'
                                  ::::  (96 duplicate lines)
                            0000  0788  free space '..'

                            0020  078A  line 7 (57:38:7) record type 32
                         00 0001  078C  Control information
                                  ....  29 bytes of static data
86726576696C6F54343631303000010D  078F   data '...00164Toliver.'
      04F44E0200873F0020C8008920  079F   data ' ..È .?...Nô.'

                       0052 2005  07AC  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07B0  bucket overflow -1:-1:-1
                              00  07B8  flags 0
                              34  07B9  padding '4'

                       004C 2005  07BA  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 32
              FFFF FFFFFFFF FFFF  07BE  bucket overflow -1:-1:-1
                              00  07C6  flags 0
                        00000001  07C7  duplicate count 1
              004F 00000026 0007  07CB   pointer 79:38:7
                              06  07D3   key len: 6 bytes
                    343631303000  07D4   key: '.00164'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        00000163  07F2  snap pointer TSN 355
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------

-- Dbkey scope ATTACH
-- RMU/Reclaim after delete/insert

$ rmu/reclaim/area=empids_low mfp_db/log
%RMU-I-RCLMAREA, Reclaiming area EMPIDS_LOW
%RMU-I-RCLMPRCT, 53 pages processed of 53 total pages for area EMPIDS_LOW, approximately 100 %
 ELAPSED:    0 00:00:00.01  CPU: 0:00:00.02  BUFIO: 26  DIRIO: 30  FAULTS: 254

-- Page after delete/insert RMU/Reclaim
-- The deleted line index entries are marked "empty"
--                                cannot be reclaimed as they are not trailing
-- Line and tsn index entries will accumulate over time
*------------------------------------------------------------------------------
                   0002 00000026  0000  page 38, physical area 2
                        9E834EEC  0006  checksum = 9E834EEC
               00B14961 F659EDDB  000A  time stamp =  3-JAN-2017 15:53:17.15
                       0000 0732  0012  1842 free bytes, 0 locked
                            0008  0016  8 lines
                       0013 07DA  0018  line 0: offset 07DA, 19 bytes
                       0000 0000  001C  line 1: empty
                       0020 07BA  0020  line 2: offset 07BA, 32 bytes
                       0000 0000  0024  line 3: empty
                       000D 07AC  0028  line 4: offset 07AC, 13 bytes
                       0000 0000  002C  line 5: empty
                       0000 0000  0030  line 6: empty
                       0022 078A  0034  line 7: offset 078A, 34 bytes

                        000000C0  0038  line 0: TSN 192
                        00000161  003C  line 1: TSN 353
                        00000163  0040  line 2: TSN 355
                        00000161  0044  line 3: TSN 353
                        00000161  0048  line 4: TSN 353
                        00000161  004C  line 5: TSN 353
                        00000161  0050  line 6: TSN 353
                        00000163  0054  line 7: TSN 355

000B000B000B000B000B000B000B000B  0058  free space '................'
                                  ::::  (16 duplicate lines)
00000000000B000B000B000B000B000B  0168  free space '................'
00000000000000000000000000000000  0178  free space '................'
                                  ::::  (96 duplicate lines)
                            0000  0788  free space '..'

                            0020  078A  line 7 (57:38:7) record type 32
                         00 0001  078C  Control information
                                  ....  29 bytes of static data
86726576696C6F54343631303000010D  078F   data '...00164Toliver.'
      04F44E0200873F0020C8008920  079F   data ' ..È .?...Nô.'

                       0052 2005  07AC  line 4: bucket for hash index 82
                                  ....  total hash bucket size: 13
              FFFF FFFFFFFF FFFF  07B0  bucket overflow -1:-1:-1
                              00  07B8  flags 0
                              34  07B9  padding '4'

                       004C 2005  07BA  line 2: bucket for hash index 76
                                  ....  total hash bucket size: 32
              FFFF FFFFFFFF FFFF  07BE  bucket overflow -1:-1:-1
                              00  07C6  flags 0
                        00000001  07C7  duplicate count 1
              004F 00000026 0007  07CB   pointer 79:38:7
                              06  07D3   key len: 6 bytes
                    343631303000  07D4   key: '.00164'

                            2001  07DA  line 0 (57:38:0) SYSTEM record
                         02 000F  07DC  15 bytes in 2 sets/dynamic items
                         004C 07  07DF  7 bytes, storage set type 76
                         0132 5B  07E2   next  76:38:2
                              00  07E5   owner 57:38:0
                         0052 07  07E6  7 bytes, storage set type 82
                         0194 5B  07E9   next  82:38:4
                              00  07EC   owner 57:38:0
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        00000163  07F2  snap pointer TSN 355
                            0000  07F6  MBZ '..'
                        00000000  07F8  page sequence number 0
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
*------------------------------------------------------------------------------
</pre>

<b>CPTRDB_RECLAIM_AREA.COM</b><br>

<p>
RMU/Reclaim one storage area.
</p>

<p>
Basically this command online applies the garbage collection of the dbkey 
scope mode TRANACTION to all pages of a storage area.
</p>

<p>
Change locked space upfront the data section of data pages into free space.<br> 
Mark "locked by {TID}" line index entries as "empty".<br>
Reclaim line and TSN index entries if possible and add their allocation
to the free space.
</p>

<p>
No users in dbkey scope mode ATTACH should be active on the database
while this command is executing.
</p>

<p>
Parameters: Adapt the parameter block.
</p>

<pre>
$!-------------------------
$ dbid   = "SBN_DB"
$ sarea1 = "SEASN_TKT_DATA"
$!-------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 39"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 39 -- Database Restore And Recover
</font>
</h3>

<b>CPTRDB_RESTORE_OPTIONS.COM</b><br>
<b>CPTRDB_RESTORE_DATABASE.COM</b><br><br>

<b>CPTRDB_ALTER_DATABASE.COM</b><br><br>

<b>CPTRDB_SHOW_AIJ_BCK_ONE.COM</b><br>
<b>CPTRDB_RECOVER_DATABASE.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_RESTORE_OPTIONS.COM</b><br>
  Interactive generate database and journal restore options files.
</p>

  Creates in CPT$RDB_DATA:<br>

<pre>
[RESTORE_]{dbid_restore}_{node}_yyyymmdd.OPT
[RESTORE_]{dbid_restore}_{node}_yyyymmdd.AIJ_OPT
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_RESTORE_OPTIONS {dbid_backup} {dbid_restore}
</pre>

<p>
<b>CPTRDB_RESTORE_DATABASE.COM</b><br>
  RMU/Restore one database
</p>

  Requires the database and journal options files in CPT$RDB_DATA:<br>

<pre>
[RESTORE_]{dbid_restore}_{node}_yyyymmdd.OPT
[RESTORE_]{dbid_restore}_{node}_yyyymmdd.AIJ_OPT
</pre>

<p>
  These option files specify the new locations and AIJ settings of the 
  restored database, and can be created using CPTRDB_RESTORE_OPTIONS.COM.

  Note that the RMU/Analyze (weekly) job saves the restore options files 
  for later reference (in case of disaster recovery) in CPT$RDB_ANA.

  The (daily) show extents job saves the database sizes in CPT$RDB_SIZE.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------------------------------------------------------
$ mailto1      = "L15S36::ALLEMEERSCH"
$ dev_restore  = "DISK$DATA_29:"
$ dbid_restore = "BOEM_DB"
$ nodeid_opt   = "L15S29"
$ yyyymmdd_opt = "20150610"
$ rbf_file     = "CPT$RDB_DB_BCK:CPTRDB_DB_1_L15S29_20150706_0035.RBF;1"
$!------------------------------------------------------------------------------
</pre>

<p>
  On purpose specify a low number of buffers so that the database can (always)
  be opened on the target system.

  Do not open nor touch the restored database if a RMU/Recover AIJ rollforward
  has to be executed right away after the restore.
</p>

  Normal exit of a successful restore:<br>

<pre>
%RMU-I-AIJWASON, AIJ journaling was active when the database was backed up
%RMU-I-AIJRECFUL, Recovery of the entire database starts with AIJ file sequence 6212
%RMU-I-LOGCREAIJ, created after-image journal file CPT$RDB_AIJ:[BOEM_DB]BOEM_DB_JRNL_1.AIJ;1
%RMU-I-LOGCREAIJ, created after-image journal file CPT$RDB_AIJ:[BOEM_DB]BOEM_DB_JRNL_2.AIJ;1
%RMU-I-LOGCREAIJ, created after-image journal file CPT$RDB_AIJ:[BOEM_DB]BOEM_DB_JRNL_3.AIJ;1
%RMU-I-COMPLETED, RESTORE operation completed at  6-JUL-2015 15:23:55.19
</pre>

  Live AIJ status after a successful restore (database closed):<br>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-120 Perf. Monitor  6-JUL-2015 15:31:14.51
Rate: 3.00 Seconds          AIJ Journal Information         Elapsed: 00:00:45.21
Page: 1 of 1          DISK$DATA_29:[BOEM_DB]BOEM_DB.RDB;1           Mode: Online

Journaling: enabled   Shutdown: 4320  Notify: enabled   State: Accessible
ALS: Automatic  ABS: disabled                 FC: enabled   CTJ: disabled
ARB.Count:  300 ARB.Avail:  300 SwtchSched:  0 NxtSwtch:
After-Image.Journal.Name....... SeqNum   AIJsize   CurrEOF Status. State.......
AIJ1                              6212    100000   Unknown Current Accessible
AIJ2                            Unused    100000     Empty Latent  Accessible
AIJ3                            Unused    100000     Empty Latent  Accessible
</pre>

<p>
  Eventually change the shared memory setting before the actual RMU/Open
  using<br>
  $ RMU/SET SHARED_MEMORY/TYPE= {db}<br>

  Adapt the database cluster nodes, users, buffers etc ... parameters
  to the new environment of the restored database using 
  CPTRDB_ALTER_DATABASE.COM as a template, before the actual RMU/Open.
</p>

  Toolset CockpitMgr events:<br>

<pre>
CPTRDB_DB_RestoreStarted
"CPTRDB - Database {root} - Restore Started - ddmmmhhmmss"

CPTRDB_DB_RestoreFailed
"CPTRDB - Database {root} - Restore Failed - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - DB Restore Failed {dbid} {node} yyyymmdd"
</pre>

<p>
<b>CPTRDB_ALTER_DATABASE.COM</b><br>
  Template procedure to (offline, after restore) alter database parameters.
</p>

<p>
<b>CPTRDB_SHOW_AIJ_BCK_ONE.COM</b><br>
  List all AIJ backup files available for a single database in CPT$RDB_DATA.
  This list can be used as input file to RMU/Recover.
</p>

  Output sample:<br>

<pre>
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_0025_6211.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_0626_6212.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_0826_6213.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_1026_6214.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_1226_6215.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20150706_1426_6216.AIJ_BCK;1
</pre>

<p>
<b>CPTRDB_RECOVER_DATABASE.COM</b><br>
  RMU/Recover AIJ rollforward one database.
</p>

  Requires the 'list of AIJ backup files' option file:<br>

<pre>
AIJ_BCK_{dbid_backup}_{node}_yyyymmdd.LIS_ddmmmhhmmss
in CPT$RDB_DATA.
</pre>

  This list can be created using<br>

<pre>
$ @CPTRDB_SHOW_AIJ_BCK_ONE {dbid_backup}
Remove the header lines from the output file before the recover.
</pre>

<p>
  If the database backup AND the AIJ backups are quiet point, AIJ backup
  filespecs older than the restored database backup can be 
  removed from the list. In the sample AIJ sequence 6211 at 00:25, as
  the restored database backup is created at 00:35. 

  Be aware that if this condition is not satisfied,
  the recover starting point may be way back in time until a database
  quiet point backup or AIJ quiet point backup is present. No quiet point
  daily database AND AIJ backups are not recommended as they impose a different
  retention policy and scheduled forced database or AIJ quiet point
  backups to keep the database recoverable. 
</p>

  Check the restore logfile for the messages:<br>

<pre>
%RMU-I-AIJWASON, AIJ journaling was active when the database was backed up
%RMU-I-AIJRECFUL,
Recovery of the entire database starts with AIJ file sequence {n}
</pre>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------------------------------------------------------
$ mailto1      = "L15S36::ALLEMEERSCH"
$ dbid_backup  = "CPTRDB_DB_1"
$ dbid_restore = "BOEM_DB"
$! -- AIJ backup files list in CPT$RDB_DATA:
$ nodeid       = "L15S29"
$ yyyymmdd     = "20150706"
$ ddmmmhhmmss  = "06JUL144259"
$!------------------------------------------------------------------------------
</pre>

<p>
  A successful recover operation ends with the messages below and a  
  return status of %X12C8AB6B
</p>

<pre>
%RMU-I-AIJALLDONE, after-image journal roll-forward operations completed
%RMU-I-AIJVNOSYNC, AIJ file CPT$RDB_AIJ:[BOEM_DB]BOEM_DB_JRNL_3.AIJ;1 synchronized with database
%RMU-I-LOGSUMMARY, total 186 transactions committed
%RMU-I-LOGSUMMARY, total 0 transactions rolled back
%RMU-I-LOGSUMMARY, total 2 transactions ignored
%RMU-I-AIJSUCCES, database recovery completed successfully
%RMU-I-AIJFNLSEQ, to start another AIJ file recovery, the sequence number needed will be 6217

$STATUS:   %X12C8AB6B
$SEVERITY: 1
%RMU-I-AIJNXTSEQ, to continue this AIJ file recovery, the sequence number needed will be !SL
</pre>

  Live AIJ status after a successful recover (database open):<br>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-120 Perf. Monitor  6-JUL-2015 15:37:15.44
Rate: 3.00 Seconds          AIJ Journal Information         Elapsed: 00:00:38.65
Page: 1 of 1          DISK$DATA_29:[BOEM_DB]BOEM_DB.RDB;1           Mode: Online

Journaling: enabled   Shutdown: 4320  Notify: enabled   State: Accessible
ALS: Running    ABS: disabled                 FC: enabled   CTJ: disabled
ARB.Count:  300 ARB.Avail:  300 SwtchSched:  0 NxtSwtch:
After-Image.Journal.Name....... SeqNum   AIJsize   CurrEOF Status. State.......
AIJ1                              6212   *BACKUP   NEEDED* Written Accessible
AIJ2                            Unused    100000     Empty Latent  Accessible
AIJ3                              6217    100000         2 Current Accessible
</pre>

<p>
  To free up the as *BACKUP NEEDED* marked AIJ slot, execute a by sequence
  number AIJ backup:
</p>

<pre>
$ RMU/BACKUP/AFTER/SEQ=6212 boem_db cpt$rdb_aij_bck:boem_db_{node}_.aij_bck
</pre>

  Live AIJ status now:<br>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-120 Perf. Monitor  6-JUL-2015 15:40:01.69
Rate: 3.00 Seconds          AIJ Journal Information         Elapsed: 00:03:24.90
Page: 1 of 1          DISK$DATA_29:[BOEM_DB]BOEM_DB.RDB;1           Mode: Online

Journaling: enabled   Shutdown: 4320  Notify: enabled   State: Accessible
ALS: Running    ABS: disabled                 FC: enabled   CTJ: disabled
ARB.Count:  300 ARB.Avail:  300 SwtchSched:  0 NxtSwtch:
After-Image.Journal.Name....... SeqNum   AIJsize   CurrEOF Status. State.......
AIJ1                            Unused    100000     Empty Latent  Accessible
AIJ2                            Unused    100000     Empty Latent  Accessible
AIJ3                              6217    100000         2 Current Accessible
</pre>

<p>
  Do NOT attempt a normal not by sequence AIJ backup to free up the
  *BACKUP NEEDED* AIJ slot, which will result in:
</p>

<pre>
%RMU-I-AIJBCKSTOP, backup of after-image journal AIJ3 did not complete
%RMU-I-OPERNOTIFY, system operator notification: AIJ manual backup operation failed
%RMU-F-AIJBCKGAP, AIJ backup completed after skipping previously backed up journal sequence 6213
%RMU-F-FTL_BCK, Fatal error for BACKUP operation at  6-JUL-2015 14:55:07.97
</pre>

<p>
  Add the recovered database to the configuration file for database and
  AIJ journal backup.
  Run the job CPTRDB_BACKUP_DB_ALL and start normal processing.
</p>

  Toolset CockpitMgr events:<br>

<pre>
CPTRDB_DB_RecoverStarted
"CPTRDB - Database {root} - Recover Started - ddmmmhhmmss"

CPTRDB_DB_RecoverFailed
"CPTRDB - Database {root} - Recover Failed - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - DB Recover Failed {dbid} {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 40"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 40 -- Verify Indices, Storage Areas And Constraints
</font>
</h3>

<b>CPTRDB_VERIFY_INDEX.COM</b><br>
<b>CPTRDB_VERIFY_AREA.COM</b><br>
<b>CPTRDB_VERIFY_CONSTR.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_VERIFY_INDEX.COM</b><br>
  RMU/Verify one or more indices for a single database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------
$ dbid       = "CPTRDB_DB_1"
$ idx1       = "TABLE_PARTI_IDX"
$ idx2       = "TABLE_PLACE_HDX"
$ larea1     = "TABLE_PARTI"
$ larea2     = "TABLE_PLACE"
$ trans_type = "READ_ONLY"
$!------------------------------
</pre>

<p>
<b>CPTRDB_VERIFY_AREA.COM</b><br>
  RMU/Verify one or more storage areas for a single database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!---------------------------
$ dbid       = "CPTRDB_DB_1"
$ sarea1     = "DATA_AREA_11"
$ sarea2     = "DATA_AREA_12"
$ sarea3     = "INDEX_AREA_1"
$ trans_type = "READ_ONLY"
$!---------------------------
</pre>

<p>
<b>CPTRDB_VERIFY_CONSTR.COM</b><br>
  RMU/Verify one or more constraints for a single database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!----------------------------------------
$ dbid       = "CPTRDB_DB_1"
$ constr1    = "TABLE_PARTI_PK"
$ constr2    = "TABLE_PLACE_PK"
$ table1     = "TABLE_PARTI"
$ table2     = "TABLE_PLACE"
$ trans_type = "AUTOMATIC"
$ root_yn    = "NOROOT"
$ define rdm$bind_lock_timeout_interval 30
$!----------------------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 41"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 41 -- Handle List Of Byte Varying Datatypes
</font>
</h3>

<b>CPTRDB_CREATE_LIST.TXT</b><br>
<b>CPTRDB_CREATE_LIST.COM</b><br>
<b>CPTRDB_READ_LIST_SQL.COM</b><br>
<b>CPTRDB_READ_LIST_SQLMOD.SQLMOD</b><br>
<b>CPTRDB_READ_LIST_BUILD.COM</b><br>
<b>CPTRDB_READ_LIST_C.H</b><br>
<b>CPTRDB_READ_LIST_SQLMOD.OBJ</b><br>
<b>CPTRDB_READ_LIST_C.C</b><br>
<b>CPTRDB_READ_LIST_C.OBJ</b><br>
<b>CPTRDB_READ_LIST_C.EXE</b><br>
<b>CPTRDB_READ_LIST_RUN.COM</b><br>

<p>
This chapter supplies template code to create and read blob data on a 
I64 Itanium platform.

Note that the .C file is pure C code. No need to recompile the .SQLMOD source
if only the C source changes and the sqlmod interface remains the same.
</p>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_CREATE_LIST.TXT</b><br>
  Ascii file to be uploaded into a list column by CPTRDB_CREATE_LIST.COM
</p>

<p>
<b>CPTRDB_CREATE_LIST.COM</b><br>
  Create a table with a 'list of byte varying' column and load some data.
</p>

<p>
<b>CPTRDB_READ_LIST_SQL.COM</b><br>
  Read a table with a 'list of byte varying' column in interactive sql.
</p>

<p>
<b>CPTRDB_READ_LIST_SQLMOD.SQLMOD</b><br>
  Called from CPTRDB_READ_LIST_C.C<br>
  Read all rows and segments of a table and list column, from a C program.
</p>

<p>
<b>CPTRDB_READ_LIST_BUILD.COM</b><br>
  Build file for CPTRDB_READ_LIST_SQLMOD.SQLMOD and CPTRDB_READ_LIST_C.C
</p>

<p>
<b>CPTRDB_READ_LIST_C.H</b><br>
  Generated C prototypes file for CPTRDB_READ_LIST_SQLMOD.SQLMOD
</p>

<p>
<b>CPTRDB_READ_LIST_SQLMOD.OBJ</b><br>
  Object file of CPTRDB_READ_LIST_SQLMOD.SQLMOD
</p>

<p>
<b>CPTRDB_READ_LIST_C.C</b><br>
  Calls CPTRDB_READ_LIST_SQLMOD.SQLMOD<br>
  Read all rows and segments of a table and list column, from a C program.
</p>

<p>
<b>CPTRDB_READ_LIST_C.OBJ</b><br>
  Object file of CPTRDB_READ_LIST_C.C
</p>

<p>
<b>CPTRDB_READ_LIST_C.EXE</b><br>
  Image file of CPTRDB_READ_LIST_C.C
</p>

<p>
<b>CPTRDB_READ_LIST_RUN.COM</b><br>
  Run file for CPTRDB_READ_LIST_C.EXE
</p>

  Output sample:<br>

<pre>
-- 1 --
==> Which term do you prefer ?
==> List of byte varying, segmented strings, blobs ?
-- 2 --
==> Note that from Rdb v7.1 on this is much more elegant.
==> You can simply insert a file !
-- 3 --
==> This is the content of a text file
==> that has been uploaded in Rdb V7.2-52 !
</pre>

<p>
Below a full dump of a data page containing list of byte varying pointer and 
data segments:
</p>

<pre>
*------------------------------------------------------------------------------
* Oracle Rdb V7.3-200                                    4-JAN-2017 11:42:06.21
*
* Dump of Live area LISTS_AREA
*     Filename: DISK$DATA_29:[CPTRDB_DB_1]LISTS_AREA.RDA;1
*     Database: DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
*
*------------------------------------------------------------------------------

                   0003 00000008  0000  page 8, physical area 3
                        D294D324  0006  checksum = D294D324
               00ADA4A1 F1649A08  000A  time stamp =  4-OCT-2013 15:50:41.75
                       0000 0590  0012  1424 free bytes, 0 locked
                            0009  0016  9 lines
                       0023 07CA  0018  line 0: offset 07CA, 35 bytes
                       0039 0790  001C  line 1: offset 0790, 57 bytes
                       0049 0746  0020  line 2: offset 0746, 73 bytes
                       003E 0708  0024  line 3: offset 0708, 62 bytes
                       0027 06E0  0028  line 4: offset 06E0, 39 bytes
                       0049 0696  002C  line 5: offset 0696, 73 bytes
                       002B 066A  0030  line 6: offset 066A, 43 bytes
                       0030 063A  0034  line 7: offset 063A, 48 bytes
                       0049 05F0  0038  line 8: offset 05F0, 73 bytes

                        000000F0  003C  line 0: TSN 240
                        000000F0  0040  line 1: TSN 240
                        000000F0  0044  line 2: TSN 240
                        000000F0  0048  line 3: TSN 240
                        000000F0  004C  line 4: TSN 240
                        000000F0  0050  line 5: TSN 240
                        000000F0  0054  line 6: TSN 240
                        000000F0  0058  line 7: TSN 240
                        000000F0  005C  line 8: TSN 240

00000000000000000000000000000000  0060  free space '................'
                                  ::::  (88 duplicate lines)

                            200B  05F0  line 8: blob primary pointer segment
                         00 0001  05F2  Control information
                                  ....  total blob segment size: 68
                        00000000  05F5  segment type 0
                        00000000  05F9  MBZ '....'
                        00000000  05FD  unused '....'
              FFFF FFFFFFFF FFFF  0601  next pointer segment -1:-1:-1
                        00000002  0609  number of dbkeys 2
                0000000000000051  060D  total length of segments 81
                        00000002  0615  number of data segments 2
                        00000001  0619  number of pointer segments 1
                        0000002B  061D  length of longest segment 43
     00000026 003D 00000008 0006  0621  data segment 61:8:6 (len 38)
     0000002B 003D 00000008 0007  062D  data segment 61:8:7 (len 43)
                              00  0639  padding '.'

                            0000  063A  line 7 (3:8:7) record type 0
                         00 0001  063C  Control information
                                  ....  43 bytes of static data
656562207361682074616874203E3D3D  063F   data '==> that has bee'
6452206E6920646564616F6C7075206E  064F   data 'n uploaded in Rd'
          212032352D322E37562062  065F   data 'b V7.2-52 !'

                            0000  066A  line 6 (3:8:6) record type 0
                         00 0001  066C  Control information
                                  ....  38 bytes of static data
206568742073692073696854203E3D3D  066F   data '==> This is the '
786574206120666F20746E65746E6F63  067F   data 'content of a tex'
                    656C69662074  068F   data 't file'
                              00  0695  padding '.'

                            200B  0696  line 5: blob primary pointer segment
                         00 0001  0698  Control information
                                  ....  total blob segment size: 68
                        00000000  069B  segment type 0
                        00000000  069F  MBZ '....'
                        00000000  06A3  unused '....'
              FFFF FFFFFFFF FFFF  06A7  next pointer segment -1:-1:-1
                        00000002  06AF  number of dbkeys 2
                000000000000005B  06B3  total length of segments 91
                        00000002  06BB  number of data segments 2
                        00000001  06BF  number of pointer segments 1
                        00000039  06C3  length of longest segment 57
     00000039 003D 00000008 0003  06C7  data segment 61:8:3 (len 57)
     00000022 003D 00000008 0004  06D3  data segment 61:8:4 (len 34)
                              00  06DF  padding '.'

                            0000  06E0  line 4 (3:8:4) record type 0
                         00 0001  06E2  Control information
                                  ....  34 bytes of static data
706D6973206E616320756F59203E3D3D  06E5   data '==> You can simp'
656C6966206120747265736E6920796C  06F5   data 'ly insert a file'
                            2120  0705   data ' !'
                              00  0707  padding '.'

                            0000  0708  line 3 (3:8:3) record type 0
                         00 0001  070A  Control information
                                  ....  57 bytes of static data
726620746168742065746F4E203E3D3D  070D   data '==> Note that fr'
74206E6F20312E377620626452206D6F  071D   data 'om Rdb v7.1 on t'
65726F6D206863756D20736920736968  072D   data 'his is much more'
              2E746E6167656C6520  073D   data ' elegant.'

                            200B  0746  line 2: blob primary pointer segment
                         00 0001  0748  Control information
                                  ....  total blob segment size: 68
                        00000000  074B  segment type 0
                        00000000  074F  MBZ '....'
                        00000000  0753  unused '....'
              FFFF FFFFFFFF FFFF  0757  next pointer segment -1:-1:-1
                        00000002  075F  number of dbkeys 2
                0000000000000052  0763  total length of segments 82
                        00000002  076B  number of data segments 2
                        00000001  076F  number of pointer segments 1
                        00000034  0773  length of longest segment 52
     0000001E 003D 00000008 0000  0777  data segment 61:8:0 (len 30)
     00000034 003D 00000008 0001  0783  data segment 61:8:1 (len 52)
                              00  078F  padding '.'

                            0000  0790  line 1 (3:8:1) record type 0
                         00 0001  0792  Control information
                                  ....  52 bytes of static data
6574796220666F207473694C203E3D3D  0795   data '==> List of byte'
6E656D676573202C676E697972617620  07A5   data ' varying, segmen'
6F6C62202C73676E6972747320646574  07B5   data 'ted strings, blo'
                        3F207362  07C5   data 'bs ?'
                              00  07C9  padding '.'

                            0000  07CA  line 0 (3:8:0) record type 0
                         00 0001  07CC  Control information
                                  ....  30 bytes of static data
64206D726574206863696857203E3D3D  07CF   data '==> Which term d'
    3F2072656665727020756F79206F  07DF   data 'o you prefer ?'
                              00  07ED  padding '.'

                        00000001  07EE  snap page pointer 1
                        000000F0  07F2  snap pointer TSN 240
                            003D  07F6  logical area 61
                        00000009  07F8  page sequence number 9
                            0000  07FC  page TSN base 0
                            0000  07FE  MBZ '..'
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 42"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 42 -- Unload Data From AIJ Journal Files
</font>
</h3>

<b>CPTRDB_UNLOAD_AFTER.OPT</b> (Called from)<br>
<b>CPTRDB_UNLOAD_AFTER.COM</b><br><br>

<b>CPTRDB_UNLOAD_AFTER_CONT.OPT</b> (Called from)<br>
<b>CPTRDB_UNLOAD_AFTER_CONT.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
These template source files unload data from AIJ journal files
for a database with (continuous) logminer enabled.
</p>

<p>
<b>CPTRDB_UNLOAD_AFTER.OPT</b><br>
  Called from CPTRDB_UNLOAD_AFTER.COM<br>
  RMU/Unload/After_Journal options file.
</p>

<p>
  List the tables to be unloaded from a series of AIJ journal files and their 
  output filespecs default created in CPT$RDB_DATA.
</p>

<p>
<b>CPTRDB_UNLOAD_AFTER.COM</b><br>
  Calls CPTRDB_UNLOAD_AFTER.OPT<br>
  RMU/Unload/After_Journal data from a series of hardcoded AIJ journal files.
</p>

<p>
  Parameters: Adapt the list of AIJ backup files in the parameter block.
</p>

<pre>
$!---------------------------------------------------------------------------
$ dbid    = "CPTRDB_DB_1"
$ aijbck1 = "CPT$RDB_AIJ_BCK:CPTRDB_DB_1_L15S29_20160715_1009_9966.AIJ_BCK;1"
$ aijbck2 = "CPT$RDB_AIJ_BCK:CPTRDB_DB_1_L15S29_20160715_1209_9967.AIJ_BCK;1"
$ aijbck3 = "CPT$RDB_AIJ_BCK:CPTRDB_DB_1_L15S29_20160715_1409_9968.AIJ_BCK;1"
$!---------------------------------------------------------------------------
</pre>

<p>
  Sample logfile extract:
</p>

<pre>
  table = jcclml$heartbeat, -
    output            = cpt$rdb_data:rdb_lm_jcclml$heartbeat.unl, -
    table_definition  = cpt$rdb_data:rdb_lm_jcclml$heartbeat.sql, -
    record_definition = cpt$rdb_data:rdb_lm_jcclml$heartbeat.rrd
   1 : TABLE=JCCLML$HEARTBEAT,OUTPUT=CPT$RDB_DATA:RDB_LM_JCCLML$HEARTBEAT.UNL,TABLE_DEFINITION=CPT$RDB_DATA:RDB_LM_JCCLML$HEARTBEAT.SQL,RECORD_DEFINITION=CPT$RDB_DATA:RDB_LM_JCCLML$HEARTBEAT.RRD
  !
%RMU-I-UNLAIJFL, Unloading table JCCLML$HEARTBEAT to CPT$RDB_ROOT:[DATA]RDB_LM_JCCLML$HEARTBEAT.UNL;1
%RMU-I-LOGOPNAIJ, opened journal file DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20160715_1009_9966.AIJ_BCK;1 at 15-JUL-2016 14:44:44.99
%RMU-I-AIJRSTSEQ, journal sequence number is "9966"
%RMU-I-AIJMODSEQ, next AIJ file sequence number will be 9967
%RMU-I-LOGOPNAIJ, opened journal file DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20160715_1209_9967.AIJ_BCK;1 at 15-JUL-2016 14:44:45.02
%RMU-I-AIJRSTSEQ, journal sequence number is "9967"
%RMU-I-AIJMODSEQ, next AIJ file sequence number will be 9968
%RMU-I-LOGOPNAIJ, opened journal file DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_DB_1_L15S29_20160715_1409_9968.AIJ_BCK;1 at 15-JUL-2016 14:44:45.07
%RMU-I-AIJRSTSEQ, journal sequence number is "9968"
%RMU-I-AIJMODSEQ, next AIJ file sequence number will be 9969
%RMU-I-LOGSUMMARY, total 75 transactions committed
%RMU-I-LOGSUMMARY, total 0 transactions rolled back
------------------------------------------------------------------------------
 ELAPSED:    0 00:00:00.15  CPU: 0:00:00.01  BUFIO: 39  DIRIO: 21  FAULTS: 74 
Table "JCCLML$HEARTBEAT" : 72 records written (72 modify, 0 delete)
Total : 72 records written (72 modify, 0 delete)
</pre>

<p>
  Sample output files:
</p>

<p>
RDB_LM_JCCLML$HEARTBEAT.SQL
</p>

<pre>
-- Table definition for LogMiner transaction data 15-JUL-2016 14:44:44.92
-- From database table "JCCLML$HEARTBEAT"
CREATE TABLE RDB_LM_JCCLML$HEARTBEAT (
  RDB$LM_ACTION CHAR
 ,RDB$LM_RELATION_NAME CHAR (31)
 ,RDB$LM_RECORD_TYPE INTEGER
 ,RDB$LM_DATA_LEN SMALLINT
 ,RDB$LM_NBV_LEN SMALLINT
 ,RDB$LM_DBK BIGINT
 ,RDB$LM_START_TAD DATE VMS
 ,RDB$LM_COMMIT_TAD DATE VMS
 ,RDB$LM_TSN BIGINT
 ,RDB$LM_RECORD_VERSION SMALLINT
 ,JCCLML$TIMESTAMP DATE VMS
);
</pre>

<p>
RDB_LM_JCCLML$HEARTBEAT.RRD
</p>

<pre>
/* Record definition for LogMiner transaction data 15-JUL-2016 14:44:44.91 */
/* From database table "JCCLML$HEARTBEAT" */
DEFINE FIELD RDB$LM_ACTION DATATYPE IS TEXT SIZE IS 1.
DEFINE FIELD RDB$LM_RELATION_NAME DATATYPE IS TEXT SIZE IS 31.
DEFINE FIELD RDB$LM_RECORD_TYPE DATATYPE IS TEXT SIZE IS 12.
DEFINE FIELD RDB$LM_DATA_LEN DATATYPE IS TEXT SIZE IS 6.
DEFINE FIELD RDB$LM_NBV_LEN DATATYPE IS TEXT SIZE IS 6.
DEFINE FIELD RDB$LM_DBK DATATYPE IS TEXT SIZE IS 20.
DEFINE FIELD RDB$LM_START_TAD DATATYPE IS TEXT SIZE IS 16.
DEFINE FIELD RDB$LM_COMMIT_TAD DATATYPE IS TEXT SIZE IS 16.
DEFINE FIELD RDB$LM_TSN DATATYPE IS TEXT SIZE IS 20.
DEFINE FIELD RDB$LM_RECORD_VERSION DATATYPE IS TEXT SIZE IS 6.
DEFINE FIELD JCCLML$TIMESTAMP DATATYPE IS TEXT SIZE IS 16.
DEFINE RECORD RDB_LM_JCCLML$HEARTBEAT.
   RDB$LM_ACTION .
   RDB$LM_RELATION_NAME .
   RDB$LM_RECORD_TYPE .
   RDB$LM_DATA_LEN .
   RDB$LM_NBV_LEN .
   RDB$LM_DBK .
   RDB$LM_START_TAD .
   RDB$LM_COMMIT_TAD .
   RDB$LM_TSN .
   RDB$LM_RECORD_VERSION .
   JCCLML$TIMESTAMP .
END RDB_LM_JCCLML$HEARTBEAT RECORD.
</pre>

<p>
RDB_LM_JCCLML$HEARTBEAT.UNL
</p>

<pre>
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508124413|2016071508124415|3139848|1|2016071508124415
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508174413|2016071508174413|3139850|1|2016071508174413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508224413|2016071508224413|3139852|1|2016071508224413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508274413|2016071508274413|3139854|1|2016071508274413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508324413|2016071508324413|3139856|1|2016071508324413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508374413|2016071508374413|3139858|1|2016071508374413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508424413|2016071508424413|3139860|1|2016071508424413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508474413|2016071508474413|3139862|1|2016071508474413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508524413|2016071508524413|3139864|1|2016071508524413
M|JCCLML$HEARTBEAT|45|8|1|18295873505984512|2016071508574413|2016071508574413|3139866|1|2016071508574413
......
</pre>

<p>
  Call JCCLML_CVT_ODBKEY.COM to convert dbkey bigint values to the 
  readable format {larea}:{page}:{line} .
</p>

<p>
  Usage:
</p>

<pre>
$ @JCCLML_CVT_ODBKEY 18295873505984512
  Char:    18295873505984512
  Hex:     410000012e0000
  Hex:     41:12e:0
  Decimal: 65:302:0

SQL> select * from JCCLML$HEARTBEAT where dbkey = _dbkey'65:302:0';
 JCCLML$TIMESTAMP
 15-JUL-2016 15:02:44.14
1 row selected
</pre>

<p>
<b>CPTRDB_UNLOAD_AFTER_CONT.OPT</b><br>
  Called from CPT$RDB:CPTRDB_UNLOAD_AFTER_CONT.COM<br>
  RMU/Unload/After_Journal/Continuous options file.
</p>

<p>
  List the tables to be unloaded from the live AIJ journal files
  in a continuous way and their output filespecs in CPT$RDB_DATA.
<p>

<p>
<b>CPTRDB_UNLOAD_AFTER_CONT.COM</b><br>
  Calls CPT$RDB:CPTRDB_UNLOAD_AFTER_CONT.OPT<br>
  RMU/Unload/After_Journal/Continuous data from the live AIJ journal files
  in a continuous way.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_UNLOAD_AFTER_CONT
</pre>

<p>
  The created batch process is named "CPTRDB_LOGMINER". 

  To stop this process with a graceful rundown use:
  $ STOP/IMAGE/ID={pid}
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 43"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 43 -- Remote Access Over TCP/IP
</font>
</h3>

<b>CPTRDB_REMOTE_ACCESS_TCPIP.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_REMOTE_ACCESS_TCPIP.COM</b><br>
  Demonstrate access to a remote database (PERSONA enabled)
  over a TCP/IP connection.
</p>
  
<pre>
Parameters: P1, hostname, varchar(255)
            P2, dbid,     varchar(255)
            P3, username, varchar(12)
            P4, password, varchar(32)
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_REMOTE_ACCESS_TCPIP {hostname} {dbid} {username} {password}
</pre>

<p>
  The procedure creates the file RDB$CLIENT_DEFAULTS.DAT in the 
  CPT$RDB_DATA: directory, defines the logical RDB$USER_DEFAULTS, and assumes 
  the {username} has access to the remote database.

  If PERSONA is not enabled on the remote database, grant database access to the
  RDB$REMOTE7% account on the remote system. 

  The procedure lists the columns RDB$FILE_NAME, RDB$CREATED and 
  RDB$DATABASE_CREATOR of table RDB$DATABASE for the remote database.
</p>

  Observe the database protection using<br>

<pre>
SQL> show protection on database rdb$dbhandle;
</pre>

  Check the tcp/ip log in<br>

<pre>
{hostname}::sys$common:[rdb$remote7%]RDBSERVER_TCPIP.LOG
</pre>

<p>
  As of Rdb V7.3-200 TCP/IP proxy access to remote databases is supported.
  Refer to the Rdb V7.3 New Features Document for more information.
</p>

Output sample:<br>

<pre>
   RDB$FILE_NAME
      RDB$CREATED               RDB$DATABASE_CREATOR
 DSA23:[SBN_DB]SABIN_TT.RDB;1
...
   11-JAN-2007 13:27:31.58   SBN_USER

1 row selected

Directory CPT$RDB_ROOT:[DATA]

RDB$CLIENT_DEFAULTS.DAT;1
                           1/96       10-DEC-2015 14:15:37.53

Total of 1 file, 1/96 blocks.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 44"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 44 -- Encrypt And Decrypt Data
</font>
</h3>

<b>CPTRDB_ENCRYPT_DISCLAIMER.TXT</b><br><br>

<b>CPTRDB_ENCRYPT_BUILD.COM</b><br><br>

<b>CPTRDB_ENCRYPT_SHR_B32.B32</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.OBJ</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.OPT</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.EXE</b><br><br>

<b>CPTRDB_ENCRYPT_SHR_C.C</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.OBJ</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.OPT</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.EXE</b><br><br>

<b>CPTRDB_ENCRYPT_C.C</b><br>
<b>CPTRDB_ENCRYPT_C.OBJ</b><br>
<b>CPTRDB_ENCRYPT_C.EXE</b><br>
<b>CPTRDB_ENCRYPT_C_RUN.COM</b><br><br>

<b>CPTRDB_ENCRYPT_SQL.COM</b><br>
<b>CPTRDB_ENCRYPT_SQL_B32_RUN.COM</b><br>
<b>CPTRDB_ENCRYPT_SQL_C_RUN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
This chapter is based on 'My Oracle Support' Document Id 363325.1

The encryption algorithm used is DESCBC (Data Encryption Standard Cipher Block
Chaining) with a block length of 64 bits.
The encrypted string length is the next multiple of 8 >= the input string
length.
The HP Bliss compiler is available from the OpenVMS Freeware distribution kit.
</p>

<p>
<b>CPTRDB_ENCRYPT_DISCLAIMER.TXT</b><br>
  Support disclaimer for the encrypt/decrypt procedures provided by
  Oracle Rdb engineering via 'My Oracle Support' Document Id 363325.1
</p>

<p>
<b>CPTRDB_ENCRYPT_BUILD.COM</b><br>
  Build file for<br>
  CPTRDB_ENCRYPT_SHR_B32.EXE, shareable image<br>
  CPTRDB_ENCRYPT_SHR_C.EXE,   shareable image<br>
  CPTRDB_ENCRYPT_C.EXE,       main C program
</p>

<p>
<b>CPTRDB_ENCRYPT_SHR_B32.B32</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.OBJ</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.OPT</b><br>
<b>CPTRDB_ENCRYPT_SHR_B32.EXE</b><br>

  Bliss source and shareable image for the encrypt/decrypt routines<br>
  ENCRYPT_CCN_B32<br>
  DECRYPT_CCN_B32
</p>

<p>
<b>CPTRDB_ENCRYPT_SHR_C.C</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.OBJ</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.OPT</b><br>
<b>CPTRDB_ENCRYPT_SHR_C.EXE</b><br>

  C source and shareable image for the encrypt/decrypt routines<br>
  ENCRYPT_CCN_C<br>
  DECRYPT_CCN_C
</p>

<b>CPTRDB_ENCRYPT_C.C</b><br>
<b>CPTRDB_ENCRYPT_C.OBJ</b><br>
<b>CPTRDB_ENCRYPT_C.EXE</b><br>

<pre>
Standalone main C program to test the encryption procedures
ENCRYPT_CCN_B32
DECRYPT_CCN_B32
ENCRYPT_CCN_C
DECRYPT_CCN_C

Parameters: P1, input string, varchar(24)

Calls CPT$RDB:CPTRDB_ENCRYPT_SHR_B32.EXE
      CPT$RDB:CPTRDB_ENCRYPT_SHR_C.EXE

The program exports two DCL symbols
ENCRYPT_SYMB_B32
ENCRYPT_SYMB_C
that contain the encrypted value of the input string, created using
the Bliss procedure ENCRYPT_CCN_B32 or the C procedure ENCRYPT_CCN_C.
</pre>

<b>CPTRDB_ENCRYPT_C_RUN.COM</b><br>

<pre>
Run command file to test the Bliss and C encryption/decryption routines
ENCRYPT_CCN_B32
DECRYPT_CCN_B32
ENCRYPT_CCN_C
DECRYPT_CCN_C
from the standalone C main program CPTRDB_ENCRYPT_C.EXE

Parameters: P1, plain text string, varchar(24)

Runs:  CPT$RDB:CPTRDB_ENCRYPT_C.EXE
Calls: CPT$RDB:CPTRDB_ENCRYPT_SHR_B32.EXE
       CPT$RDB:CPTRDB_ENCRYPT_SHR_C.EXE

The encrypted values are imported in to a SQL session to list their
length and hexadecimal value using the SQL function RAWTOHEX.

Usage:
$ @CPTRDB_ENCRYPT_C_RUN {plain text string}
</pre>

  Examples:<br>

<pre>
$ @CPTRDB_ENCRYPT_C_RUN "boem"
In Length: 4
In:        {boem}
Out B32:   {boem}
Out C:     {boem}
  ENCRYPT_SYMB_B32 = "â5ö.ãOnÇ"
  ENCRYPT_SYMB_C = "â5ö.ãOnÇ"
B32 Cipher Length: 8
B32 Cipher Txt:    {â5ö.ãOnÇ}
B32 Cipher Hex:    {E235F695E34F6EC7}
C   Cipher Length: 8
C   Cipher Txt:    {â5ö.ãOnÇ}
C   Cipher Hex:    {E235F695E34F6EC7}

$ @CPTRDB_ENCRYPT_C_RUN "123456789"
In Length: 9
In:        {123456789}
Out B32:   {123456789}
Out C:     {123456789}
  ENCRYPT_SYMB_B32 = "Ö¯¿Ã¶_ûho..R.äAT"
  ENCRYPT_SYMB_C = "Ö¯¿Ã¶_ûho..R.äAT"
B32 Cipher Length: 16
B32 Cipher Txt:    {Ö¯¿Ã¶_ûho..R.äAT}
B32 Cipher Hex:    {D6AFBFC3B65FFB686F9B01520DE44154}
C   Cipher Length: 16
C   Cipher Txt:    {Ö¯¿Ã¶_ûho..R.äAT}
C   Cipher Hex:    {D6AFBFC3B65FFB686F9B01520DE44154}
</pre>

<b>CPTRDB_ENCRYPT_SQL.COM</b><br>

<pre>
Create the encryption sql external procedures
ENCRYPT_CCN_B32_PROC
DECRYPT_CCN_B32_PROC
ENCRYPT_CCN_C_PROC
DECRYPT_CCN_C_PROC
in database CPTRDB_DB_1
  
Calls CPT$RDB:CPTRDB_ENCRYPT_SHR_B32.EXE
      CPT$RDB:CPTRDB_ENCRYPT_SHR_C.EXE
</pre>

<b>CPTRDB_ENCRYPT_SQL_B32_RUN.COM</b><br>

<pre>
Run command file for the encryption/decryption sql external procedures
ENCRYPT_CCN_B32_PROC
DECRYPT_CCN_B32_PROC
called from within a sql session.

Usage:
$ @CPTRDB_ENCRYPT_SQL_B32_RUN {plain text}

Example:

$ @CPTRDB_ENCRYPT_SQL_B32_RUN "boem"
In Length: 4
In:        {boem}
Out B32:   {boem}
B32 Cipher Length: 8
B32 Cipher Txt:    {â5ö.ãOnÇ}
B32 Cipher Hex:    {E235F695E34F6EC7}
-- Using Table Cipher --
Out B32: {boem}
-- Using Table Hex --
Out B32: {boem}
</pre>

<b>CPTRDB_ENCRYPT_SQL_C_RUN.COM</b><br>

<pre>
Run command file for the encryption/decryption sql external procedures
ENCRYPT_CCN_C_PROC
DECRYPT_CCN_C_PROC
called from within a sql session.

Usage:
$ @CPTRDB_ENCRYPT_SQL_C_RUN }plain text{

Examples:

$ @CPTRDB_ENCRYPT_SQL_C_RUN "123456789"
In Length: 9
In:        {123456789}
Out C:     {123456789}
C Cipher Length: 16
C Cipher Txt:    {Ö¯¿Ã¶_ûho..R.äAT}
C Cipher Hex:    {D6AFBFC3B65FFB686F9B01520DE44154}
-- Using Table Cipher --
Out C: {123456789}
-- Using Table Hex --
Out C: {123456789}

$ @CPTRDB_ENCRYPT_SQL_C_RUN "12345678901234567"
In Length: 17
In:        {12345678901234567}
Out C:     {12345678901234567}
C Cipher Length: 24
C Cipher Txt:    {Ö¯¿Ã¶_ûh;.ï2¢Ð.{¢Ç© ;Ã.Ü}
C Cipher Hex:    {D6AFBFC3B65FFB683B9FEF32A2D0127BA2C7A9203BC31BDC}
-- Using Table Cipher --
Out C: {12345678901234567}
-- Using Table Hex --
Out C: {12345678901234567}
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 45"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 45 -- Restart JDBC Thin Servers
</font>
</h3>

<b>CPTRDB_RESTART_JDBC_ALL.COM</b><br>
<b>CPTRDB_RESTART_JDBC_GO.COM</b><br>
<b>CPTRDB_RESTART_JDBC.COM</b><br><br>

<b>CPTRDB_THINSRV$STARTUP.COM</b><br><br>

<b>SYS$COMMON:[RDB$JDBC.COM]</b><br>
<b>TSP1701_CFG.XML</b><br>
<b>TSP1701_CFG_JVM5.XML</b><br>
<b>TSP1701_CFG_JVM6.XML</b><br><br>

<b>CPTRDB_RDBJDBC_STARTSRV.COM</b><br>
<b>CPTRDB_RDBJDBC_STARTSRV_73_150.COM</b><br>
<b>CPTRDB_RDBJDBC_STARTSRV_73_160.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The general goal of the procedures in this chapter is to obtain unique 
meaningful names on each thin server (re)start for log, output, error and
trace files. Eventually Rdb debug flags can be activated and their output
written to the server log file.
</p>

<p>
<b>CPTRDB_RESTART_JDBC_ALL.COM</b><br>
  Calls CPTRDB_RESTART_JDBC.COM
</p>

<p>
  Daily restart the Rdb JDBC thin servers on a series of nodes,
  listed in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_RESTART_JDBC.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_RESTART_JDBC|L15S29|JDBCMON|DISK$USERS:[JDBCMON]|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_RESTART_JDBC
! 2 Execution node
! 3 Username
! 4 Logfile directory
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file
  identified by the keywords CPT$RDB_JOB|CPTRDB_RESTART_JDBC_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_RESTART_JDBC_ALL|L15S29|TOMORROW + 00:16|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_RESTART_JDBC_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_RESTART_JDBC_GO.COM</b><br>
  Calls CPTRDB_RESTART_JDBC.COM
</p>

<p>
  Interactive submit the restart of the JDBC thin servers on one node,
  with hardcoded jdbc user and logfile directory.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_RESTART_JDBC_GO {node}
</pre>

  Adapt the parameter block.<br>

<pre>
$!----------------------------------
$ defdir    = "CPT$RDB:"
$ jdbc_user = "JDBCMON"
$ logdir    = "DISK$USERS:[JDBCMON]"
$!----------------------------------
</pre>

<p>
<b>CPTRDB_RESTART_JDBC.COM </b><br>
  Called from CPTRDB_RESTART_JDBC_[GO|ALL].COM<br>
  Calls CPTRDB_THINSRV$STARTUP.COM
</p>

<p>
  Restart the JDBC thin servers on one cluster node.
  The runtime parameters are retrieved from the configuration file
  identified by the keywords CPT$RDB_PARAM|CPTRDB_RESTART_JDBC.
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_RESTART_JDBC|L15S28|DISK$DATA_24:[JAVA$150.COM]JAVA$150_SETUP|RDB$JDBC_COM:TSP1701_CFG_JVM5.XML|rdb4ever|RDBMON|TSP1701|
CPT$RDB_PARAM|CPTRDB_RESTART_JDBC|L15S29|DISK$DATA_24:[JAVA$60.COM]JAVA$60_SETUP|RDB$JDBC_COM:TSP1701_CFG_JVM6.XML|rdb4ever|RDBMON|TSP1701|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_RESTART_JDBC
! 2 Execution node
! 3 Java version setup
! 4 JDBC config file
! 5 Control password
! 6 'Reply to' user
! 7 Pool server process name
</pre>

<p>
  In order to list old and new process id's,
  the thin server process names (sub)strings are retrieved from the
  configuration file, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS|L15S29|TSP1701|
CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS|L15S29|TS170|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_JDBC_PROCESS
! 2 Execution node
! 3 Process name(s) (sub)string
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_JDBC_RestartStarted
"CPTRDB - JDBC Restart Started {node} - ddmmmhhmmss"
</pre>

<p>
<b>CPTRDB_THINSRV$STARTUP.COM</b><br>
  Called from CPTRDB_RESTART_JDBC.COM
</p>

<p>
  Start the JDBC thin pool server process with meaningful logfile names.
  The runtime parameters are retrieved from the configuration file
  identified by the keywords CPT$RDB_PARAM|CPTRDB_RESTART_JDBC.
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_RESTART_JDBC|L15S28|DISK$DATA_24:[JAVA$150.COM]JAVA$150_SETUP|RDB$JDBC_COM:TSP1701_CFG_JVM5.XML|rdb4ever|RDBMON|TSP1701|
CPT$RDB_PARAM|CPTRDB_RESTART_JDBC|L15S29|DISK$DATA_24:[JAVA$60.COM]JAVA$60_SETUP|RDB$JDBC_COM:TSP1701_CFG_JVM6.XML|rdb4ever|RDBMON|TSP1701|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_RESTART_JDBC
! 2 Execution node
! 3 Java version setup
! 4 JDBC config file
! 5 Control password
! 6 'Reply to' user
! 7 Pool server process name
</pre>

<p>
<b>CPTRDB_RDBJDBC_STARTSRV.COM</b><br>
  Contains a copy of RDB$JDBC_COM:RDBJDBC_STARTSRV.COM modified
  to provide unique meaningful names for thin server log/trace files,
  and debug flags output if needed, using the default java version.
</p>

  The modified code sections are:<br>

<pre>
$!------------------------------------------------------------------------------
$ trcdir = "DISK$DATA_29:[JDBC_TRACE_FILES]"
$!
$ nodeid  = f$getsyi("nodename")
$!
$ refdate     = f$cvtime("today","comparison","date")
$ yyyy_ref    = f$extract(0,4,"''refdate'")
$ mm_ref      = f$extract(5,2,"''refdate'")
$ dd_ref      = f$extract(8,2,"''refdate'")
$ refout      = yyyy_ref + mm_ref + dd_ref
$!
$ dd_out  = f$cvtime("today","comparison","day")
$ mmm_out = f$cvtime("today","absolute",  "month")
$ hh_out  = f$cvtime(,"comparison","hour")
$ mm_out  = f$cvtime(,"comparison","minute")
$ ss_out  = f$cvtime(,"comparison","second")
$ dateout = dd_out + mmm_out + hh_out + mm_out + ss_out
$!
$    err_file ="''logdir'SRVERR_''nam'_''nodeid'_''refout'.LOG_''dateout'"
$    out_file ="''logdir'SRVOUT_''nam'_''nodeid'_''refout'.LOG_''dateout'"
$    log_file ="''logdir'SRVLOG_''nam'_''nodeid'_''refout'.LOG_''dateout'"
$    trc_file ="''trcdir'SRVTRC_''nam'_''nodeid'_''refout'.LOG_''dateout'"
$!------------------------------------------------------------------------------

$!------------------------------------------------------------------------------
$!$    if nam .eqs. "TS1705"
$!$    then
$!$      write x "$ define rdms$set_flags -"
$!$      write x """database,transaction,chrono_flag(2),strategy,detail,execution,request_names,index_partitions"""
$!$    endif
$!
$    write x "$define/nolog rdb$jdbc_trace_file ''trc_file'"
$!------------------------------------------------------------------------------
</pre>

<p>
  Called implicitely from CPT$RDB:CPTRDB_THINSRV$STARTUP via
  the jdbc config file RDB$JDBC_COM:TSP1701_CFG.XML
</p>

<pre>
----
cfg="rdb$jdbc_com:tsp1701_cfg.xml"
srv.startup="rdb$jdbc_com:rdbjdbc_startsrv.com"
----
</pre>

<p>
  The servers are defined in the config file as below with 
  tracelevel "0x40000400" and trace logfile "rdb$jdbc_trace_file"
  which translates to {trcdir}:SRVTRC_{name}_{node}_yyyymmdd.LOG_ddmmmhhmmss
</p>

<pre>
        {server
             name="TS1704"
             type="rdbthinsrv"
             url="//localhost:1704/"
             autostart = "true"
             restrictaccess = "true"
             tracelevel = "0x40000400"
             log = "rdb$jdbc_trace_file"
        }
             {allowDatabase name="sbn_db"/}
        {/server}
</pre>

<p>
<b>CPTRDB_RDBJDBC_STARTSRV_73_150.COM</b><br>
  Copie of RDB$JDBC_COM:RDBJDBC_STARTSRV.COM, modified to allow for
  meaningfull logfile names, Rdb debug flags and hardcoded JAVA V150 version.
</p>

  The additional modified code sections are:

<pre>
----
$    write x "$define/nolog tz ""Europe/Brussels""" ! Timezone fixed in 160
----

----
$!------------------------
$! -- Set java version 150
$!------------------------
$!
$     write x "$ @DISK$DATA_24:[JAVA$150.COM]JAVA$150_SETUP"
$     write x "$ java :== $DISK$DATA_24:[JAVA$150.bin]java$java"
----
</pre>

<p>
  Called implicitely from CPT$RDB:CPTRDB_THINSRV$STARTUP via
  the jdbc config file RDB$JDBC_COM:TSP1701_CFG_JVM5.XML
</p>
  
<pre>
----
  cfg="rdb$jdbc_com:tsp1701_cfg_jvm5.xml"
  srv.startup="rdb$jdbc_com:rdbjdbc_startsrv_73_150.com"
----
</pre>

<p>
<b>CPTRDB_RDBJDBC_STARTSRV_73_160.COM</b><br>
  Copie of RDB$JDBC_COM:RDBJDBC_STARTSRV.COM, modified to allow for
  meaningfull logfile names, Rdb debug flags and hardcoded JAVA V160 version.
</p>
  
  The additional modified code section is:

<pre>
----
$!------------------------
$! -- Set java version 160
$!------------------------
$!
$     write x "$ @DISK$DATA_24:[JAVA$60.COM]JAVA$60_SETUP"
$     write x "$ java :== $DISK$DATA_24:[JAVA$60.bin]java$java"
----
</pre>

<p>
  Called implicitely from CPT$RDB:CPTRDB_THINSRV$STARTUP via
  the jdbc config file RDB$JDBC_COM:TSP1701_CFG_JVM6.XML
</p>
  
<pre>
----
  cfg="rdb$jdbc_com:tsp1701_cfg_jvm6.xml"
  srv.startup="rdb$jdbc_com:rdbjdbc_startsrv_73_160.com"
----
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 46"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 46 -- List And Check JDBC Processes
</font>
</h3>

<b>CPTRDB_SHOW_JDBC_PROCESS_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_JDBC_PROCESS.COM</b><br>
<b>CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM</b><br><br>

<b>CPTRDB_SHOW_JDBC_PROCESS.REF</b> (Reference file)<br>
<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_JDBC_PROCESS_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_JDBC_PROCESS[_DAILY].COM
</p>

<p>
  List the JDBC processes on one node sorted by process name.

  The process name search strings are listed in the configuration file 
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS.

  Below jdbc thin pool server full process name TSP1701, and regular servers 
  TS170% substrings.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS|L15S29|TSP1701|
CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS|L15S29|TS170|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_JDBC_PROCESS
! 2 Execution node
! 3 Process name (sub)string
</pre>

<p>
<b>CPTRDB_SHOW_JDBC_PROCESS.COM</b><br>
  Calls CPTRDB_SHOW_JDBC_PROCESS_BATCH.COM
</p>

<p>
  Interactive list the JDBC processes on a series of nodes. The list of
  nodes and process name (sub)strings is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS.
</p>

  Output sample:<br>

<pre>
23-APR-2015 15:42:17.21 CPTRDB - JDBC Processes From Node L15S29
 
--------------
On Node L15S28
--------------
 
OpenVMS V8.4  on node L15S28   23-APR-2015 15:42:17.57   Uptime  2 03:21:32
2DC09F48 TS1702          HIB      6    12112   0 00:00:10.85     21165  16260 M 
2DC09F4A TS1703          HIB      6    21687   0 00:00:17.28     30018  16513 M 
2DC0AB45 TS1704          HIB      6    20653   0 00:00:16.70     25683  16731 M 
2DC0A73D TS1705          HIB      6    78004   0 00:02:34.00    167367  35078 M 
2DC09F3A TSP1701         HIB      6    93421   0 00:00:32.06     15911  15909 M 
Number of JDBC processes: 5
 
--------------
On Node L15S29
--------------
 
OpenVMS V8.4  on node L15S29   23-APR-2015 15:42:20.01   Uptime  2 03:02:23
2DE0A6FB TS1702          HIB      6    12122   0 00:00:10.76     19422  17512 M 
2DE0AEFD TS1703          HIB      6    21686   0 00:00:17.68     27651  16190 M 
2DE0AAF9 TS1704          HIB      6    20576   0 00:00:18.01     25216  17259 M 
2DE0AEF7 TS1705          HIB      6    11808   0 00:00:11.04     45936  12015 M 
2DE0A2F5 TSP1701         HIB      6    57385   0 00:00:22.24     17144  16633 M 
Number of JDBC processes: 5
</pre>

<p>
<b>CPTRDB_SHOW_JDBC_PROCESS_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_JDBC_PROCESS_BATCH.COM
</p>

<p>
  Daily list JDBC processes on a series of cluster nodes, enumerated
  in the configuration file CPTRDB_CONFIGURATION.REF, identified by the
  keywords CPT$RDB_NODE|CPTRDB_SHOW_JDBC_PROCESS.

  Send CockpitMgr event and mail if difference found with reference file
  CPTRDB_SHOW_JDBC_PROCESS.REF .

  The reschedule node, time and exception mail address are retrieved from
  the configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_JDBC_PROCESS_DAILY.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_JDBC_PROCESS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_JDBC_PROCESS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_JDBC_ProcessDifferences
"CPTRDB - JDBC Process Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JDBC Processes Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 47"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 47 -- List And Check JDBC Log And Trace Files
</font>
</h3>

<b>CPTRDB_SHOW_JDBC_LOGS_BATCH.COM</b> (Called from)<br>
<b>CPTRDB_SHOW_JDBC_LOGS.COM</b><br>
<b>CPTRDB_SHOW_JDBC_LOGS_DAILY.COM</b><br><br>

<b>CPTRDB_SHOW_JDBC_LOGS.REF</b> (Reference file)<br>
<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_JDBC_LOGS_BATCH.COM </b><br>
  Called from CPTRDB_SHOW_JDBC_LOGS[_DAILY].COM
</p>

<p>
  List the JDBC log and trace files for one node.

  The directories to be listed are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords 
  CPT$RDB_NODE|CPTRDB_SHOW_JDBC_LOGS.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_JDBC_LOGS|L15S29|CPT$RDB_JDBC_LOGDIR|CPT$RDB_JDBC_TRCDIR|CPT$RDB_JDBC_TRCDIRDONE|CPT$RDB_JDBC_THINDIR|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_JDBC_LOGS
! 2 Execution node
! 3 JDBC logfiles directory
! 4 JDBC tracefiles directory
! 5 JDBC tracefiles after client extraction directory
! 6 JDBC clients data directory
</pre>

<p>
<b>CPTRDB_SHOW_JDBC_LOGS.COM</b><br>
  Calls CPTRDB_SHOW_JDBC_LOGS_BATCH.COM
</p>

<p>
  Interactive list the JDBC log and trace files on a series of nodes.

  The list of nodes is enumerated in the configuration file, identified
  by the keywords CPT$RDB_NODE|CPTRDB_SHOW_JDBC_LOGS.
</p>

  Output sample:<br>

<pre>
23-APR-2015 15:46:24.10 CPTRDB - JDBC Logfiles From Node L15S29
 
--------------
On Node L15S28
--------------

Directory SYS$COMMON:[RDB$JDBC.LOGS]

POOLOUT_TSP1701_L15S28_20150423.LOG_23APR001606;1
                           3/16       23-APR-2015 00:16:06.64
SRVERR_TS1702_L15S28_20150423.LOG_23APR001621;1
                           0/0        23-APR-2015 00:16:21.86
SRVERR_TS1703_L15S28_20150423.LOG_23APR001624;1
                           0/0        23-APR-2015 00:16:24.39
SRVERR_TS1704_L15S28_20150423.LOG_23APR001619;1
                           0/0        23-APR-2015 00:16:19.25
SRVERR_TS1705_L15S28_20150423.LOG_23APR001608;1
                           0/0        23-APR-2015 00:16:08.75
SRVLOG_TS1702_L15S28_20150423.LOG_23APR001621;1
                           8/16       23-APR-2015 00:16:21.87
SRVLOG_TS1703_L15S28_20150423.LOG_23APR001624;1
                           8/16       23-APR-2015 00:16:24.41
SRVLOG_TS1704_L15S28_20150423.LOG_23APR001619;1
                           8/16       23-APR-2015 00:16:19.27
SRVLOG_TS1705_L15S28_20150423.LOG_23APR001608;1
                           8/16       23-APR-2015 00:16:08.75
SRVOUT_TS1702_L15S28_20150423.LOG_23APR001621;1
                           1/16       23-APR-2015 00:16:21.85
SRVOUT_TS1703_L15S28_20150423.LOG_23APR001624;1
                           1/16       23-APR-2015 00:16:24.37
SRVOUT_TS1704_L15S28_20150423.LOG_23APR001619;1
                           1/16       23-APR-2015 00:16:19.21
SRVOUT_TS1705_L15S28_20150423.LOG_23APR001608;1
                           1/16       23-APR-2015 00:16:08.71

Total of 13 files, 39/144 blocks.

Directory DISK$DATA_29:[JDBC_TRACE_FILES]

SRVTRC_TS1702_L15S28_20150423.LOG_23APR001621;1
                           0/576      23-APR-2015 00:16:23.50
SRVTRC_TS1703_L15S28_20150423.LOG_23APR001624;1
                           0/1056     23-APR-2015 00:16:25.62
SRVTRC_TS1704_L15S28_20150423.LOG_23APR001619;1
                           0/1056     23-APR-2015 00:16:20.89
SRVTRC_TS1705_L15S28_20150423.LOG_23APR001608;1
                           0/27744    23-APR-2015 00:16:18.25

Total of 4 files, 0/30432 blocks.

Directory DISK$DATA_29:[JDBC_TRACE_FILES.DONE]

SRVTRC_TS1702_L15S28_20150422.LOG_22APR001628;1
                         800/864      22-APR-2015 00:16:29.42
SRVTRC_TS1703_L15S28_20150422.LOG_22APR001630;1
                        1632/1632     22-APR-2015 00:16:32.10
SRVTRC_TS1704_L15S28_20150422.LOG_22APR001625;1
                        1632/1632     22-APR-2015 00:16:27.73
SRVTRC_TS1705_L15S28_20150422.LOG_22APR001613;1
                       28800/28800    22-APR-2015 00:16:24.44

Total of 4 files, 32864/32928 blocks.

Directory DISK$USERS:[ORACLE.RDB$PROCS.THIN]

SRVTRC_CLIENTS_L15S28_TS1702_20150422.LIS_23APR030000;1
                          33/96       23-APR-2015 03:00:01.14
SRVTRC_CLIENTS_L15S28_TS1703_20150422.LIS_23APR030001;1
                          66/96       23-APR-2015 03:00:02.93
SRVTRC_CLIENTS_L15S28_TS1703_20150422.LIS_23APR040000;2
                          66/96       23-APR-2015 04:00:02.37
SRVTRC_CLIENTS_L15S28_TS1704_20150422.LIS_23APR030003;1
                          66/96       23-APR-2015 03:00:04.63
SRVTRC_CLIENTS_L15S28_TS1704_20150422.LIS_23APR040002;2
                          66/96       23-APR-2015 04:00:04.23
SRVTRC_CLIENTS_L15S28_TS1705_20150422.LIS_23APR030004;1
                         150/192      23-APR-2015 03:00:08.74

Total of 6 files, 447/672 blocks.
 
--------------
On Node L15S29
--------------

Directory SYS$COMMON:[RDB$JDBC.LOGS]

POOLOUT_TSP1701_L15S29_20150423.LOG_23APR001643;1
                           3/16       23-APR-2015 00:16:43.80
SRVERR_TS1702_L15S29_20150423.LOG_23APR001650;1
                           0/0        23-APR-2015 00:16:50.61
SRVERR_TS1703_L15S29_20150423.LOG_23APR001653;1
                           0/0        23-APR-2015 00:16:53.15
SRVERR_TS1704_L15S29_20150423.LOG_23APR001648;1
                           0/0        23-APR-2015 00:16:48.10
SRVERR_TS1705_L15S29_20150423.LOG_23APR001645;1
                           0/0        23-APR-2015 00:16:45.54
SRVLOG_TS1702_L15S29_20150423.LOG_23APR001650;1
                           8/16       23-APR-2015 00:16:50.62
SRVLOG_TS1703_L15S29_20150423.LOG_23APR001653;1
                           8/16       23-APR-2015 00:16:53.16
SRVLOG_TS1704_L15S29_20150423.LOG_23APR001648;1
                           8/16       23-APR-2015 00:16:48.11
SRVLOG_TS1705_L15S29_20150423.LOG_23APR001645;1
                           8/16       23-APR-2015 00:16:45.55
SRVOUT_TS1702_L15S29_20150423.LOG_23APR001650;1
                           1/16       23-APR-2015 00:16:50.60
SRVOUT_TS1703_L15S29_20150423.LOG_23APR001653;1
                           1/16       23-APR-2015 00:16:53.13
SRVOUT_TS1704_L15S29_20150423.LOG_23APR001648;1
                           1/16       23-APR-2015 00:16:48.08
SRVOUT_TS1705_L15S29_20150423.LOG_23APR001645;1
                           1/16       23-APR-2015 00:16:45.53

Total of 13 files, 39/144 blocks.

Directory DISK$DATA_29:[JDBC_TRACE_FILES]

SRVTRC_TS1702_L15S29_20150423.LOG_23APR001650;1
                           0/576      23-APR-2015 00:16:52.09
SRVTRC_TS1703_L15S29_20150423.LOG_23APR001653;1
                           0/1056     23-APR-2015 00:16:54.63
SRVTRC_TS1704_L15S29_20150423.LOG_23APR001648;1
                           0/1056     23-APR-2015 00:16:49.59
SRVTRC_TS1705_L15S29_20150423.LOG_23APR001645;1
                           0/576      23-APR-2015 00:16:47.26

Total of 4 files, 0/3264 blocks.

Directory DISK$DATA_29:[JDBC_TRACE_FILES.DONE]

SRVTRC_TS1702_L15S29_20150422.LOG_22APR001654;1
                         800/864      22-APR-2015 00:16:55.53
SRVTRC_TS1703_L15S29_20150422.LOG_22APR001656;1
                        1632/1632     22-APR-2015 00:16:58.16
SRVTRC_TS1704_L15S29_20150422.LOG_22APR001651;1
                        1632/1632     22-APR-2015 00:16:52.84
SRVTRC_TS1705_L15S29_20150422.LOG_22APR001648;1
                         800/864      22-APR-2015 00:16:50.42

Total of 4 files, 4864/4992 blocks.

Directory DISK$USERS:[ORACLE.RDB$PROCS.THIN]

SRVTRC_CLIENTS_L15S29_TS1702_20150422.LIS_23APR030009;1
                          33/96       23-APR-2015 03:00:10.10
SRVTRC_CLIENTS_L15S29_TS1703_20150422.LIS_23APR030010;1
                          66/96       23-APR-2015 03:00:11.76
SRVTRC_CLIENTS_L15S29_TS1704_20150422.LIS_23APR030012;1
                          66/96       23-APR-2015 03:00:13.74
SRVTRC_CLIENTS_L15S29_TS1705_20150422.LIS_23APR030013;1
                          33/96       23-APR-2015 03:00:14.67

Total of 4 files, 198/384 blocks.
 
</pre>

<p>
<b>CPTRDB_SHOW_JDBC_LOGS_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_JDBC_LOGS_BATCH.COM
</p>

<p>
  Daily list JDBC log and trace files on a series of nodes, enumerated
  in the configuration file, identified by the keywords
  CPT$RDB_NODE|CPTRDB_SHOW_JDBC_LOGS.

  Send CockpitMgr event and mail if difference found with reference file
  CPTRDB_SHOW_JDBC_LOGS.REF.

  An additional jdbc restart on the previous day will create an extra
  file in the CPT$RDB_JDBC_TRCDIRDONE directory and trigger an exception.

  The reschedule node, time and exception mail address are retrieved
  from the configuration file, identified by the keywords
  CPT$RDB_JOB|CPTRDB_SHOW_JDBC_LOGS_DAILY
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SHOW_JDBC_LOGS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_JDBC_LOGS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_JDBC_LogfilesDifferences
"CPTRDB - JDBC Logfiles Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JDBC Logfiles Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 48"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 48 -- Extract And List JDBC Thin Server Clients
</font>
</h3>

<b>CPTRDB_SRVTRC_CLIENTS_ALL.COM</b> (Calls)<br>
<b>CPTRDB_SRVTRC_CLIENTS_73020.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73100.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73202.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73402.COM</b><br><br>

<b>CPTRDB_SRVTRC_CLIENTS_73202_ONE.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br><br>

<b>CPTRDB_JDBC_TRC_LIST_CLIENTS.COM</b><br>
<b>CPTRDB_JDBC_TRC_LIST_SQL.COM</b><br>
<b>CPTRDB_JDBC_TRC_LIST_TIME.COM</b><br>
<b>CPTRDB_JDBC_TRC_LIST_TRANS.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

The procedures in this chapter assume:<br>

<pre>
. The pooled thin servers are restarted daily
. The startup files are modified to provide meaningful names for output, log,
   error and trace files, 
. The trace level is set to 0x40000400
. The trace files format is 
  {trcdir}:SRVTRC_{server name}_{server node}_yyyymmdd.LOG_ddmmmhhmmss
</pre>
 
<p>
Refer to the chapter <a href="#Chapter 45">§ -- 45 -- Restart JDBC Thin Servers</a> on 
how to modify RDB$JDBC_COM:RDBJDBC_STARTSRV.COM to obtain meaningful output 
filenames for the thin server processes.
</p>

<p>
<b>CPTRDB_SRVTRC_CLIENTS_ALL.COM</b><br>
  Parse yesterday's list of Rdb JDBC thin server/node trace files
  level 0x40000400 for ip address and client info.<br>

  Calls CPTRDB_SRVTRC_CLIENTS_nnnnn.COM per server/node, depending on the
  JDBC version running.<br>

  The list of trace files is enumerated in the configuration file 
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|CPTRDB_SRVTRC_CLIENTS_ALL
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_SRVTRC_CLIENTS_ALL|TS1702|L15S28|YESTERDAY|L15S29|
! 
! 0 CPT$RDB_DATABASE
! 1 CPTRDB_SRVTRC_CLIENTS_ALL
! 2 Server id / Database
! 3 Server node
! 4 Reference date
! 5 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file
  identified by the keywords CPT$RDB_JOB|CPTRDB_SRVTRC_CLIENTS_ALL
</p>

<pre>
CPT$RDB_JOB|CPTRDB_SRVTRC_CLIENTS_ALL|L15S29|TOMORROW + 04:00|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SRVTRC_CLIENTS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>CPTRDB_SRVTRC_CLIENTS_73020.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73100.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73202.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73402.COM</b><br>
  Called from CPTRDB_SRVTRC_CLIENTS_ALL.COM
</p>

<p>
  Parse one daily Rdb JDBC thin server/node trace file level 0x40000400
  for ip address and client info.<br>

  Send a CockpitMgr event and mail if no trace file or no clients are found.<br>

  The input and output directories are listed in the configuration file
  identified by the keywords CPT$RDB_PARAM|CPTRDB_SRVTRC_CLIENTS_73402
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_SRVTRC_CLIENTS_73402|CPT$RDB_JDBC_TRCDIR|CPT$RDB_JDBC_TRCDIRDONE|CPT$RDB_JDBC_THINDIR|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_SRVTRC_CLIENTS_73402
! 2 Trace source directory
! 3 Trace rename directory
! 4 Extract output directory
! 5 Exception mail address
</pre>

<p>
  Each procedure is JDBC version specific, as the format of the client info
  in the trace file is version dependent, and the parsing subroutine is
  different.
</p>

  Input trace file extracts per version:<br>

<p>
V73020
</p>

<pre>
>> RDB$CLIENT_ID_00000002 C00000000 2010-03-09 11:34:19.363 : 
srv.DBActionHandler@7b6889( "id=00000002,name=JDBCMON,db=clio_db,ip=10.3.130.172:62695,processID=24D17892:1" )
</pre>

<p>
V73100
</p>

<pre>
>> RDB$CLIENT_ID_00000002 C00000000*T 2012-05-20 23:18:44.011 : srv.DBActionHandler@15212bc( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.172:62274
  ,processID=28D036FE
  ,version=73100:20120227" )
</pre>

<p>
V73202, compatible V73310, V73323
</p>

<pre>
>> RDB$CLIENT_ID_00000002 C00000000*T 2016-04-05 0:24:06.490 : srv.DBActionHandler@7a148bd3( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=ssp_db
  ,ip=10.3.130.193:65382
  ,processID=28A14E53:2
  ,version=73202:20130501" )
>> RDB$CLIENT_ID_00000002 C00000000*T 2016-04-05 0:24:06.744 : [RdbProcessId] .doAction msg : 28A14E53:1
</pre>
 
<p>
V73323
</p>

<pre>
>> RDB$CLIENT_ID_00000002 C00000000*T 2015-04-09 0:18:44.965 : srv.DBActionHandler@377653ae( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=c170_db
  ,ip=10.3.130.172:53300
  ,processID=2D8678A5:1
  ,version=73323:20141224" )
>> RDB$CLIENT_ID_00000002 C00000000*T 2015-04-09 0:18:45.174 : [RdbProcessId] .doAction msg : 2D8678A5:1
</pre>

<p>
V73402, compatible V73410, V73503, V73510, V73520
</p>

<pre>
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2016-03-31 0:18:43.029 : srv.DBActionHandler@77827284( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=c170_db
  ,ip=10.3.130.172:55416
  ,processID=2DCC04FF:1
  ,version=73402:20150626" )
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2016-03-31 0:18:43.282 : [RdbProcessId]  msg : 2DCC04FF:1
</pre>

<p>
V73410
</p>

<pre>
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2016-03-31 16:08:43.766 : srv.DBActionHandler@77827284( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=c170_db
  ,ip=10.3.130.172:58524
  ,processID=2DCB3215:1
  ,version=73410:20160222" )
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2016-03-31 16:08:44.016 : [RdbProcessId]  msg : 2DCB3215:1
</pre>

<p>
V73503
</p>

<pre>
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2017-10-01 0:18:44.470 : srv.DBActionHandler@4e99353f( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.172:54486
  ,processID=2FA2AA7E:1
  ,version=73503:20170830" )
>40000400> JDBC SubscriberThread C00000000*T 2017-10-01 0:18:44.470 : srv.ConnectContext@58a17083.getMemUsage( [null], false )
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2017-10-01 0:18:44.670 : [RdbProcessId]  msg : 2FA2AA7E:1
</pre>

<p>
V73510
</p>

<pre>
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2018-04-12 15:44:28.058 : srv.DBActionHandler@7cf1bb78( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.173:57107
  ,processID=2FE60296:1
  ,version=73510:20180227" )
>40000400> JDBC SubscriberThread C00000000*T 2018-04-12 15:44:28.058 : srv.ConnectContext@692a3722.getMemUsage( [null], false )
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2018-04-12 15:44:28.309 : [RdbProcessId]  msg : 2FE60296:1
</pre>

<p>
V73520
</p>

<pre>
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2019-05-08 00:18:49.263 : srv.DBActionHandler@3603820e.( "client info", "
  id=00000002
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.172:61872
  ,processID=30D9A5FF:2
  ,version=73520:20190408" )
>40000400> JDBC SubscriberThread C00000000*T 2019-05-08 00:18:49.263 : srv.ConnectContext@452bb7e0.getMemUsage( [null], false )
>40000400> RDB$CLIENT_ID_00000002 C00000000*T 2019-05-08 00:18:49.466 : [RdbProcessId] .[RdbProcessId] ( "30D9A5FF:1" )
</pre>

  The client info listed per new client is:<br>

<pre>
Timestamp
Client ip address
Database
User
Thin server process id / Thread id
Remote port number
RDB$CLIENT_ID
Client JDBC version
Thin server process id / Rdb stream id -- Min JDBC V73202, Min Rdb v7.2-50 !!
</pre>

<p>
  The [RdbProcessId] lines from the trace files that cannot be linked in
  sequence to a corresponding "client info" line are listed as is.
  This assures that all Rdb stream id's and their client id's are visible.
</p>

<p>
  The Rdb stream id allows to uniquely link a query to the stream id
  displayed in stall logs, monitor logs and RMU/Show Statistics screens.
</p>

  Output sample:<br>

<pre>
2016-09-21 11:35:00.667|10.2.47.83|ssp_db|LISA_TEST|2DC67C83:1|52025|RDB$CLIENT_ID_000004E2|73202:20130501|2DC67C83:625
2016-09-21 11:35:22.234|10.2.47.82|ssp_db|LISA_TEST|2DC67C83:1|39159|RDB$CLIENT_ID_000004E4|73202:20130501|2DC67C83:626
2016-09-21 11:36:05.333|10.2.47.83|ssp_db|LISA_TEST|2DC67C83:1|41543|RDB$CLIENT_ID_000004E6|73202:20130501|2DC67C83:627
>40000400> RDB$CLIENT_ID_000004EA C00000000*T 2016-09-21 11:37:14.993 : [RdbProcessId] msg : 2DC67C83:629
2016-09-21 11:37:14.993|10.2.47.82|ssp_db|LISA_TEST|2DC67C83:1|51916|RDB$CLIENT_ID_000004E9|73202:20130501|2DC67C83:628
2016-09-21 11:40:03.027|10.2.47.83|ssp_db|LISA_TEST|2DC67C83:1|58219|RDB$CLIENT_ID_000004EC|73202:20130501|2DC67C83:630
2016-09-21 11:40:03.575|10.3.130.172|ssp_db_vdd|JDBCMON|2DC67C83:1|54590|RDB$CLIENT_ID_000004EE|73410:20160222|2DC67C83:631
</pre>

<p>
  In JDBC V73520 the [RdbProcessId] in the output file is surrounded by
  double quotes, as listed below.
</p>

<pre>
2019-05-12 00:18:48.231|10.3.130.173|clio_db|JDBCMON|3116347C:3|56496|RDB$CLIENT_ID_00000002|73520:20190408|"3116347C:1"
2019-05-12 00:23:54.211|10.3.130.173|clio_db|JDBCMON|3116347C:3|56506|RDB$CLIENT_ID_00000004|73520:20190408|"3116347C:2"
2019-05-12 00:29:12.406|10.3.130.173|clio_db|JDBCMON|3116347C:1|56526|RDB$CLIENT_ID_00000006|73520:20190408|"3116347C:3"
2019-05-12 00:34:18.631|10.3.130.173|clio_db|JDBCMON|3116347C:2|56536|RDB$CLIENT_ID_00000008|73520:20190408|"3116347C:4"
2019-05-12 00:39:37.170|10.3.130.173|clio_db|JDBCMON|3116347C:2|56556|RDB$CLIENT_ID_0000000A|73520:20190408|"3116347C:5"
</pre>

Toolset CockpitMgr event:<br>

<pre>
"CPTRDB_SRVTRC_NoClients"
"CPTRDB - SRVTRC No Clients {server} {node} {refdate} - ddmmmhhmmss"
</pre>

   Mail subject:<br>

<pre>
"CPTRDB - SRVTRC No Clients {server} {node} {refdate}"
</pre>

<p>
<b>CPTRDB_SRVTRC_CLIENTS_73202_ONE.COM</b><br>
<b>CPTRDB_SRVTRC_CLIENTS_73402_ONE.COM</b><br>
  Standalone parse one Rdb JDBC thin server/node/day trace file level 0x40000400
  for ip address and client info.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-------------------------
$ nodeid     = "L15S28"
$ servid     = "TS1703"
$ refdatein  = "2015-03-18"
$ trcdir     = "CPT$RDB:"
$ trcdirdone = "CPT$RDB:"
$ outdir     = "CPT$RDB:"
$!-------------------------
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_SRVTRC_CLIENTS_73402_ONE
</pre>

<p>
[As the Rdb JDBC trace files contain 'long' lines that prevent the use of a 
 normal editor to read them, the CPTRDB_JDBC_TRC*.COM procedures below are based
 on the DCL SEARCH command, and/or handle the input file line per line.]
</p>

<p>
<b>CPTRDB_JDBC_TRC_LIST_CLIENTS.COM</b><br>
  List all clients from a hardcoded Rdb JDBC level 0X40000400 trace file.
</p>

<p>
  Parameters: Adapt the input trace file filespec and/or the SEARCH command.
</p>

<p>
  *Adapt the SEARCH items to the JDBC version being used*
</p>

<pre>
$!------------------------------------------------------------------
$ trcfile = "''datdir'SRVTRC_TS1703_L15S58_20180917.LOG_17SEP195428"
$!------------------------------------------------------------------
</pre>

<p>
  Search items:
</p>

<pre>
!! "New Client", -
!! ".doAction.INIT_V713(", -
!! ".doAction.CONNECT_SECURE_V73(", -
"Client connecting", -
"client info", -
",name=", -
",db=", -
",ip=", -
",processID=", -
",version=", -
"[RdbProcessId]", -
!! ".doAction.DISCONNECT(", - ! V73510
   ".doAction.DISCONNECT", -  ! V73520
".forceDisconnect.<FORCED DISCONNECT>(", -
"RdbException", -
"-E-", -
"-F-"
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_JDBC_TRC_LIST_CLIENTS 
</pre>

<p>
  The procedure lists the raw data lines default in the CPT$RDB_LISTS: directory
  without any formatting.
</p>

<p>
  Output sample:
</p>

<pre>
>> RDB$CLIENT_ID_0000002D C00000000*T 2018-09-17 20:01:14.851 : srv.DBClientHandler@7bcd107f.message msg : New Client initiating RDB$CLIENT_ID_0000002D
>> RDB$CLIENT_ID_0000002E C00000000*T 2018-09-17 20:01:14.901 : srv.DBClientHandler@67a5a19.message msg : New Client initiating RDB$CLIENT_ID_0000002E
>40000400> RDB$CLIENT_ID_0000002E C00000000*T 2018-09-17 20:01:15.046 : srv.DBActionHandler@2cf18e8e( "client info", "
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.191:54490
  ,processID=29E96F42:3
  ,version=73410:20160222" )
>40000400> RDB$CLIENT_ID_0000002E C00000000*T 2018-09-17 20:01:15.046 : [RdbProcessId]  msg : 29E96F42:23
>00000400> RDB$CLIENT_ID_0000002E C00000000*T 2018-09-17 20:01:15.246 : srv.DBActionHandler@2cf18e8e.doAction.DISCONNECT(  )
>00000400> RDB$CLIENT_ID_0000002C C00000000*T 2018-09-17 20:01:33.381 : srv.DBActionHandler@a81b1fb.doAction.DISCONNECT(  )
>> RDB$CLIENT_ID_0000002F C00000000*T 2018-09-17 20:01:39.888 : srv.DBClientHandler@6d372656.message msg : New Client initiating RDB$CLIENT_ID_0000002F
>> RDB$CLIENT_ID_00000030 C00000000*T 2018-09-17 20:01:39.988 : srv.DBClientHandler@69d6065.message msg : New Client initiating RDB$CLIENT_ID_00000030
>40000400> RDB$CLIENT_ID_00000030 C00000000*T 2018-09-17 20:01:40.099 : srv.DBActionHandler@2c8376b( "client info", "
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.191:54497
  ,processID=29E96F42:3
  ,version=73410:20160222" )
>40000400> RDB$CLIENT_ID_00000030 C00000000*T 2018-09-17 20:01:40.149 : [RdbProcessId]  msg : 29E96F42:24
>00000400> RDB$CLIENT_ID_00000030 C00000000*T 2018-09-17 20:01:40.299 : srv.DBActionHandler@2c8376b.doAction.DISCONNECT(  )
>> RDB$CLIENT_ID_00000031 C00000000*T 2018-09-17 20:02:47.366 : srv.DBClientHandler@1629ce8c.message msg : New Client initiating RDB$CLIENT_ID_00000031
>> RDB$CLIENT_ID_00000032 C00000000*T 2018-09-17 20:02:47.416 : srv.DBClientHandler@359eda2c.message msg : New Client initiating RDB$CLIENT_ID_00000032
>40000400> RDB$CLIENT_ID_00000032 C00000000*T 2018-09-17 20:02:47.576 : srv.DBActionHandler@ffdadcd( "client info", "
  ,name=JDBCMON
  ,db=clio_db
  ,ip=10.3.130.191:54505
  ,processID=29E96F42:2
  ,version=73410:20160222" )
>40000400> RDB$CLIENT_ID_00000032 C00000000*T 2018-09-17 20:02:47.628 : [RdbProcessId]  msg : 29E96F42:25
>00000400> RDB$CLIENT_ID_00000032 C00000000*T 2018-09-17 20:02:47.778 : srv.DBActionHandler@ffdadcd.doAction.DISCONNECT(  )
</pre>

<p>
<b>CPTRDB_JDBC_TRC_LIST_SQL.COM</b><br>
  List all sql statements for a given client from a hardcoded Rdb JDBC level
  0X40000400 trace file.<br>
  Number the sql statements and split the output lines in char(132) segments.
</p>

<p>
  Parameters: Adapt the input trace file filespec and client id 
</p>

<p>
  *Adapt the SEARCH items to the JDBC version being used*
</p>

<pre>
$!-------------------------------------------------------------------
$ trcfile  = "''datdir'SRVTRC_TS1703_L15S58_20180601.LOG_01JUN002139"
$   srchstr1 = ">> sql> .>> sql>" ! V73520
$!$ srchstr1 = ">> sql>"          ! V73510
$!$ srchstr2 = "RDB$CLIENT_ID_0000015C"
$!-------------------------------------------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_JDBC_TRC_LIST_SQL 
</pre>

<p>
  The output file is default created in the CPT$RDB_LISTS: directory.
</p>

<p>
  Output sample:<br>
  (Statements generated by the 'Hibernate' product)
</p>

<pre>
-- 2 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.455 : >> sql>  msg : select disability0_.HANDICAP_ID as HANDICAP1_3
0_0_, disability0_.HANDICAP_CD as HANDICAP2_30_0_, disability0_.DSCRPN_F as DSCRPN3_30_0_, disability0_.DSCRPN_D as DSCRPN4_30_0_, d
isability0_.DSCRPN_G as DSCRPN5_30_0_, disability0_.DSCRPN_E as DSCRPN6_30_0_, disability0_.TIME_STAMP as TIME7_30_0_, disability0_.
USER_FNGR_PRNT as USER8_30_0_, disability0_.APPLCTN_ID as APPLCTN9_30_0_ , dbkey as RDB$JDBC_ROW_ID from CLIO_HANDICAPS disability0_
 where disability0_.HANDICAP_ID=?
------------------------------------------------------------------------------------------------------------------------------------
-- 3 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.505 : >> sql>  msg : select addresstyp0_.ADR_TYPE_ID as ADR1_1_0_, 
addresstyp0_.HIBVERSION as HIBVERSION1_0_, addresstyp0_.ADR_TYPE_CD as ADR2_1_0_, addresstyp0_.DSCRPN_F as DSCRPN3_1_0_, addresstyp0
_.DSCRPN_D as DSCRPN4_1_0_, addresstyp0_.DSCRPN_G as DSCRPN6_1_0_, addresstyp0_.DSCRPN_E as DSCRPN5_1_0_, addresstyp0_.TIME_STAMP as
 TIME7_1_0_, addresstyp0_.USER_FNGR_PRNT as USER8_1_0_, addresstyp0_.APPLCTN_ID as APPLCTN9_1_0_ , dbkey as RDB$JDBC_ROW_ID from CLI
O_ADR_TYPES addresstyp0_ where addresstyp0_.ADR_TYPE_ID=?
------------------------------------------------------------------------------------------------------------------------------------
-- 4 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.505 : >> sql>  msg : select applicatio0_.APPLCTN_ID as APPLCTN1_37_
0_, applicatio0_.APPLCTN_CD as APPLCTN2_37_0_, applicatio0_.DSCRPN_F as DSCRPN3_37_0_, applicatio0_.DSCRPN_D as DSCRPN4_37_0_, appli
catio0_.DSCRPN_G as DSCRPN5_37_0_, applicatio0_.DSCRPN_E as DSCRPN6_37_0_ , dbkey as RDB$JDBC_ROW_ID from CLIO_APPLCTNS applicatio0_
 where applicatio0_.APPLCTN_ID=?
------------------------------------------------------------------------------------------------------------------------------------
-- 5 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.616 : >> sql>  msg : select linkedkeys0_.INTRN_KEY_ID as INTRN3_1_,
 linkedkeys0_.LNK_KEY_ID as LNK1_1_, linkedkeys0_.LNK_KEY_ID as LNK1_17_0_, linkedkeys0_.INTRN_KEY_TYPE_ID as INTRN2_17_0_, linkedke
ys0_.INTRN_KEY_ID as INTRN3_17_0_, linkedkeys0_.XTRN_KEY_TYPE_ID as XTRN4_17_0_, linkedkeys0_.XTRN_KEY_VALUE as XTRN5_17_0_, linkedk
eys0_.TIME_STAMP as TIME6_17_0_, linkedkeys0_.USER_FNGR_PRNT as USER7_17_0_ , dbkey as RDB$JDBC_ROW_ID from CLIO_LNK_KEYS linkedkeys
0_ where  ( linkedkeys0_.INTRN_KEY_TYPE_ID=1)  and linkedkeys0_.INTRN_KEY_ID=?
------------------------------------------------------------------------------------------------------------------------------------
-- 6 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.666 : >> sql>  msg : select bankaccoun0_.BANK_ACCT_ID as BANK1_2_, 
bankaccoun0_.CLNT_ID as CLNT13_2_, bankaccoun0_.SEQ_NO as SEQ3_2_, bankaccoun0_.BANK_OFFC_ID as BANK4_2_, bankaccoun0_.BANK_ACCT_NO 
as BANK14_2_, bankaccoun0_.BANK_IBAN_CD as BANK5_2_, bankaccoun0_.BANK_ACCT_OWNER as BANK7_2_, bankaccoun0_.BANK_ACCT_TYPE as BANK8_
2_, bankaccoun0_.BANK_ACCT_COMMENT as BANK9_2_, bankaccoun0_.TIME_STAMP as TIME10_2_, bankaccoun0_.USER_FNGR_PRNT as USER11_2_, bank
accoun0_.APPLCTN_ID as APPLCTN12_2_ , dbkey as RDB$JDBC_ROW_ID from CLIO_BANK_ACCTS bankaccoun0_ where (bankaccoun0_.CLNT_ID=3892115
 ) order by  bankaccoun0_.SEQ_NO DESC LIMIT 1
------------------------------------------------------------------------------------------------------------------------------------
-- 7 --
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-06-01 0:39:22.716 : >> sql>  msg : select * , dbkey as RDB$JDBC_ROW_ID from clio_
clnts where clnt_id='3892115'
------------------------------------------------------------------------------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_JDBC_TRC_LIST_TIME.COM</b><br>
  List timestamp interval lines from a hardcoded Rdb JDBC level 0X40000400
  trace file.<br> 
  Trunc the output lines to char(132) segments.
</p>

<p>
  Parameters: Adapt the input trace file filespec and timestamp string.
</p>

<p>
  *Adapt the SEARCH items to the JDBC version being used*
</p>

<pre>
$!------------------------------------------------------------------
$ trcfile = "''datdir'SRVTRC_TS1703_L15S58_20180601.LOG_01JUN002139"
$ timestr = "2018-06-01 10:00:00."
$!$ timestr2 = ">> sql> .>> sql>" ! V73520
$!$ timestr3 = "RDB$CLIENT_ID_000000E2"
$!------------------------------------------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_JDBC_TRC_LIST_TIME
</pre>

<p>
  The output file is default created in the CPT$RDB_LISTS: directory.
</p>

<p>
  Output sample:
</p>

<pre>
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.SET_DEF_TRANS(  )
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.SET_DEF_TRANS(  )
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.PREPARE_STMT(  )
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : >>  msg : PREPARE_STMT
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : >> sql>  msg : SELECT TA_BE_ROAD_ID, NAME, UPPERNAME, LC, ST
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.SELECT(  )
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 :  >>  msg : SELECT
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : [[num records]]  msg : 100
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.FETCH_READ_ROW(  )
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 :  >>  msg : FETCH_READ_ROW
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : [[num records]]  msg : 100
>00000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 : srv.DBActionHandler@2aaf914c.doAction.FETCH_READ_ROW(  )
>40000400> RDB$CLIENT_ID_0000018E C00000000*T 2018-06-01 10:00:00.378 :  >>  msg : FETCH_READ_ROW
</pre>

<p>
<b>CPTRDB_JDBC_TRC_LIST_TRANS.COM</b><br>
  List the transactons from a hardcoded Rdb JDBC level 0X40000400 trace file.<br>
  Sort the output lines on client id and time.<br>
  List the first char(132) segment and calculate the elapsed time per client.<br>
  Allow search and sort on start, end and elapsed time.
</p>
  
<p>
  Parameters: Adapt the input trace file filespec and/or SEARCH command
</p>

<p>
  *Adapt the SEARCH items to the JDBC version being used*
</p>

<pre>
$!------------------------------------------------------------------
$ trcfile = "''datdir'SRVTRC_TS1703_L15S58_20180917.LOG_17SEP195428"
$!------------------------------------------------------------------
</pre>

<p>
Search items:
</p>

<pre>
"[RdbProcessId]", -
!! ">> sql>  msg : select", -       ! V73510
   ">> sql> .>> sql> ( ""select", - ! V73520
">> sql>  msg : select", -
">> sql>  msg : insert", -
">> sql>  msg : update", -
">> sql>  msg : delete", -
!! ".doAction.EXECUTE_BATCH(", -
!! ".doAction.EXECUTE_INSERT(", -
!! ".doAction.EXECUTE_STMT(", -
!! ".doAction.FETCH_READ_ROW(", -
!! ".doAction.CLOSE_CURS(", -
!! ".doAction.PREPARE_STMT(", -
!! ".doAction.RELEASE_STMT(", -
!! ".doAction.SELECT(", -
!! ".doAction.SET_BIN_VAL(", -
!! ".doAction.SET_DATE_VAL_T(", -
!! ".doAction.SET_INT_VAL(", -
!! ".doAction.SET_NULL_IND(", -
!! ".doAction.SET_DEF_TRANS("
!! ".doAction.DISCONNECT(", - ! V73510
   ".doAction.DISCONNECT", -  ! V73520
".doAction.ROLL_TRANS(", -
".doAction.COMMIT_TRANS("
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_JDBC_TRC_LIST_TRANS
</pre>

<p>
  The output file is default created in the CPT$RDB_LISTS: directory.
</p>

<p>
  Output sample:
</p>

<pre>
------------------------------------------------------------------------------------------------------------------------------------
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:31.731 : [RdbProcessId]  msg : 29E96F42:9
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:31.834 : >> sql>  msg : select MASTER_CLNT_ID , dbkey as RDB$JDBC_ROW
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:32.710 : >> sql>  msg : select client0_.CLNT_ID as CLNT1_4_0_, addres
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:33.804 : >> sql>  msg : select addresstyp0_.ADR_TYPE_ID as ADR1_1_0_,
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:34.148 : >> sql>  msg : select applicatio0_.APPLCTN_ID as APPLCTN1_37
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:34.577 : >> sql>  msg : select country0_.CNTRY_ID as CNTRY1_14_0_, co
>40000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:35.554 : >> sql>  msg : select linkedkeys0_.INTRN_KEY_ID as INTRN3_1_
>00000400> RDB$CLIENT_ID_00000010 C00000000*T 2018-09-17 19:54:36.528 : srv.DBActionHandler@21f8c6df.doAction.COMMIT_TRANS(  )
***Start   2018-09-17 19:54:31.73 RDB$CLIENT_ID_00000010
***End     2018-09-17 19:54:36.52 RDB$CLIENT_ID_00000010
***Elapsed          0 00:00:04.79 RDB$CLIENT_ID_00000010
------------------------------------------------------------------------------------------------------------------------------------
>40000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:32.006 : [RdbProcessId]  msg : 29E96F42:2
>40000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:32.108 : >> sql>  msg : SELECT city2.* , dbkey as RDB$JDBC_ROW_ID FRO
>00000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:39.233 : srv.DBActionHandler@462ba11b.doAction.COMMIT_TRANS(  )
>40000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:40.400 : >> sql>  msg : select client0_.CLNT_ID as CLNT1_4_0_, addres
>40000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:42.139 : >> sql>  msg : select linkedkeys0_.INTRN_KEY_ID as INTRN3_1_
>40000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:42.189 : >> sql>  msg : select bankaccoun0_.BANK_ACCT_ID as BANK1_2_,
>00000400> RDB$CLIENT_ID_00000012 C00000000*T 2018-09-17 19:54:42.239 : srv.DBActionHandler@462ba11b.doAction.COMMIT_TRANS(  )
***Start   2018-09-17 19:54:32.00 RDB$CLIENT_ID_00000012
***End     2018-09-17 19:54:42.23 RDB$CLIENT_ID_00000012
***Elapsed          0 00:00:10.23 RDB$CLIENT_ID_00000012
------------------------------------------------------------------------------------------------------------------------------------
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:31.784 : [RdbProcessId]  msg : 29E96F42:7
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:32.237 : >> sql>  msg : select client0_.CLNT_ID as CLNT1_4_0_, addres
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:34.040 : >> sql>  msg : select disability0_.HANDICAP_ID as HANDICAP1_
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:34.527 : >> sql>  msg : select applicatio0_.APPLCTN_ID as APPLCTN1_37
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:35.604 : >> sql>  msg : select linkedkeys0_.INTRN_KEY_ID as INTRN3_1_
>40000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:37.811 : >> sql>  msg : select bankaccoun0_.BANK_ACCT_ID as BANK1_2_,
>00000400> RDB$CLIENT_ID_00000013 C00000000*T 2018-09-17 19:54:38.105 : srv.DBActionHandler@43462851.doAction.COMMIT_TRANS(  )
***Start   2018-09-17 19:54:31.78 RDB$CLIENT_ID_00000013
***End     2018-09-17 19:54:38.10 RDB$CLIENT_ID_00000013
***Elapsed          0 00:00:06.32 RDB$CLIENT_ID_00000013
------------------------------------------------------------------------------------------------------------------------------------
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:31.784 : [RdbProcessId]  msg : 29E96F42:4
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:32.237 : >> sql>  msg : select client0_.CLNT_ID as CLNT1_4_0_, addres
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:33.752 : >> sql>  msg : select disability0_.HANDICAP_ID as HANDICAP1_
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:34.527 : >> sql>  msg : select applicatio0_.APPLCTN_ID as APPLCTN1_37
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:35.187 : >> sql>  msg : select country0_.CNTRY_ID as CNTRY1_14_0_, co
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:35.903 : >> sql>  msg : select linkedkeys0_.INTRN_KEY_ID as INTRN3_1_
>40000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:37.937 : >> sql>  msg : select bankaccoun0_.BANK_ACCT_ID as BANK1_2_,
>00000400> RDB$CLIENT_ID_00000014 C00000000*T 2018-09-17 19:54:38.155 : srv.DBActionHandler@e4ac00c.doAction.COMMIT_TRANS(  )
***Start   2018-09-17 19:54:31.78 RDB$CLIENT_ID_00000014
***End     2018-09-17 19:54:38.15 RDB$CLIENT_ID_00000014
***Elapsed          0 00:00:06.37 RDB$CLIENT_ID_00000014
------------------------------------------------------------------------------------------------------------------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 49"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 49 -- Cleanup JDBC Thin Server Log, Output, Trace And Restart Log Files
</font>
</h3>

<b>CPTRDB_CLEANUP_JDBC_LOGS.COM</b> (Called from)<br>
<b>CPTRDB_CLEANUP_JDBC_LOGS_ALL.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_CLEANUP_JDBC_LOGS.COM</b><br>
  Called from CPTRDB_CLEANUP_JDBC_LOGS_ALL.COM
</p>

<p>
  Cleanup JDBC log and trace files on one cluster node.

  The directories are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_NODE|CPTRDB_CLEANUP_JDBC_LOGS.
</p>

<pre>
CPT$RDB_NODE|CPTRDB_CLEANUP_JDBC_LOGS|L15S28|RDB$JDBC_LOGS|CPT$RDB_JDBC_TRCDIR|CPT$RDB_JDBC_TRCDIRDONE|DISK$USERS:[JDBCMON]|
CPT$RDB_NODE|CPTRDB_CLEANUP_JDBC_LOGS|L15S29|RDB$JDBC_LOGS|CPT$RDB_JDBC_TRCDIR|CPT$RDB_JDBC_TRCDIRDONE|DISK$USERS:[JDBCMON]|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_CLEANUP_JDBC_LOGS
! 2 Execution node
! 3 JDBC log files directory
! 4 JDBC trace files directory
! 5 JDBC extracted trace files directory
! 6 JDBC restart log files directory
</pre>

<p>
  Note that the default log files location RDB$JDBC_LOGS defined as
  SYS$COMMON:[RDB$JDBC.LOGS] is node specific if each node has it's own 
  system disk.
</p>
 
<p>
<b>CPTRDB_CLEANUP_JDBC_LOGS_ALL.COM</b><br>
  Calls CPTRDB_CLEANUP_JDBC_LOGS.COM
</p>

<p>
  Daily cleanup JDBC log and trace files on a series of nodes.

  The list of nodes is enumerated in the configuration file identified by
  the keywords CPT$RDB_NODE|CPTRDB_CLEANUP_JDBC_LOGS.

  The reschedule node and time are retrieved from the configuration file
  identified by the keywords CPT$RDB_JOB|CPTRDB_CLEANUP_JDBC_LOGS_ALL.
</p>

<pre>
CPT$RDB_JOB|CPTRDB_CLEANUP_JDBC_LOGS_ALL|L15S29|TOMORROW + 05:00|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_CLEANUP_JDBC_LOGS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 50"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 50 -- Realy Simple Java JDBC Programs
</font>
</h3>

<b>CPTRDB_JAVA_JDBC.JAVA</b><br>
<b>CPTRDB_JAVA_JDBC_CLIO.JAVA</b><br>
<b>CPTRDB_JAVA_JDBC_BUILD.COM</b><br>
<b>CPTRDB_JAVA_JDBC.CLASS</b><br>
<b>CPTRDB_JAVA_JDBC_CLIO.CLASS</b><br>
<b>CPTRDB_JAVA_JDBC_RUN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_JAVA_JDBC.JAVA</b><br>
  Built using CPTRDB_JAVA_JDBC_BUILD.COM<br>
  Called from CPTRDB_JAVA_JDBC_RUN.COM
</p>

<p>
  Realy simple Java JDBC program, that allows to test JDBC thin servers.
</p>

<pre>
Returns "Hello World / {rdb$database.rdb$file_name>}

Comment out the code below to observe the running thin server.

   /* -- Sleep 900 sec to observe the running thin server
   Thread.currentThread().sleep(900000);
   */
</pre>

<p>
<b>CPTRDB_JAVA_JDBC_CLIO.JAVA</b><br>
  Built using CPTRDB_JAVA_JDBC_BUILD.COM<br>
  Called from CPTRDB_JAVA_JDBC_RUN.COM
</p>

<p>
  A more elaborated simple Java JDBC program, that executes a query generated
  by the 'Hibernate' product.
  Illustrates the construction of a query.
</p>

<pre>
Returns address data from the CLIO database.

Comment out the code below to observe the running thin server.

   /* -- Sleep 900 sec to observe the running thin server
   Thread.currentThread().sleep(900000);
   */
</pre>

<p>
<b>CPTRDB_JAVA_JDBC_BUILD.COM</b><br>
  Build file for CPTRDB_JAVA_JDBC.JAVA and
                 CPTRDB_JAVA_JDBC_CLIO.JAVA
</p>

<p>
<b>CPTRDB_JAVA_JDBC.CLASS</b><br>
<b>CPTRDB_JAVA_JDBC_CLIO.CLASS</b><br>

  Executable java byte code for CPTRDB_JAVA_JDBC.JAVA and
                                CPTRDB_JAVA_JDBC_CLIO.JAVA
</p>

<p>
<b>CPTRDB_JAVA_JDBC_RUN.COM</b><br>
  Run command file for CPTRDB_JAVA_JDBC.JAVA and
                       CPTRDB_JAVA_JDBC_CLIO.JAVA
</p>

  Usage:<br>

<pre>
$ @CPTRDB_JAVA_JDBC_RUN {dbid}
</pre>

<p>
  The database CLIO_DB is hardcoded for CPTRDB_JAVA_JDBC_CLIO.JAVA
</p>

  Output sample:<br>

<pre>
$ @CPTRDB_JAVA_JDBC_RUN clio_db
Hello World / DSA25:[CLIO_DB]CLIO_DB.RDB;1
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 51"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 51 -- Replicate Data Using The JCC Logminer Loader
</font>
</h3>

<b>CPTRDB_LML_ALL_TABLE.INI</b><br>
<b>CPTRDB_LML_ALL_MAPTABLE.INI</b><br>
<b>CPTRDB_LML_ALL_FILTERMAP.INI</b><br><br>

<b>JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM</b><br>
<b>CPTRDB_LML_UNLOAD.OPT</b><br>
<b>CPTRDB_LML_CONTROL.INI</b><br>
<b>CPTRDB_LML_TABLE_PLACE_TABLE.INI</b><br>
<b>CPTRDB_LML_TABLE_PLACE_MAPTABLE.INI</b><br>
<b>CPTRDB_LML_FILTERMAP.INI</b><br><br>

<b>JCCLML_RDB$MAX_VERSION.COM</b><br>
<b>JCCLML_VMS_FUNCTIONS.SQL</b><br>
<b>JCCLML_CREATE_LOGMINER_HIGHWATER.SQL</b><br>
<b>JCCLML_CREATE_LOGMINER_HIGHWATER_ORACLE.SQL</b><br>
<b>CPTRDB_LML_ADD_COLUMNS_VIRTUAL.SQL</b><br><br>

<b>JCCLML_FILTER_DB_LOGICALS.COM</b><br>
<b>JCCLML_LML_CREATE_FILTER_DB.COM</b><br><br>

<b>JCCLML_SUBMIT.COM</b><br>
<b>JCCLML_JCC_RUN_CTL_ALL.COM</b><br><br>

<b>JCCLML_CPTRDB_CONFIGURATION.REF</b><br>
<b>JCCLML_CPTRDB_DAILY.COM</b><br><br>

<b>JCCLML_LML_CLEANUP_LOGS_DAILY.COM</b><br><br>

<b>JCCLML_JCC_RUN_LML.COM</b><br>

<p>
This template source files allow to create and run a single tutorial 
demonstration and test loader session.

The procedures assume a identical target database named CPTRDB_DB_2 has been
created using
</p>

<pre>
CPTRDB_CREATE_DB.COM
CPTRDB_ADD_STORAGE_AREAS.COM
CPTRDB_ADD_TABLES.COM
</pre>

<p>
The source database must have AIJ and continuous logminer enabled using
</p>

<pre>
$ Rmu/Set Logminer/enable/continuous {dbid}
</pre>

<pre>
[In a JCC Logminer Loader ONLY environment, it is recommended NOT to use the
JCC_TOOL_LOCAL and JCC_TOOL_LOGS logicals as directory locations in command
procedures and configuration files. These logicals are JCCLML version specific
and will jeopardize future new multiversion installations.

In this setup the JCC_TOOL_LOGS directory remains empty and the JCC_TOOL_LOCAL
directory only contains:

JCC_LML_LICENSE.COM
  (Copied from JCC_TOOL_COM. Adapt the license value)
JCC_RUNTIME_PARAMETERS.DAT
JCC_RUN_LML.COM
  (Optional to adapt the LML process name if using parallel threads)
THIS_FILE_MAY_BE_DELETED.TXT

The use of the logicals JCCLML$PROCS and JCCLML$LOGS is proposed. 

The JCCLML$PROCS directory contains all source files and the CTL, DTL and
other run logfiles and (temporary) output files.

The JCCLML$LOGS directory contains the CLM, LML logfiles and the DTL statistics
output files (reopened daily).

In the toolset environment these logicals would be defined as 

$ define/sys/exec JCCLML$PROCS       CPT$RDB
$ define/sys/exec JCCLML$LOGS        CPT$RDB_JCCLML_LOGS
$ define/sys/exec CPT$RDB_JCCLML_MGR JCCLML$PROCS

With this setup the run logfiles live in the 'default' directory CPT$RDB.]
</pre>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_LML_ALL_TABLE.INI</b><br>
<b>CPTRDB_LML_ALL_MAPTABLE.INI</b><br>
<b>CPTRDB_LML_ALL_FILTERMAP.INI</b><br>
  Template control files for all tables and date filters of the source database
  generated using:
</p>

<pre>
$ @JCC_TOOL_COM:JCC_LML_CREATE_CONTROL_FILE {sourcedb} ALL
</pre>

<p>
<b>JCCLML_JCC_RUN_CTL-CPTRDB_LML.COM</b><br>
  Run command file for the CTL batch job loader session.
</p>

<pre>
The file name format is
JCCLML_JCC_RUN_CTL-{loader name}.COM

The loader name is "CPTRDB_LML". The name must be unique in the first 11
characters as it is used in process names with format "123 12345678901".

The logical JCC_CLML_PROCESS_NAME_SEPARATOR allows to define a alternate
separator character, other than blank, in the CTL/CLM/LML process names.

Submitted using JCCLML_SUBMIT.COM
Usage:
$ @JCCLML_SUBMIT {node} JCCLML_JCC_RUN_CTL-{loader name}

The (current) logfile is:
CPT$RDB_JCCLML_MGR:JCC_RUN_CTL-{loader name}.LOG
</pre>

<p>
<b>CPTRDB_LML_UNLOAD.OPT</b><br>
  List the table(s) to be replicated.
</p>

  This file can be generated using:<br>

<pre>
@JCC_TOOL_COM:JCC_CREATE_LOG_MINER_OPT_FILE {dbid}
</pre>

<p>
  Vertical partitioned tables are not supported, so TABLE_PARTI does not apply.
  LIST OF BYTE VARYING columns cannot be replicated.
</p>

  The replicated table is TABLE_PLACE:<br>

<pre>
table=TABLE_PLACE,output=rdb_logminer_output_file
</pre>

<p>
<b>CPTRDB_LML_CONTROL.INI</b><br>
  Central control file of the loader session CPTRDB_LML.

  Defines the loader name, target type, destination, access validation, 
  *_table.ini / *_maptable.ini / *_filtermap.ini filespecs, logging and
  checkpoint options.
</p>

<p>
<b>CPTRDB_LML_TABLE_PLACE_TABLE.INI</b><br>
  Description of the source table TABLE_PLACE.
</p>

  Virtual columns are added.<br>

<pre>
VirtualColumn~TABLE_PLACE~transaction_start_time
VirtualColumn~TABLE_PLACE~transaction_commit_time
VirtualColumn~TABLE_PLACE~transmission_date_time
VirtualColumn~TABLE_PLACE~originating_dbkey
VirtualColumn~TABLE_PLACE~jcclml_constant,origin='CPTRDB_DB_1|TABLE_PLACE'
VirtualColumn~TABLE_PLACE~action
</pre>

<p>
<b>CPTRDB_LML_TABLE_PLACE_MAPTABLE.INI</b><br>
  Description of the mapping for all columns of source table TABLE_PLACE.
</p>

  The default transmission action is REPLICATE<br>

<pre>
MapTable~TABLE_PLACE~TABLE_PLACE_MAP1,TABLE_PLACE~Replicate
</pre>

  The "MapTable~" semantics are:<br>

<pre>
MapTable~{source table}~{map name},{target table}~Replicate
</pre>

  The virtual columns are also mapped.<br>

<pre>
MapColumn~TABLE_PLACE_MAP1~transaction_start_time
MapColumn~TABLE_PLACE_MAP1~transaction_commit_time
MapColumn~TABLE_PLACE_MAP1~transmission_date_time
MapColumn~TABLE_PLACE_MAP1~originating_dbkey
MapColumn~TABLE_PLACE_MAP1~jcclml_constant,origin
</pre>

  Column COL1 is chosen as primary key.<br>

<pre>
MapKey~TABLE_PLACE_MAP1~COL1
</pre>

<p>
  The source table is mapped a second time to the shadow audit table
  TABLE_PLACE_AUDIT with transmission action AUDIT, which acts as a
  audit trail and only receives inserts on all actions.
</p>

<pre>
MapTable~TABLE_PLACE~TABLE_PLACE_MAP2,TABLE_PLACE_AUDIT~Audit
MapColumn~TABLE_PLACE_MAP2~action
</pre>

<p>
  All operations on the source table will be recorded here. The virtual
  column ACTION indicates the type of operation.
</p>

<pre>
"M" for INSERT or UPDATE
"D" for DELETE
</pre>

<p>
<b>CPTRDB_LML_FILTERMAP.INI</b><br>
  Filter definition for table TABLE_PLACE (and others). 

  All filter definitions must be grouped here.

  The WHERE clause is expressed in terms of target columns, and can
  only be applicable to a single row.
</p>

<p>
<b>JCCLML_RDB$MAX_VERSION.COM</b><br>
  List RDB$MAX_VERSION and RDB$CARDINALITY for a series of hardcoded tables
  in the source database.

  The output is used to check the record version in the table definition
  file CPTRDB_LML_TABLE_PLACE_TABLE.INI .
</p>

<pre>
Table~TABLE_PLACE~1~~NoMapTable
                  |-> record version

Usage:
$ @JCCLML_RDB$MAX_VERSION {sourcedb}
</pre>

<p>
<b>JCCLML_VMS_FUNCTIONS.SQL</b><br>
  Copy of JCC_TOOL_SQL:VMS_FUNCTIONS.SQL<br>
  Create functions and procedures required by the JCC Logminer Loader.
  To be executed on the source database.
</p>

<p>
<b>JCCLML_CREATE_LOGMINER_HIGHWATER.SQL</b><br>
  Copy of JCC_TOOL_SQL:CREATE_LOGMINER_HIGHWATER.SQL<br>
  Create the logminer highwater table containing the checkpoint information.
  To be excuted on the target database.
</p>

<p>
<b>JCCLML_CREATE_LOGMINER_HIGHWATER_ORACLE.SQL</b><br>
  Edited copy of JCC_TOOL_SQL:CREATE_LOGMINER_HIGHWATER_ORACLE.SQL<br>
  Create the logminer highwater table containing the checkpoint information
  in a Oracle RDBMS database
  To be excuted on the target database.

  Adapt the tablespace name.
</p>

<p>
<b>CPTRDB_LML_ADD_COLUMNS_VIRTUAL.SQL</b><br>
  Add virtual columns to the target table.
  Create a target shadow audit table named TABLE_PLACE_AUDIT.
  To be executed on the target database.
</p>

<p>
<b>JCCLML_FILTER_DB_LOGICALS.COM</b><br>
  Define the logicals to locate and name a filter database for the
  JCC Logminer Loader when a filtermap is specified for one or more loaders.
</p>

<p>
<b>JCCLML_LML_CREATE_FILTER_DB.COM</b><br>
  Create a filter database for the JCC Logminer Loader, that can be
  shared by a series of loaders. Also on other nodes if the filter
  logicals are defined, and 'number of cluster nodes' > 1 and
  'number of users' is a multiple of 28.
</p>

<p>
<b>JCCLML_SUBMIT.COM</b><br>
  Submit a JCCLML toolset job in batch to the queue CPT$RDB_BATCH_{node},
  with the logfile in the CPT$RDB_JCCLML_MGR: directory.
</p>
  
<p>
  The procedure only handles command files starting with "JCCLML_LML_"
  or "JCCLML_JCC_RUN_CTL-".
</p>

<pre>
Parameters: P1,   nodename,                                        char(6)
            P2,   filename, JCCLML_LML_{name}[.COM]
                         or JCCLML_JCC_RUN_CTL-{loader_name}[.COM] char(39)
            [P3], /AFTER date time,               [absolute|delta] time

P2 is the filename only, without extension .COM
P3 is optional
The prefix "JCCLML_" is stripped off from the logfile filename
The logfile format is LML_{name}_{node}_yyyymmdd.log_ddmmmhhmmss
                   or JCC_RUN_CTL-{loader_name}.log
</pre>

Usage:<br>

<pre>
$ @JCCLML_SUBMIT {node} JCCLML_{name} {date time}
</pre>

Start the loader session using:<br>

<pre>
$ @JCCLML_SUBMIT {node} JCCLML_JCC_RUN_CTL-{loader_name} 

The CTL logfile is created in CPT$RDB_JCCLML_MGR, one per session.
The CLM and LML logiles are created in CPT$RDB_JCCLML_LOGS, reopened daily.

By convention within the toolset for each loader session,

The current logfiles format is:
JCC_RUN_CTL-{loader_name}.LOG (defined by the toolset via JCCLML_SUBMIT.COM)
JCC_RUN_CLM-{loader_name}.LOG (defined by the JCC LML product)
JCC_RUN_LML-{loader_name}.LOG (defined by the JCC LML product)

The previous logfiles formats are:
JCC_RUN_CTL-{loader_name}_{node}_yyyymmdd.LOG_ddmmmhhmmss
JCC_RUN_CLM-{loader_name}_{node}_yyyymmdd.LOG_ddmmmhhmmss
JCC_RUN_LML-{loader_name}_{node}_yyyymmdd.LOG_ddmmmhhmmss
based on creation date and time and
defined by the toolset via JCCLML_RENAME_LOGFILES.COM 
                       and JCCLML_LML_REOPEN_LOGS.COM
</pre>
  
<p>
<b>JCCLML_JCC_RUN_CTL_ALL.COM</b><br>
  Start a series of JCC Logminer Loader sessions listed in the configuration
  file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|JCCLML_JCC_RUN_CTL.
</p>

<pre>
CPT$RDB_DATABASE|JCCLML_JCC_RUN_CTL|CPTRDB_LML|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_JCC_RUN_CTL
! 2 Loader name
! 3 Execution node
</pre>

<p>
The procedure submits the command file(s)
CPT$RDB:JCCLML_JCC_RUN_CTL-{loader name}.COM
</p>

<p>
  Usage:
</p>

<pre>
$ @JCCLML_JCC_RUN_CTL_ALL
</pre>

<p>
  This procedure can be called from the system startup.
</p>

<p>
<b>JCCLML_CPTRDB_CONFIGURATION.REF</b><br>
  Template configuration and parameter file for a JCC Logminer Loader ONLY
  environment.
</p>

<p>
  This configuration file is a subset of the general 
  CPTRDB_CONFIGURATION.REF<br> 
  Adapt this file to your environment.<br>
  Copy this file to 'defdir'CPTRDB_CONFIGURATION.REF in the runtime active
  environment.
</p>

<p>
<b>JCCLML_CPTRDB_DAILY.COM</b><br>
  Quick interactive check on log and output files for a JCC Logminer Loader
  ONLY environment.
</p>

<pre>
Parameters: [P1], {vms_date}
</pre>

<p>
  This procedure is a subset of the general CPTRDB_DAILY.COM
</p>

<p>
<b>JCCLML_LML_CLEANUP_LOGS_DAILY.COM</b><br>
  Catchall cleanup log and output files in a JCC Logminer Loader
  ONLY environment.
</p>

<p>
  Usage:
</p>

<pre>
$ @JCCLML_SUBMIT {node} JCCLML_LML_CLEANUP_LOGS_DAILY
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|JCCLML_LML_CLEANUP_LOGS_DAILY
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_CLEANUP_LOGS_DAILY|L15S29|TOMORROW + 08:28|
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_CLEANUP_LOGS_DAILY
! 2 Reschedule node
! 3 Reschedule time
</pre>

<p>
<b>JCCLML_JCC_RUN_LML.COM</b><br>
  Adapt the process name of the LML process from "||0 {loader name}" to
  "LML {loader name}" if running with one thread, using "parallel~1~1"
  in the config file {loader name}_CONTROL.INI<br>

  This procedure has to be copied as *JCC_RUN_LML.COM* to the JCC_TOOL_LOCAL:
  directory of the current JCCLML version.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52 -- Manage JCC Logminer Loader Sessions
</font>
</h3>

-- Reopen logfiles daily --<br>
<b>JCCLML_LML_REOPEN_LOGS.COM</b> (Called from)<br>
<b>JCCLML_LML_REOPEN_LOGS_ALL.COM</b><br><br>

-- Rename logfiles --<br>
<b>JCCLML_RENAME_LOGFILES.COM</b> (Called from)<br>
<b>JCCLML_RENAME_LOGFILES_ALL.COM</b><br><br>

-- Shutdown loader sessions --<br>
<b>JCCLML_SHUTDOWN.COM</b> (Called from)<br>
<b>JCCLML_SHUTDOWN_ALL.COM</b><br><br>

-- Run statistics sessions --<br>
<b>JCCLML_JCC_RUN_DTL.COM</b> (Called from)<br>
<b>JCCLML_JCC_RUN_DTL_GO.COM</b><br>
<b>JCCLML_JCC_RUN_DTL_ALL.COM</b><br><br>

-- List and check processes and logfiles --<br>
<b>JCCLML_SHOW_PROCESS_BATCH.COM</b> (Called from)<br>
<b>JCCLML_SHOW_PROCESS.COM</b><br>
<b>JCCLML_LML_SHOW_PROCESS_DAILY.COM</b><br>
<b>JCCLML_SHOW_PROCESS.REF</b> (Reference file)<br><br>

-- List and check statistics sessions and logfiles --<br>
<b>JCCLML_SHOW_STATS.COM</b><br>
<b>JCCLML_LML_SHOW_STATS_DAILY.COM</b><br>
<b>JCCLML_SHOW_STATS.REF</b> (Reference file)<br><br>

-- List and check heartbeat timestamps from CTL logfiles --<br>
<b>JCCLML_SHOW_HEARTBEAT_BATCH.COM</b> (Called from)<br>
<b>JCCLML_SHOW_HEARTBEAT.COM</b><br>
<b>JCCLML_LML_SHOW_HEARTBEAT_CONT.COM</b><br>
<b>JCCLML_SHOW_HEARTBEAT.REF</b> (Reference file)<br><br>

-- List and check heartbeat AERCP checkpoints from LML logfiles --<br>
<b>JCCLML_SHOW_AERCP_BATCH.COM</b> (Called from)<br>
<b>JCCLML_SHOW_AERCP.COM</b><br>
<b>JCCLML_LML_SHOW_AERCP_CONT.COM</b><br>
<b>JCCLML_SHOW_AERCP.REF</b> (Reference file)<br><br>

-- Replicate data using the data pump mechanism --<br>
<b>CPTRDB_LML_DATA_PUMP_DRIVER.INI</b><br>
<b>CPTRDB_LML_DATA_PUMP_STRUCTURE.INI</b><br>
<b>JCCLML_LML_DATA_PUMP_CPTRDB_LML.COM</b><br><br>

-- Format char(20) originating dbkeys --<br>
<b>JCCLML_CVT_ODBKEY.C</b><br>
<b>JCCLML_CVT_ODBKEY_BUILD.COM</b><br>
<b>JCCLML_CVT_ODBKEY.OBJ</b><br>
<b>JCCLML_CVT_ODBKEY.EXE</b><br>
<b>JCCLML_CVT_ODBKEY.COM</b><br><br>

-- Dump target checkpoints --<br>
<b>JCCLML_LML_DUMP_CHECKPOINT_RDB.COM</b><br>
<b>JCCLML_LML_DUMP_CHECKPOINT_OCI.COM</b><br>
<b>JCCLML_DUMP_CHECKPOINT_ONE.COM</b><br><br>

<b>JCCLML_DUMP_CHECKPOINT_BATCH.COM</b> (Called from)<br>
<b>JCCLML_DUMP_CHECKPOINT.COM</b><br>
<b>JCCLML_LML_DUMP_CHECKPOINT_CON.COM</b><br>
<b>JCCLML_DUMP_CHECKPOINT.REF</b> (Reference file)<br><br>

-- How to exclude deletes from replication --<br>

<p>
The JCCLML_LML_*.COM procedures are intended as batch jobs submitted using 
JCCLML_SUBMIT.COM and conform to the naming policy of log and output 
files starting with "LML_".
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.1 -- Reopen Logfiles Daily
</font>
</h3>

<p>
<b>JCCLML_LML_REOPEN_LOGS.COM </b><br>
  Called from JCCLML_LML_REOPEN_LOGS_ALL.COM
</p>

<p>
  Reopen/rename the CLM/LML logfiles in CPT$RDB_JCCLML_LOGS: 
  for one loader session.
</p>

<pre>
Parameters: P1, loader_name, char(11)

Clean the logfiles
CPT$RDB_JCCLML_LOGS:JCC_RUN_CLM-{loader_name}*.LOG*;*
CPT$RDB_JCCLML_LOGS:JCC_RUN_LML-{loader_name}*.LOG*;*
CPT$RDB_JCCLML_LOGS:DTL*{loader_name}*.LOG*;*
older than 22 days

Clean the logfiles
CPT$RDB_JCCLML_MGR:LML_REOPEN_{loader_name}*.LOG*;*
older than 8 days
</pre>

<p>
<b>JCCLML_LML_REOPEN_LOGS_ALL.COM</b><br>
  Calls JCCLML_LML_REOPEN_LOGS.COM
</p>

<p>
  Reopen the logfiles for a series of JCC Logminer Loader sessions on a 
  daily basis.

  Clean the logfiles
  CPT$RDB_JCCLML_MGR:LML_REOPEN_LOGS_ALL*.LOG*;*
  older than 8 days.
</p>

<p>
  The list of loader sessions is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_DATABASE|JCCLML_REOPEN_LOGS.
</p>

<pre>
CPT$RDB_DATABASE|JCCLML_REOPEN_LOGS|CPTRDB_LML|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_REOPEN_LOGS
! 2 Loader name
! 3 Execution node
</pre>

<p>
  The reschedule node and time are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|JCCLML_LML_REOPEN_LOGS_ALL, by default at 00:02.
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_REOPEN_LOGS_ALL|L15S29|TOMORROW + 00:02|
!
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_REOPEN_LOGS_ALL
! 2 Reschedule node
! 3 Reschedule time
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.2 -- Rename Logfiles
</font>
</h3>

<p>
<b>JCCLML_RENAME_LOGFILES.COM</b><br>
  Called from JCCLML_RENAME_LOGFILES_ALL.COM
</p>

<p>
  Interactive rename all logfiles of one stopped loader session to their 
  creation date and time.
</p>

<p>
<hr>
  To enforce the logfile naming conventions, the rename has to be executed 
  after each unintended stop of a loader, or stop of a loader not using
  JCCLML_SHUTDOWN.COM
<hr>
</p>

  Usage:<br>

<pre>
$ @JCCLML_RENAME_LOGFILES {loader_name}
</pre>

<p>
<b>JCCLML_RENAME_LOGFILES_ALL.COM</b><br>
  Calls JCCLML_RENAME_LOGFILES.COM
</p>

<p>
  Interactive rename the logfiles for a series of stopped loaders sessions.
</p>

  Usage:<br>

<pre>
$ @JCCLML_RENAME_LOGFILES_ALL
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.3"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.3 -- Shutdown Loader Sessions
</font>
</h3>

<p>
<b>JCCLML_SHUTDOWN.COM</b><br>
  Calls       JCCLML_RENAME_LOGFILES.COM<br>
  Called from JCCLML_SHUTDOWN_ALL.COM
</p>

<p>
  Controlled shutdown of one loader session and rename of the logfiles to their 
  creation date and time.
</p>

  Usage:<br>

<pre>
$ @JCCLML_SHUTDOWN {loader_name} 
</pre>

<p>
<b>JCCLML_SHUTDOWN_ALL.COM</b><br>
  Calls JCCLML_SHUTDOWN.COM
</p>

<p>
  Shutdown a series of JCC Logminer Loader sessions listed in the
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|JCCLML_SHUTDOWN
</p>

<pre>
CPT$RDB_DATABASE|JCCLML_SHUTDOWN|CPTRDB_LML|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_SHUTDOWN
! 2 Loader name
! 3 Execution node
</pre>

  Usage:<br>

<pre>
$ @JCCLML_SHUTDOWN_ALL
</pre>

<p>
  This procedure can be run from the system shutdown.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.4"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.4 -- Run Statistics Sessions
</font>
</h3>

<p>
<b>JCCLML_JCC_RUN_DTL.COM</b><br>
  Renamed from JCCLML_LML_RUN_STATS.COM<br>
  Called from JCCLML_JCC_RUN_DTL_[GO|ALL].COM
</p>

<p>
  Run JCC Logminer Loader statistics for one loader session.<br>

  The process name is set to "DTL {loadername}".<br>

  The output file format created in CPT$RDB_JCCLML_LOGS: is<br>
  DTL_{node}_{loader name}_yyyymmdd_hhmm.LOG<br>
  (defined by the JCC Logminer Loader product).
</p>

<p>
  The prefix of the output filespec indicates the type of statistics running:
</p>

<pre>
BRIEF  BRF_
FULL   FUL_
DETAIL DTL_ (Default in the toolset)
CSV    CSV_
T4     T4_
</pre>

<p>
  The REOPEN option assures that the output file is reopened daily at
  midnight with the actual timestamp yyyymmdd_hhmm in the output filespec.
</p>

  The default parameters are:<br>

<pre>
$ define jcc_logminer_loader_stat_tardy_field "TrailOutput"
$ define jcc_logminer_loader_stat_file_seconds 900
$ define jcc_logminer_loader_stat_options     "nointeractive,file,reopen"

$ jcc_lml_statistics -
  "''loaderid'" -
  180 -          ! refresh rate
  detail -       ! report type
  180 -          ! tardiness threshold
  central        ! operator class
</pre>

<p>
  The CockpitMgr Event Console captures and displays all opcom messages issued
  by the "DTL {loader name}" statistics process, such as:
</p>

<pre>
18-JUN-2015 05:41:51.14 JCCSTAT: JCC Loader 'PTNOVASBNP' output is trailing realtime by 243.89 seconds
18-JUN-2015 05:44:51.14 JCCSTAT: JCC Loader 'PTNOVASBNP' is below tardy interval of 180.00 seconds; output trailing realtime by 94.37 seconds
</pre>

  To realtime monitor a running loader use:<br>

<pre>
$ @JCC_TOOL_COM:JCC_LML_USER
$ JCC_LML_STATISTICS {loader_name} {refresh_rate} DETAIL
</pre>

  Output sample:<br>

<pre>
Rate:  30.00                       CPTRDB_LML            19-JUN-2015 12:29:52.00
================================================================================
   Input: 19-JUN-2015 12:28:35.37                Output: 19-JUN-2015 12:28:35.37
--[Trail:    0.00]---------------             ---[Trail:    0.00]---------------
Transactions                 3085             Checkpoints                   2845
Records                      7927                Timeout                       0
   Modify                    3140                BufferLimit(   600)           1
   Delete                    1702                NoWork                     2838
   Commit                    3085             Records(   2)                 2806
 Discarded                                       Messages(  N/A )            N/A
   Filtered                     0                Filtered                   1202
   Excluded                     0             Failure                          0
   Unknown                      0             Timeout                          0
   Restart                      0        - Current ---------------- Ave/Second -
   NoWork                     240        Checkpoints             0          0.00
   Heartbeat                 2838        Records                 0          0.00
Timeout                      1417        Rate                 0.00%
--- Restart Context ------               - Latency(sec) ------ LML detail ------
M|AIJ#               6046 |              CLM    0.00 |  Inpt   0.0%  Cnvt   0.0%
Q|VBN                   5 |              ------------   Sort   0.0%  Trgt   0.0%
P|TSN             1897707 |              LML    0.00    Sync   0.0%  Ckpt   0.0%
 CTSN             1897707 |        - Loaders - 0 -------------------------------
  LSN                   7 |        - States  - z
</pre>

<p>
  The "VBN" value in the "Restart Context" indicates the actual block number
  position of the loader extraction in the AIJ file with sequence number 
  "AIJ#". It can be compared to the AIJ sequence number "SeqNum" and current 
  end of file block number "CurrEOF" in the RMU/Show Statistics screen 
  Journaling Information/AIJ Journal Information, to evaluate a eventual delay
  in the replication. 
</p>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-120 Perf. Monitor 19-JUN-2015 12:31:15.63
Rate: 3.00 Seconds          AIJ Journal Information      Elapsed: 58 21:21:44.35
Page: 1 of 1      DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1       Mode: Online

Journaling: enabled   Shutdown: 4320  Notify: enabled   State: Accessible
ALS: Running    ABS: disabled                 FC: enabled   CTJ: disabled
ARB.Count:  300 ARB.Avail: **** SwtchSched:  0 NxtSwtch:
After-Image.Journal.Name....... SeqNum   AIJsize   CurrEOF Status. State.......
AIJ1                            Unused    500000     Empty Latent  Accessible
AIJ2                            Unused    500000     Empty Latent  Accessible
AIJ3                              6046    500000         5 Current Accessible
Available AIJ slot 1
Available AIJ slot 2
Available AIJ slot 3
</pre>

<p>
<b>JCCLML_JCC_RUN_DTL_GO.COM</b><br>
Renamed from JCCLML_LML_RUN_STATS_GO.COM<br>
Calls        JCCLML_JCC_RUN_DTL.COM
</p>

<p>
  Start one JCC Logminer Loader statistics process in batch.
  This procedure is only executed once, right away after the start of a
  loader session.
</p>

  Usage:<br>

<pre>
$ @JCCLML_JCC_RUN_DTL_GO {node} {loader_name}

The current log file format, created in CPT$RDB_JCCLML_MGR: is
JCC_RUN_DTL-{loader name}_{node}_yyyymmdd.LOG_ddmmmhhmmss
</pre>

<p>
<b>JCCLML_JCC_RUN_DTL_ALL.COM</b><br>
Renamed from JCCLML_LML_RUN_STATS_ALL.COM<br>
Calls        JCCLML_JCC_RUN_DTL.COM
</p>

<p>
  Start JCC Logminer Loader statistics sessions for a series of loaders
  listed in the configuration file CPTRDB_CONFIGURATION.REF, identified by the
  keywords CPT$RDB_DATABASE|JCCLML_JCC_RUN_DTL.
</p>

<pre>
CPT$RDB_DATABASE|JCCLML_JCC_RUN_DTL|CPTRDB_LML|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_JCC_RUN_DTL
! 2 Loader name
! 3 Execution node
</pre>

  Usage:<br>

<pre>
$ @JCCLML_JCC_RUN_DTL_ALL
</pre>

<p>
  This procedure can be run from the system startup.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.5"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.5 -- List And Check Processes And Logfiles
</font>
</h3>

<p>
<b>JCCLML_SHOW_PROCESS_BATCH.COM</b><br>
  Called from<br>
  JCCLML_SHOW_PROCESS.COM<br>
  JCCLML_LML_SHOW_PROCESS_DAILY.COM<br>
  JCCLML_SHOW_STATS.COM<br>
  JCCLML_LML_SHOW_STATS_DAILY.COM
</p>

<p>
  List the JCC Logminer Loader CTL, CLM, LML, DTL processes on one node.
</p>

<pre>
Parameters: P1, process name prefix, varchar(15), 
                                     "[CTL|CLM|LML|DTL] {loader_name}"
            P2, output file,         LML_SHOW_PROCESS.TMP_{filecnt}
</pre>

<p>
<b>JCCLML_SHOW_PROCESS.COM</b><br>
  Calls JCCLML_SHOW_PROCESS_BATCH.COM
</p>

<p>
  Interactive list the JCC Logminer Loader CTL, CLM, LML current processes 
  and logfiles on a series of cluster nodes.

  The list of nodes and process name (sub)strings is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|JCCLML_SHOW_PROCESS
</p>

<pre>
CPT$RDB_NODE|JCCLML_SHOW_PROCESS|L15S29|CTL |
CPT$RDB_NODE|JCCLML_SHOW_PROCESS|L15S29|CLM |
CPT$RDB_NODE|JCCLML_SHOW_PROCESS|L15S29|LML CPTRDB|
!
! 0 CPT$RDB_NODE
! 1 JCCLML_SHOW_PROCESS
! 2 Execution node
! 3 JCCLML process name (sub)string
</pre>

  Usage:<br>

<pre>
$ @JCCLML_SHOW_PROCESS
</pre>

  Output sample:<br>

<pre>
CPTRDB - JCC Logminer Loader Processes And Logfiles
From Node: L95S08
At:         7-MAR-2018 15:06:59.50
 
--------------
On Node L95S08
--------------
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:06:59.60   Uptime  76 02:20:29
00022C31 CTL ACC_L90S05A LEF      6  3749375   0 00:00:29.74      5312   3297  B
00169034 CTL ACC_L95S02A LEF      6  3728146   0 00:00:42.76      5296   3296  B
0012B437 CTL ACC_L95S04A LEF      6  3666153   0 00:00:23.83      5361   3310  B
00167C3B CTL ACC_L95S05A LEF      6  3666114   0 00:00:23.49      5267   3296  B
Number of CTL processes: 4
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:06:59.74   Uptime  76 02:20:29
00165833 CLM ACC_L90S05A HIB      6    59268   0 00:00:17.44      6984   2335  S
0015B836 CLM ACC_L95S02A HIB      6   117329   0 00:00:12.32      8495   1980  S
00171C39 CLM ACC_L95S04A HIB      6    40941   0 00:00:06.36      6905   2146  S
0017D43E CLM ACC_L95S05A HIB      6    57947   0 00:00:05.86      6813   2191  S
Number of CLM processes: 4
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:06:59.87   Uptime  76 02:20:29
00168832 LML ACC_L90S05A LEF      6  7242709   0 00:00:47.80      7475   5603  S
00166835 LML ACC_L95S02A LEF      6  7388475   0 00:01:18.23      7659   5793  S
00172038 LML ACC_L95S04A LEF      6  7124454   0 00:00:28.15      6784   4887  S
0017543C LML ACC_L95S05A LEF      6  7199507   0 00:00:40.75      7365   5438  S
Number of LML processes: 4
 
--------------
On Node L95S08
--------------
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:00.06   Uptime  76 02:20:30
00188C42 CTL AGGREGSBNA  LEF      4  3684983   0 00:00:36.40      5359   3297  B
Number of CTL processes: 1
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:00.25   Uptime  76 02:20:30
00175445 CLM AGGREGSBNA  HIB      6    95807   0 00:00:14.75      6706   2174  S
Number of CLM processes: 1
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:00.39   Uptime  76 02:20:30
0017C044 LML AGGREGSBNA  LEF      6  7289632   0 00:01:02.75      7570   5265  S
Number of LML processes: 1
 
--------------
On Node L95S08
--------------
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:00.73   Uptime  76 02:20:30
00188092 CTL PTNOVASBNA  LEF      6  3700217   0 00:00:29.03      4403   3187  B
001884A5 CTL PTNSLS1302A LEF      6  3645941   0 00:00:28.86      4449   3103  B
0017ECAE CTL PTNSLS1303A LEF      6  3645728   0 00:00:31.87      4441   3173  B
Number of CTL processes: 3
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:00.86   Uptime  76 02:20:30
0018B4A2 CLM PTNOVASBNA  HIB      6   106904   0 00:00:07.41      4290   2163  S
0018B0A9 CLM PTNSLS1302A HIB      6    42444   0 00:00:09.61      6666   2132  S
001880B0 CLM PTNSLS1303A HIB      6    42403   0 00:00:10.59      6655   2151  S
Number of CLM processes: 3
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:01.00   Uptime  76 02:20:31
001878A0 LML PTNOVASBNA  LEF      6   410948   0 00:01:01.83      3806   3215  S
001880A8 LML PTNSLS1302A LEF      6  7109805   0 00:00:32.83      2882   2454  S
0017DCAF LML PTNSLS1303A LEF      6  7109811   0 00:00:33.98      2855   2513  S
Number of LML processes: 3
 

Directory DISK$DATA_6:[JCCLML350.LOCAL]

JCC_RUN_CTL-ACC_L90S05A.LOG;1
                        2520/2592     26-JAN-2018 11:20:16.85
JCC_RUN_CTL-ACC_L95S02A.LOG;1
                        2521/2592     26-JAN-2018 11:20:21.86
JCC_RUN_CTL-ACC_L95S04A.LOG;1
                        2520/2592     26-JAN-2018 11:20:26.88
JCC_RUN_CTL-ACC_L95S05A.LOG;1
                        2520/2592     26-JAN-2018 11:20:31.88
JCC_RUN_CTL-AGGREGSBNA.LOG;1
                        2464/2592     26-JAN-2018 11:20:36.90
JCC_RUN_CTL-PTNOVASBNA.LOG;1
                        1332/1440     26-JAN-2018 11:20:41.92
JCC_RUN_CTL-PTNSLS1302A.LOG;1
                        2460/2592     26-JAN-2018 11:20:46.92
JCC_RUN_CTL-PTNSLS1303A.LOG;1
                        2460/2592     26-JAN-2018 11:20:51.93

Total of 8 files, 18797/19584 blocks.

Directory DISK$DATA_6:[JCCLML350.LOG]

jcc_run_clm-ACC_L90S05A.log;41
                           0/1008      7-MAR-2018 00:02:01.17
jcc_run_clm-ACC_L95S02A.log;41
                           0/1008      7-MAR-2018 00:02:06.31
jcc_run_clm-ACC_L95S04A.log;41
                           0/1008      7-MAR-2018 00:02:11.55
jcc_run_clm-ACC_L95S05A.log;41
                           0/1008      7-MAR-2018 00:02:16.73
jcc_run_clm-AGGREGSBNA.log;41
                           0/1008      7-MAR-2018 00:02:22.10
jcc_run_clm-PTNOVASBNA.log;41
                           0/1008      7-MAR-2018 00:02:27.32
jcc_run_clm-PTNSLS1302A.log;41
                           0/1008      7-MAR-2018 00:02:32.50
jcc_run_clm-PTNSLS1303A.log;41
                           0/1008      7-MAR-2018 00:02:37.73

Total of 8 files, 0/8064 blocks.

Directory DISK$DATA_6:[JCCLML350.LOG]

jcc_run_lml-ACC_L90S05A.log;41
                        6326/7056      7-MAR-2018 00:02:01.18
jcc_run_lml-ACC_L95S02A.log;41
                        3114/4032      7-MAR-2018 00:02:06.32
jcc_run_lml-ACC_L95S04A.log;41
                         172/1008      7-MAR-2018 00:02:11.56
jcc_run_lml-ACC_L95S05A.log;41
                         171/1008      7-MAR-2018 00:02:16.73
jcc_run_lml-AGGREGSBNA.log;41
                         127/1008      7-MAR-2018 00:02:22.10
jcc_run_lml-PTNOVASBNA.log;41
                         163/1008      7-MAR-2018 00:02:27.33
jcc_run_lml-PTNSLS1302A.log;41
                          78/1008      7-MAR-2018 00:02:32.51
jcc_run_lml-PTNSLS1303A.log;41
                          78/1008      7-MAR-2018 00:02:37.73

Total of 8 files, 10229/17136 blocks.
</pre>

<p>
<b>JCCLML_LML_SHOW_PROCESS_DAILY.COM</b><br>
  Calls<br> 
JCCLML_SHOW_PROCESS_BATCH.COM<br>
JCCLML_SHOW_PROCESS.REF
</p>

<p>
  Daily list the JCC Logminer Loader processes and logfiles on a series of 
  cluster nodes, identified in the configuration file CPTRDB_CONFIGURATION.REF
  by the keywords CPT$RDB_NODE|JCCLML_SHOW_PROCESS.

  Send a CockpitMgr event and mail if a difference is found with the reference 
  file JCCLML_SHOW_PROCESS.REF.

  The reschedule node, time and exception mail address are retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|JCCLML_LML_SHOW_PROCESS_DAILY.
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_SHOW_PROCESS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_SHOW_PROCESS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_JCCLML_ProcessDiff
"CPTRDB - JCCLML Process Diff {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JCCLML Process Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.6"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.6 -- List And Check Statistics Sessions And Logfiles
</font>
</h3>

<p>
<b>JCCLML_SHOW_STATS.COM</b><br>
  Calls JCCLML_SHOW_PROCESS_BATCH.COM
</p>

<p>
  Interactive list the JCC Logminer Loader statistics processes and logfiles
  for a series of nodes.

  The list of nodes and process name (sub)strings is retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|JCCLML_SHOW_STATS
</p>

<pre>
CPT$RDB_NODE|JCCLML_SHOW_STATS|L15S29|DTL |
!
! 0 CPT$RDB_NODE
! 1 JCCLML_SHOW_STATS
! 2 Execution node
! 3 Statistics process name (sub)string
</pre>

  Usage:<br>

<pre>
$ @JCCLML_SHOW_STATS
</pre>

  Output sample:<br>

<pre>
CPTRDB - JCCLML Statistics Processes And Logfiles
From Node: L95S08
At:         7-MAR-2018 15:07:47.39
 
--------------
On Node L95S08
--------------
 
OpenVMS V8.4  on node L95S08    7-MAR-2018 15:07:47.48   Uptime  76 02:21:17
001AC6D9 DTL ACC_L90S05A LEF      6    16527   0 00:00:08.91       997    587  B
001986DA DTL ACC_L95S02A LEF      6    16519   0 00:00:09.13       997    587  B
001AC6DB DTL ACC_L95S04A LEF      6    16505   0 00:00:09.19       997    587  B
001772DC DTL ACC_L95S05A LEF      6    16518   0 00:00:08.68       997    587  B
001AC6DD DTL AGGREGSBNA  LEF      6    16512   0 00:00:07.21       997    587  B
0018D2DE DTL PTNOVASBNA  LEF      6    29412   0 00:00:07.69       924    535  B
0011AEDF DTL PTNSLS1302A LEF      6    16532   0 00:00:07.05       997    587  B
001982E0 DTL PTNSLS1303A LEF      5    16556   0 00:00:07.49       996    586  B
Number of DTL processes: 8
 

Directory DISK$DATA_6:[JCCLML350.LOCAL]

JCC_RUN_DTL-ACC_L90S05A_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-ACC_L95S02A_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-ACC_L95S04A_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-ACC_L95S05A_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-AGGREGSBNA_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-PTNOVASBNA_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-PTNSLS1302A_L95S08_20180129.LOG_29JAN154847;1
JCC_RUN_DTL-PTNSLS1303A_L95S08_20180129.LOG_29JAN154847;1

Total of 8 files.

Directory DISK$DATA_6:[JCCLML350.LOG]

DTL_L95S08_ACC_L90S05A_20180307_0000.LOG;1
                        1147/1440      7-MAR-2018 00:03:55.87
DTL_L95S08_ACC_L95S02A_20180307_0000.LOG;1
                        1151/1440      7-MAR-2018 00:03:55.96
DTL_L95S08_ACC_L95S04A_20180307_0000.LOG;1
                        1147/1440      7-MAR-2018 00:03:55.97
DTL_L95S08_ACC_L95S05A_20180307_0000.LOG;1
                        1147/1440      7-MAR-2018 00:03:55.97
DTL_L95S08_AGGREGSBNA_20180307_0000.LOG;1
                        1147/1440      7-MAR-2018 00:03:55.93
DTL_L95S08_PTNOVASBNA_20180307_0000.LOG;1
                        1121/1152      7-MAR-2018 00:03:47.00
DTL_L95S08_PTNSLS1302A_20180307_0000.LOG;1
                        1147/1440      7-MAR-2018 00:03:55.97
DTL_L95S08_PTNSLS1303A_20180307_0000.LOG;1
                        1151/1440      7-MAR-2018 00:03:55.96

Total of 8 files, 9158/11232 blocks.
</pre>

<p>
<b>JCCLML_LML_SHOW_STATS_DAILY.COM</b><br>
  Calls<br>
  JCCLML_SHOW_PROCESS_BATCH.COM<br>
  JCCLML_SHOW_STATS.REF
</p>

<p>
  Daily list JCC Logminer Loader statistics processes and logfiles on a
  series of cluster nodes, identified in the configuration file 
  CPTRDB_CONFIGURATION.REF by the keywords CPT$RDB_NODE|JCCLML_SHOW_STATS.

  Send a CockpitMgr event and mail if a difference is found with the reference 
  file JCCLML_SHOW_STATS.REF.

  The reschedule node, time and exception mail address are retrieved from the 
  configuration file CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_JOB|JCCLML_LML_SHOW_STATS_DAILY.
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_SHOW_STATS_DAILY|L15S29|TOMORROW + 08:00|L15S36::ALLEMEERSCH|
! 
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_SHOW_STATS_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_JCCLML_StatsDiff
"CPTRDB - JCCLML Stats Diff {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JCCLML Stats Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.7"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.7 -- List And Check Heartbeat Timestamps From CTL Logfiles
</font>
</h3>

<p>
<b>JCCLML_SHOW_HEARTBEAT_BATCH.COM</b><br>
  Called from<br>
  JCCLML_SHOW_HEARTBEAT.COM<br>
  JCCLML_LML_SHOW_HEARTBEAT_CONT.COM
</p>

<p>
  List the most recent heartbeat timestamps from the CTL logfiles and their 
  realtime delay for all JCC Logminer Loader sessions on one node.<br>

  Per loader name the status is flagged as "OK" or "*DELAYED*".<br>

  The runtime parameters are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF identified by the keywords
  CPT$RDB_PARAM|JCCLML_SHOW_HEARTBEAT_BATCH.
</p>

<pre>
CPT$RDB_PARAM|JCCLML_SHOW_HEARTBEAT_BATCH|0-00:05:00.00|10|-4:00:00|
!
! 0 CPT$RDB_PARAM
! 1 JCCLML_SHOW_HEARTBEAT_BATCH
! 2 Warning delta time
! 3 Column align, max(length) loader names
! 4 Continuous 'clean before' delay
</pre>

<p>
<b>JCCLML_SHOW_HEARTBEAT.COM</b><br>
  Calls JCCLML_SHOW_HEARTBEAT_BATCH.COM
</p>

<p>
  Interactive list the most recent heartbeat timestamps and their realtime delay
  from the CTL logfiles, for all JCC Logminer Loader sessions on a series 
  of nodes.<br>

  The list of nodes is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_NODE|JCCLML_SHOW_HEARTBEAT.
</p>

<pre>
CPT$RDB_NODE|JCCLML_SHOW_HEARTBEAT|L15S29|
!
! 0 CPT$RDB_NODE
! 1 JCCLML_SHOW_HEARTBEAT
! 2 Execution node
</pre>

Usage:<br>

<pre>
$ @JCCLML_SHOW_HEARTBEAT
</pre>

  Output sample:<br>

<pre>
CPTRDB - JCC Logminer Loader Most Recent Heartbeat Timestamps
From Node:     L95S08
Delay Warning: 0-00:05:05.00
At:             7-MAR-2018 15:08:06.84
 
--------------
On Node L95S08
--------------
 
ACC_L90S05A| 7-MAR-2018 15:05:23.12|   0 00:02:43.82|OK
ACC_L95S02A| 7-MAR-2018 15:05:26.76|   0 00:02:40.18|OK
ACC_L95S04A| 7-MAR-2018 15:05:31.89|   0 00:02:35.06|OK
ACC_L95S05A| 7-MAR-2018 15:05:36.80|   0 00:02:30.15|OK
AGGREGSBNA | 7-MAR-2018 15:05:42.62|   0 00:02:24.33|OK
PTNOVASBNA | 7-MAR-2018 15:05:46.70|   0 00:02:20.25|OK
PTNSLS1302A| 7-MAR-2018 15:05:51.34|   0 00:02:15.61|OK
PTNSLS1303A| 7-MAR-2018 15:05:56.23|   0 00:02:10.72|OK
Total number of loader sessions 8
</pre>

<p>
<b>JCCLML_LML_SHOW_HEARTBEAT_CONT.COM</b><br>
  Calls <br>
  JCCLML_SHOW_HEARTBEAT_BATCH.COM<br>
  JCCLML_SHOW_HEARTBEAT.REF (Reference file)
</p>

<p>
  List the most recent heartbeat timestamps and their realtime delay
  from the CTL logfiles for a series of JCC Logminer Loader sessions and
  nodes, in a continuous way every n minutes.<br>

  The default reschedule interval is 30 minutes.<br>

  Default, the output files *.log / *.lis / *.diff are cleaned after 4 hours,
  *.mime files after 7 days.<br>

  The list of nodes is retrieved from the configuration file 
  CPTRDB_CONFIGURATION.REF identified by the keywords 
  CPT$RDB_NODE|JCCLML_SHOW_HEARTBEAT.<br>

  Send CockpitMgr event and mail if difference found with reference file
  CPT$RDB:JCCLML_SHOW_HEARTBEAT.REF.<br>

  The purpose of this procedure is to track the presence and normal progress
  of the loader sessions.<br> 

  The reschedule node, time and exception mail address are retrieved from
  the configuration file CPTRDB_CONFIGURATION.REF, identified by the
  keywords CPT$RDB_JOB|JCCLML_LML_SHOW_HEARTBEAT_CONT.
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_SHOW_HEARTBEAT_CONT|L15S29|+00:30|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_SHOW_HEARTBEAT_CONT
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
"CPTRDB_JCCLML_HeartbeatDiff {node} yyyymmdd"
"CPTRDB - JCCLML Heartbeat Diff {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JCCLML Heartbeat Diff {node} yyyymmdd"
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.8"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.8 -- List And Check Heartbeat AERCP Checkpoints From LML Logfiles
</font>
</h3>

<p>
<b>JCCLML_SHOW_AERCP_BATCH.COM</b><br>
  Called from<br>
  JCCLML_SHOW_AERCP.COM<br>
  JCCLML_LML_SHOW_AERCP_CONT.COM
</p>

<p>
  List the most recent heartbeat AERCP checkpoints and their realtime delay
  from the LML logfile for one JCC Logminer Loader session.<br>

  The runtime parameters are retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_PARAM|JCCLML_SHOW_AERCP_BATCH.
</p>

<pre>
CPT$RDB_PARAM|JCCLML_SHOW_AERCP_BATCH|0-00:06:00.00|6|-4:00:00|
!
! 0 CPT$RDB_PARAM
! 1 JCCLML_SHOW_AERCP_BATCH
! 2 Warning delta time
! 3 Number of checkpoints listed
! 4 Continuous 'clean before' delay
</pre>

<p>
  Per checkpoint for this loader the status is flagged as "DLYD", "OK" or
  "*DLYD*".
</p>

<p>
<b>JCCLML_SHOW_AERCP.COM</b><br>
  Calls JCCLML_SHOW_AERCP_BATCH.COM
</p>

<p>
  Interactive list the most recent heartbeat AERCP checkpoints and their 
  realtime delay from the LML logfiles for a series of JCC Logminer Loader 
  sessions and nodes.<br>

  The list of loaders and nodes is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|JCCLML_SHOW_AERCP.
</p>

<pre>
CPT$RDB_DATABASE|JCCLML_SHOW_AERCP|CPTRDB_LML|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_SHOW_AERCP
! 2 Loader name
! 3 Execution node
</pre>

Usage:<br>

<pre>
$ @JCCLML_SHOW_AERCP
</pre>

  Output sample:<br>

<pre>
CPTRDB - JCC Logminer Loader Heartbeat AERCP Checkpoints
From Node L95S08
At  7-MAR-2018 15:08:24.16
 
Delay Warning: 0-00:06:00.00
 
-- 1 --
On Node L95S08
At  7-MAR-2018 15:08:24.27
 
Loader: ACC_L90S05A
 
ACC_L90S05A|7-MAR-2018 14:40:23.11|   0 00:28:01.22|DLYD  |1-28-31998-12-10115075-10115075
ACC_L90S05A|7-MAR-2018 14:45:23.11|   0 00:23:01.22|DLYD  |1-28-31998-13-10115077-10115077
ACC_L90S05A|7-MAR-2018 14:50:23.11|   0 00:18:01.22|DLYD  |1-28-31998-14-10115079-10115079
ACC_L90S05A|7-MAR-2018 14:55:23.11|   0 00:13:01.22|DLYD  |1-28-31998-16-10115081-10115081
ACC_L90S05A|7-MAR-2018 15:00:23.11|   0 00:08:01.22|DLYD  |1-28-31998-17-10115083-10115083
ACC_L90S05A|7-MAR-2018 15:05:23.11|   0 00:03:01.22|OK    |1-28-31998-18-10115085-10115085
 
-- 2 --
On Node L95S08
At  7-MAR-2018 15:08:24.42
 
Loader: ACC_L95S02A
 
ACC_L95S02A|7-MAR-2018 14:40:26.76|   0 00:27:57.71|DLYD  |1-28-31707-12-9956279-9956279
ACC_L95S02A|7-MAR-2018 14:45:26.74|   0 00:22:57.73|DLYD  |1-28-31707-13-9956281-9956281
ACC_L95S02A|7-MAR-2018 14:50:26.74|   0 00:17:57.73|DLYD  |1-28-31707-14-9956283-9956283
ACC_L95S02A|7-MAR-2018 14:55:26.75|   0 00:12:57.72|DLYD  |1-28-31707-15-9956285-9956285
ACC_L95S02A|7-MAR-2018 15:00:26.75|   0 00:07:57.72|DLYD  |1-28-31707-16-9956287-9956287
ACC_L95S02A|7-MAR-2018 15:05:26.76|   0 00:02:57.71|OK    |1-28-31707-18-9956289-9956289
 
-- 3 --
On Node L95S08
At  7-MAR-2018 15:08:24.57
 
Loader: ACC_L95S04A
 
ACC_L95S04A|7-MAR-2018 14:40:31.89|   0 00:27:52.69|DLYD  |1-28-33387-11-25303942-25303942
ACC_L95S04A|7-MAR-2018 14:45:31.89|   0 00:22:52.69|DLYD  |1-28-33387-12-25303943-25303943
ACC_L95S04A|7-MAR-2018 14:50:31.89|   0 00:17:52.70|DLYD  |1-28-33387-13-25303944-25303944
ACC_L95S04A|7-MAR-2018 14:55:31.89|   0 00:12:52.70|DLYD  |1-28-33387-15-25303945-25303945
ACC_L95S04A|7-MAR-2018 15:00:31.90|   0 00:07:52.69|DLYD  |1-28-33387-16-25303946-25303946
ACC_L95S04A|7-MAR-2018 15:05:31.89|   0 00:02:52.70|OK    |1-28-33387-17-25303947-25303947
 
-- 4 --
On Node L95S08
At  7-MAR-2018 15:08:24.69
 
Loader: ACC_L95S05A
 
ACC_L95S05A|7-MAR-2018 14:40:36.80|   0 00:27:47.91|DLYD  |1-28-31204-10-9305508-9305508
ACC_L95S05A|7-MAR-2018 14:45:36.80|   0 00:22:47.91|DLYD  |1-28-31204-11-9305509-9305509
ACC_L95S05A|7-MAR-2018 14:50:36.81|   0 00:17:47.90|DLYD  |1-28-31204-12-9305510-9305510
ACC_L95S05A|7-MAR-2018 14:55:36.80|   0 00:12:47.91|DLYD  |1-28-31204-13-9305511-9305511
ACC_L95S05A|7-MAR-2018 15:00:36.82|   0 00:07:47.89|DLYD  |1-28-31204-14-9305512-9305512
ACC_L95S05A|7-MAR-2018 15:05:36.80|   0 00:02:47.91|OK    |1-28-31204-15-9305513-9305513
 
-- 5 --
On Node L95S08
At  7-MAR-2018 15:08:24.81
 
Loader: AGGREGSBNA
 
AGGREGSBNA|7-MAR-2018 14:55:42.59|   0 00:12:42.24|DLYD  |1-28-37207-66-80859987-80859987
AGGREGSBNA|7-MAR-2018 14:55:46.71|   0 00:12:38.12|DLYD  |1-28-37207-75-80859992-80859992
AGGREGSBNA|7-MAR-2018 15:00:42.59|   0 00:07:42.24|DLYD  |1-28-37207-77-80859994-80859994
AGGREGSBNA|7-MAR-2018 15:00:46.70|   0 00:07:38.13|DLYD  |1-28-37207-78-80859996-80859996
AGGREGSBNA|7-MAR-2018 15:05:42.62|   0 00:02:42.21|OK    |1-28-37207-87-80860001-80860001
AGGREGSBNA|7-MAR-2018 15:05:46.70|   0 00:02:38.13|OK    |1-28-37207-89-80860003-80860003
 
-- 6 --
On Node L95S08
At  7-MAR-2018 15:08:24.93
 
Loader: PTNOVASBNA
 
PTNOVASBNA|7-MAR-2018 14:55:42.59|   0 00:12:42.36|DLYD  |1-28-37207-66-80859987-80859987
PTNOVASBNA|7-MAR-2018 14:55:46.71|   0 00:12:38.24|DLYD  |1-28-37207-75-80859992-80859992
PTNOVASBNA|7-MAR-2018 15:00:42.59|   0 00:07:42.36|DLYD  |1-28-37207-77-80859994-80859994
PTNOVASBNA|7-MAR-2018 15:00:46.70|   0 00:07:38.25|DLYD  |1-28-37207-78-80859996-80859996
PTNOVASBNA|7-MAR-2018 15:05:42.62|   0 00:02:42.33|OK    |1-28-37207-87-80860001-80860001
PTNOVASBNA|7-MAR-2018 15:05:46.70|   0 00:02:38.25|OK    |1-28-37207-89-80860003-80860003
 
-- 7 --
On Node L95S08
At  7-MAR-2018 15:08:25.07
 
Loader: PTNSLS1302A
 
PTNSLS1302A|7-MAR-2018 14:40:51.30|   0 00:27:33.80|DLYD  |1-28-18194-12-5690236-5690236
PTNSLS1302A|7-MAR-2018 14:45:51.30|   0 00:22:33.80|DLYD  |1-28-18194-13-5690238-5690238
PTNSLS1302A|7-MAR-2018 14:50:51.30|   0 00:17:33.80|DLYD  |1-28-18194-16-5690240-5690240
PTNSLS1302A|7-MAR-2018 14:55:51.30|   0 00:12:33.80|DLYD  |1-28-18194-17-5690242-5690242
PTNSLS1302A|7-MAR-2018 15:00:51.30|   0 00:07:33.80|DLYD  |1-28-18194-18-5690244-5690244
PTNSLS1302A|7-MAR-2018 15:05:51.30|   0 00:02:33.80|OK    |1-28-18194-19-5690246-5690246
 
-- 8 --
On Node L95S08
At  7-MAR-2018 15:08:25.19
 
Loader: PTNSLS1303A
 
PTNSLS1303A|7-MAR-2018 14:40:56.23|   0 00:27:28.98|DLYD  |1-28-18194-12-5690282-5690282
PTNSLS1303A|7-MAR-2018 14:45:56.23|   0 00:22:28.98|DLYD  |1-28-18194-13-5690284-5690284
PTNSLS1303A|7-MAR-2018 14:50:56.23|   0 00:17:28.98|DLYD  |1-28-18194-14-5690286-5690286
PTNSLS1303A|7-MAR-2018 14:55:56.23|   0 00:12:28.98|DLYD  |1-28-18194-16-5690288-5690288
PTNSLS1303A|7-MAR-2018 15:00:56.23|   0 00:07:28.98|DLYD  |1-28-18194-17-5690290-5690290
PTNSLS1303A|7-MAR-2018 15:05:56.23|   0 00:02:28.98|OK    |1-28-18194-18-5690292-5690292
</pre>

<p>
<b>JCCLML_LML_SHOW_AERCP_CONT.COM</b><br>
  Calls<br>
  JCCLML_SHOW_AERCP_BATCH.COM<br>
  JCCLML_SHOW_AERCP.REF (Reference file)
</p>

<p>
  List the most recent heartbeat AERCP checkpoints and their realtime delay
  from the LML logfiles for a series of JCC Logminer Loader sessions and
  nodes, listed in the configuration file, identified by the keywords 
  CPT$RDB_DATABASE|JCCLML_SHOW_AERCP, in a continuous way every n minutes.<br>

  The default reschedule interval is 30 minutes.<br>

  Default, the output files *.log / *.lis / *.diff are cleaned after 4 hours,
  *.mime files after 7 days.<br>

  Send CockpitMgr event and mail if difference found with reference file
  CPT$RDB:JCCLML_SHOW_AERCP.REF<br>

  The reschedule node, time and exception mail address are retrieved from
  the configuration file CPTRDB_CONFIGURATION.REF, identified by the
  keywords CPT$RDB_JOB|JCCLML_LML_SHOW_AERCP_CONT.
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_SHOW_AERCP_CONT|L15S29|+00:30|L15S36::ALLEMEERSCH|
! 
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_SHOW_AERCP_CONT
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

  Toolset CockpitMgr event:<br>

<pre>
"CPTRDB_JCCLML_AercpDiff {node} yyyymmdd"
"CPTRDB - JCCLML Aercp Diff {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - JCCLML AERCP Diff {node} yyyymmdd"
</pre>

<p>
  The purpose of this procedure is to track the presence and normal progress
  of the loader sessions. The positions within the live AIJ journal files
  allow to evaluate eventual delays at a glance for a series of loaders 
  without starting an interactive statistics session for each loader.  
</p>

<pre>
CPTRDB_LML|8-OCT-2014 08:44:54.24|   0 00:36:02.79|*DLYD*|1-28-3506-12-1094734-1094734
                                    Live AIJ sequence number <-|    |  |
                                    Live AIJ block number         <-|  |
                                    TSN                              <-|
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.9"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.9 -- Replicate Data Using The Data Pump Mechanism
</font>
</h3>

<p>
<b>CPTRDB_LML_DATA_PUMP_DRIVER.INI</b><br>
  List the tables to be replicated via the data pump mechanism.
</p>

<p>
<b>CPTRDB_LML_DATA_PUMP_STRUCTURE.INI</b><br>
  List the hierarchy of the tables to be replicated via the data pump.
  The dot "." character in the first column ends the current hierarchy.
</p>

<p>
<b>JCCLML_LML_DATA_PUMP_CPTRDB_LML.COM</b><br>
  Run file for a data pump session to be submitted in batch.
</p>

  Usage:<br>

<pre>
$ @jcclml_submit {node} JCCLML_LML_DATA_PUMP_CPTRDB_LML
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.10"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.10 -- Format Char(20) Originating Dbkeys
</font>
</h3>

<p>
<b>JCCLML_CVT_ODBKEY.C</b><br>
 Display a bigint/number(20) originating dbkey value in dbkey format
 {larea}:{page}:{line}
</p>

<p>
<b>JCCLML_CVT_ODBKEY_BUILD.COM</b><br>
  Build file for JCCLML_CVT_ODBKEY.C
</p>

<p>
<b>JCCLML_CVT_ODBKEY.OBJ</b><br>
  Object file of JCCLML_CVT_ODBKEY.C
</p>

<p>
<b>JCCLML_CVT_ODBKEY.EXE</b><br>
  Image file of JCCLML_CVT_ODBKEY.C
</p>

<p>
<b>JCCLML_CVT_ODBKEY.COM</b><br>
  Example run file of JCCLML_CVT_ODBKEY.C
</p>

<pre>
Calls CPT$RDB:JCCLML_CVT_ODBKEY.EXE as foreign command

Parameters: P1, originating dbkey, varchar(20), 20266201719963661

Usage:
$ @JCCLML_CVT_ODBKEY 18295873505984512
  Char:    18295873505984512
  Hex:     410000012e0000
  Hex:     41:12e:0
  Decimal: 65:302:0
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.11"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.11 -- Dump Target Checkpoints
</font>
</h3>

<p>
<b>JCCLML_LML_DUMP_CHECKPOINT_RDB.COM</b><br>
  Dump the JCC Logminer Loader checkpoint information
  for one hardcoded Rdb target loader session.<br>
  To be submitted in batch.
</p>

<p>
  *This procedure is deprecated*<br>
  *The use of JCCLML_DUMP_CHECKPOINT[_ONE].COM is recommended*
</p>

<p>
  Parameters: Adapt the parameter block and loader version.
</p>

<pre>
$!--------------------------
$ loaderid   = "CPTRDB_LML"
$ dbid       = "CPTRDB_DB_2"
$ chkpt_type = "RDB"
$!--------------------------
...
$ @jcc_tool_com:jcc_lml_user s
</pre>

  Usage:<br>

<pre>
$ @JCCLML_SUBMIT {node} JCCLML_LML_DUMP_CHECKPOINT_RDB
</pre>

  Output sample:<br>

<pre>
 -- Checkpoint restart information --

Write Timestamp:     12-FEB-2015 12:37:15.90
LoaderName:          CPTRDB_LML
Completion Flag:     N
Checkpoint Interval: 1
Input Data Source:   LML_CONT_CPTRDB_LML
Last Transaction:
        Start Time:  12-FEB-2015 12:37:15.89
        Commit Time: 12-FEB-2015 12:37:15.89
        TSN:         1495672
        LSN:         15
        AERCP:       1-28-4776-10-1495672-1495672
        RM TID:
</pre>

<p>
<b>JCCLML_LML_DUMP_CHECKPOINT_OCI.COM</b><br>
  Dump the JCC Logminer Loader checkpoint information
  for one OCI target loader session.<br>
  To be submitted in batch.
</p>

<p>
  *This procedure is deprecated*<br>
  *The use of JCCLML_DUMP_CHECKPOINT[_ONE].COM is recommended*
</p>

<p>
  Parameters: Adapt the parameter block, loader/client versions and
              username/password.
</p>

<pre>
$!--------------------------
$ loaderid   = "PTNOVASBNP"
$ dbid       = "O663D00P"
$ chkpt_type = "OCI"
$!--------------------------
...
$ @jcc_tool_com:jcc_lml_user s
$ @jcc_tool_com:JCC_LML_oracle_USER 10.2 DISK$DATA_38:[ORACLE10202]orauser.com
...
$ jcc_lml_dump_checkpoint 'loaderid' 'dbid' 'chkpt_type'
{username}
{password}
$!
</pre>

  Usage:<br>

<pre>
$ @JCCLML_SUBMIT {node} JCCLML_LML_DUMP_CHECKPOINT_OCI
</pre>

  Output sample:<br>

<pre>
username:
password: 
Connected to ORACLE(O663D00P) as user A663.

 -- Checkpoint restart information --

Write Timestamp:     12-FEB-2015 12:43:43.23
LoaderName:          PTNOVASBNP
Completion Flag:     N
Checkpoint Interval: 1
Input Data Source:   LML_CONT_PTNOVASBNP
Last Transaction:
        Start Time:  12-FEB-2015 12:43:43.18
        Commit Time: 12-FEB-2015 12:43:43.42
        TSN:         697533486
        LSN:         8910158
        AERCP:       1-28-27024-17387-697533486-697533486
        RM TID:
</pre>

<p>
<b>JCCLML_DUMP_CHECKPOINT_ONE.COM</b><br>
  Dump the JCC Logminer Loader checkpoint information for one loader session,
  from the target database LOGMINER_HIGHWATER table.<br>
  Compute and list the "Write Timestamp:" realtime delay.
</p>

<pre>
Parameters: P1,   loaderid,    char(11)
            P2,   target dbid, varchar(255)
            P3,   chkpt_type,  char(3), [OCI|RDB]
            [P4], username,    varchar(255), OCI Only
            [P5], password,    varchar(255), OCI Only
</pre>

<p>
  The warning delta time is retrieved from the configuration file
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_PARAM|JCCLML_DUMP_CHECKPOINT_BATCH
</p>

<pre>
CPT$RDB_PARAM|JCCLML_DUMP_CHECKPOINT_BATCH|0-00:05:00.00|-2:00:00|
!
! 0 CPT$RDB_PARAM
! 1 JCCLML_DUMP_CHECKPOINT_BATCH
! 2 Warning delta time
! 3 Continuous dump checkpoint 'clean before' delay
</pre>

<p>
Adapt the parameter block for loader and Oracle client versions.
</p>

<pre>
$! -- Set loader and Oracle Database client versions
$!------------------------------------------------------------------------------
$ @disk$data_24:[jcclml360.com]jcc_lml_user 3.6
$!$ @jcc_tool_com:JCC_LML_oracle_USER 10.2 DISK$DATA_38:[ORACLE10202]orauser.com
$!------------------------------------------------------------------------------
</pre>

<p>
  Usage:
</p>

<pre>
$ @JCCLML_DUMP_CHECKPOINT_ONE {loader id} {target dbid} {chkpt_type} -
                              [{OCI username} {OCI password}]
</pre>

<p>
Output sample:
</p>

<pre>
$ @JCCLML_DUMP_CHECKPOINT_ONE cptrdb_lml cptrdb_db_2 rdb
Setting JCC LogMiner Loader version 3.6
Delay Warning: 0-00:05:00.00
Delay|CPTRDB_LML |19-MAR-2019 10:36:55.82|   0 05:27:37.47|*DELAYED*
At|               19-MAR-2019 16:04:33.30
Output CPT$RDB_LISTS:LML_DUMP_CHECKPOINT_L15S29_20190319.LIS_19MAR160433
</pre>

<p>
<b>JCCLML_DUMP_CHECKPOINT_BATCH.COM</b><br>
  Called from<br> 
  JCCLML_DUMP_CHECKPOINT.COM<br>
  JCCLML_LML_DUMP_CHECKPOINT_CON.COM
</p>

<p>
  Dump the JCC Logminer Loader checkpoint information for one loader session,
  from the target database LOGMINER_HIGHWATER table.<br>
  Compute and list the realtime delay of the "Write Timestamp:".
</p>
  
<pre>
[Internal
Parameters: P1, loaderid,    char(11)
            P2, dbid,        varchar(255)
            P3, chkpt_type,  char(3), [OCI|RDB]
            P4, username,    varchar(255)
            P5, password,    varchar(255)
            P6, output file, <tmpdir>lml_dump_checkpoint.tmp_<filecnt>]
</pre>

<p>
  The runtime parameters are retrieved from the configuration file 
  CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_PARAM|JCCLML_DUMP_CHECKPOINT_BATCH 
</p>

<pre>
CPT$RDB_PARAM|JCCLML_DUMP_CHECKPOINT_BATCH|0-00:05:00.00|-2:00:00|
!
! 0 CPT$RDB_PARAM
! 1 JCCLML_DUMP_CHECKPOINT_BATCH
! 2 Warning delta time
! 3 Continuous dump checkpoint 'clean before' delay
</pre>

<p>
  Adapt the parameter block for the loader and client versions.
</p>

<pre>
$! -- Set loader and Oracle Database client versions
$!---------------------------------------------------------------------------------------------
$ @disk$data_24:[jcclml351.com]jcc_lml_user s
$!$ @disk$data_24:[jcclml351.com]JCC_LML_oracle_USER 10.2 DISK$DATA_24:[ORACLE10202]orauser.com
$!---------------------------------------------------------------------------------------------
</pre>

<p>
 If, due to a mismatch of the system time between the executor node and the
 target node, the "Write Timestamp:" on the target node is located in the
 future and a negative delay is computed, the status is regardless set to "OK"
 and the delay is hardcoded set to "9999 23:59:59.99".
</p>

<p>
<b>JCCLML_DUMP_CHECKPOINT.COM</b><br>
  Calls JCCLML_DUMP_CHECKPOINT_BATCH.COM
</p>

<p>
  Interactive dump the checkpoints from the target LOGMINER_HIGHWATER table,
  for a series of JCC Logminer Loader sessions listed in the configuration
  file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|JCCLML_DUMP_CHECKPOINT.<br>
  Compute and list the realtime delays of the "Write Timestamp:"'s.
</p>

<pre>
!! CPT$RDB_DATABASE|JCCLML_DUMP_CHECKPOINT|PTNOVASBNP|O663D00P|OCI|A663|SECRET|L15S59|
CPT$RDB_DATABASE|JCCLML_DUMP_CHECKPOINT|CPTRDB_LML|CPTRDB_DB_2|RDB|DUMMY|DUMMY|L15S29|
!
! 0 CPT$RDB_DATABASE
! 1 JCCLML_DUMP_CHECKPOINT
! 2 Loader name
! 3 Target database
! 4 Checkpoint type
! 5 Username
! 6 Password
! 7 Execution node
</pre>

<p>
   Usage:
</p>

<pre>
$ @JCCLML_DUMP_CHECKPOINT
</pre>

<p>
   Output sample:
</p>

<pre>
$ @jcclml_dump_checkpoint
-- 15-MAY-2019 14:28:06.02 Handle Loader ACC_L90S05A --
...
On Node L95S08
ACC_L90S05A|OK
ACC_L95S02A|OK
ACC_L95S04A|OK
ACC_L95S05A|OK
AGGREGSBNA |OK
DOLICLIOA  |OK
DOLISSPA   |OK
PTNOVASBNA |OK
PTNSLS1302A|OK
PTNSLS1303A|OK
Total number of loader sessions 10
Delay Warning: 0-00:05:00.00
Delay|ACC_L90S05A|15-MAY-2019 14:26:36.64|   0 00:01:30.03|OK
Delay|ACC_L95S02A|15-MAY-2019 14:26:40.27|   0 00:01:27.03|OK
Delay|ACC_L95S04A|15-MAY-2019 14:25:46.89|   0 00:02:21.03|OK
Delay|ACC_L95S05A|15-MAY-2019 14:26:50.55|   0 00:01:18.03|OK
Delay|AGGREGSBNA |15-MAY-2019 14:25:21.17|   0 00:02:48.04|OK
Delay|DOLICLIOA  |15-MAY-2019 14:25:33.75|   0 00:02:36.03|OK
Delay|DOLISSPA   |15-MAY-2019 14:24:50.32|   0 00:03:20.03|OK
Delay|PTNOVASBNA |15-MAY-2019 14:25:21.88|   0 00:02:49.03|OK
Delay|PTNSLS1302A|15-MAY-2019 14:26:57.46|   0 00:01:14.03|OK
Delay|PTNSLS1303A|15-MAY-2019 14:27:26.03|   0 00:00:46.03|OK
At                15-MAY-2019 14:28:12.14
Output LML_DUMP_CHECKPOINT_L95S08_20190515.LIS_15MAY142806
$

CPTRDB - JCC Logminer Loader Checkpoint Dumps
From Node L95S08
At 15-MAY-2019 14:28:06.01
 
Delay Warning: 0-00:05:00.00
 
-- 1 --
--------------------------
On Node L95S08
At 15-MAY-2019 14:28:06.28
Loader: ACC_L90S05A
--------------------------

JCC LML Dump Checkpoint V03.05.01 (built  6-FEB-2018 16:00:57.71)

username: 
password: Connected to ORACLE(NOICTR1A) as user A304.

 -- Checkpoint restart information --

Write Timestamp:     15-MAY-2019 14:26:36.64
LoaderName:          ACC_L90S05A
Completion Flag:     N
Checkpoint Interval: 1
Input Data Source:   LML_CONT_ACC_L90S05A
Last Transaction:
        Start Time:  15-MAY-2019 14:26:36.02
        Commit Time: 15-MAY-2019 14:26:36.02
        TSN:         11488127
        LSN:         24726
        AERCP:       1-28-36339-3-11488127-11488127
        RM TID:      

Delay|ACC_L90S05A|15-MAY-2019 14:26:36.64|   0 00:01:30.03|OK
At|               15-MAY-2019 14:28:06.67
 
-- 2 --
--------------------------
On Node L95S08
At 15-MAY-2019 14:28:06.94
Loader: ACC_L95S02A
--------------------------

JCC LML Dump Checkpoint V03.05.01 (built  6-FEB-2018 16:00:57.71)

username: 
password: Connected to ORACLE(NOICTR1A) as user A304.

 -- Checkpoint restart information --

Write Timestamp:     15-MAY-2019 14:26:40.27
LoaderName:          ACC_L95S02A
Completion Flag:     N
Checkpoint Interval: 1
Input Data Source:   LML_CONT_ACC_L95S02A
Last Transaction:
        Start Time:  15-MAY-2019 14:26:40.17
        Commit Time: 15-MAY-2019 14:26:40.17
        TSN:         11329570
        LSN:         39878
        AERCP:       1-28-36051-2-11329570-11329570
        RM TID:      

Delay|ACC_L95S02A|15-MAY-2019 14:26:40.27|   0 00:01:27.03|OK
At|               15-MAY-2019 14:28:07.30
 
-- 3 --
--------------------------
On Node L95S08
At 15-MAY-2019 14:28:07.58
Loader: ACC_L95S04A
--------------------------

JCC LML Dump Checkpoint V03.05.01 (built  6-FEB-2018 16:00:57.71)

username: 
password: Connected to ORACLE(NOICTR1A) as user A304.

 -- Checkpoint restart information --

Write Timestamp:     15-MAY-2019 14:25:46.89
LoaderName:          ACC_L95S04A
Completion Flag:     N
Checkpoint Interval: 1
Input Data Source:   LML_CONT_ACC_L95S04A
Last Transaction:
        Start Time:  15-MAY-2019 14:25:46.54
        Commit Time: 15-MAY-2019 14:25:46.54
        TSN:         26540850
        LSN:         0
        AERCP:       1-28-37726-27-26540850-26540850
        RM TID:      

Delay|ACC_L95S04A|15-MAY-2019 14:25:46.89|   0 00:02:21.03|OK
At|               15-MAY-2019 14:28:07.92

... 
</pre> 

<p>
<b>JCCLML_LML_DUMP_CHECKPOINT_CON.COM</b><br>
  Calls<br> 
  JCCLML_DUMP_CHECKPOINT_BATCH.COM<br>
  JCCLML_DUMP_CHECKPOINT.REF (Reference file)
</p>

<p>
  Dump the checkpoints from the target database LOGMINER_HIGHWATER table,
  for a series of JCC Logminer Loader sessions listed in the configuration
  file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_DATABASE|JCCLML_DUMP_CHECKPOINT, in a continuous way every n minutes.
</p>
  
<p>
  Send a CockpitMgr event and mail if a "Write Timestamp:" realtime delay
  limit is exceeded for one or more loader sessions or if a difference is
  found with the reference file JCCLML_DUMP_CHECKPOINT.REF
</p>

<p>
  Toolset CockpitMgr event:
</p>

<pre>
CPTRDB_JCCLML_CheckpointDiff
"CPTRDB - JCCLML Checkpoint Diff {node} - ddmmmhhmmss"
</pre>

<p>
  Mail subject:
</p>

<pre>
"CPTRDB - JCCLML Checkpoint Diff {node} yyyymmdd"
</pre>

<p>
  The reschedule node, time and exception mail address are retrieved from the
  configuration file CPTRDB_CONFIGURATION.REF, identified by the keywords
  CPT$RDB_JOB|JCCLML_LML_DUMP_CHECKPOINT_CON
</p>

<pre>
CPT$RDB_JOB|JCCLML_LML_DUMP_CHECKPOINT_CON|L15S29|+00:30|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 JCCLML_LML_DUMP_CHECKPOINT_CON
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

<p>
  The loader names in the [OK|*DELAYED*] lines in the reference file
  JCCLML_DUMP_CHECKPOINT.REF and temporary reference file
  LML_DUMP_CHECKPOINT_CON.TMP_REF are aligned as char(11).
</p>

<pre>
On Node L15S29
Loader: CPTRDB_LML
CPTRDB_LML |OK
----
12345678901
----
On Node L15S59
Loader: DOLICLIOD
DOLICLIOD  |OK
On Node L15S59
Loader: DOLISSPD
DOLISSPD   |OK
On Node L15S59
Loader: PTNOVASBNP
PTNOVASBNP |OK
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 52.12"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 52.12 -- How To Exclude Deletes From Replication
</font>
</h3>

<pre>
Declare a virtualcolumn ACTION:
VirtualColumn~SEASN_TKT~action

Map the virtualcolumn ACTION:
MapColumn~SEASN_TKT~action

Filter deletes:
FilterMap~SEASN_TKT~where \
      STKT_PRGRS_CODE = '8' \
  and ACTION <> 'D'

Exclude ACTION from the mapping:
MapExclude~SEASN_TKT~action

No need to add the column ACTION to the target table.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 53"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 53 -- List Data From A Oracle RDBMS Database
</font>
</h3>

<b>CPTRDB_OCI_CONNECT_TARGET_P.COM</b><br>
<b>CPTRDB_OCI_PTNOVA_INTERFACE.COM</b><br><br>

<b>CPTRDB_OCI_DETAILS_CENTRAL_GO.COM</b> (Calls)<br>
<b>CPTRDB_OCI_DETAILS_CENTRAL.COM</b> (Calls)<br>
<b>CPTRDB_OCI_DETAILS_CENTRAL.SQL</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The procedures in this chapter assume the Oracle OpenVMS client has been
installed on the executor node, and has been started as below,
depending on the client version and ORA_ROOT directory.
</p>

<pre>
$ @{dev}:[ORACLE10202]INSORACLE.COM {dev}:[ORACLE10202]
$ @{dev}:[ORACLE102020]INSORACLE.COM {dev}:[ORACLE102020]
$ @{dev}:[{dir}]INSORACLE.COM {dev}:[{dir}]
</pre>

<p>
<b>CPTRDB_OCI_CONNECT_TARGET_P.COM</b><br>
  Create a DCL symbol to connect to a Oracle RDBMS database using the
  Oracle OpenVMS client.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_OCI_CONNECT_TARGET_P
$ ctrgt
SQL> select sys_context('userenv','db_name') from dual; 
     describe logminer_highwater;
     select trans_name from logminer_highwater;
</pre>

<p>
  These sql statements provide a minimal check to test if a Oracle logminer
  loader target database is available.

  The connection requires a TNSNAMES.ORA file in
  "TNS_ADMIN" = "{dev}:[ORACLE10202.NETWORK.ADMIN]"
  with a entry similar to:
</p>

<pre>  
{dbid}.WORLD =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = <ip address>)(PORT = 1521))
    )
    (CONNECT_DATA = (SID = {dbid}))
  )
</pre>

<p>
<b>CPTRDB_OCI_PTNOVA_INTERFACE.COM</b><br>
  List data from a Oracle RDBMS database using the Oracle OpenVMS client,
  from a OpenVMS batch job.<br>

  Template PL/SQL code using table S663_PTNOVA_INTERFACE, a JCC Logminer Loader
  target table with virtual columns.<br>

  Parameters: Adapt the Oracle OpenVMS client environment
</p>

<p>
Output sample:
</p>

<pre>
...
SQL> --  ptnova_interface_id                       not null number(10)
SQL> --  seasn_tkt_code                                     varchar2(12)
SQL> --  sls_item_no                                        varchar2(12)
SQL> --  mobib_card_code                                    varchar2(20)
SQL> --  origin                                             varchar2(287)
SQL> --  transaction_start_time                             timestamp(2)
SQL> --  transaction_commit_time                            timestamp(2)
SQL> --  transmission_date_time                             timestamp(2)
SQL> --  originating_dbkey                                  number(22)
SQL> --  stkt_prgrs_code                                    varchar2(1)
SQL> --  trace_seasn_tkt_code                               varchar2(12)
SQL> --  trace_sls_item_no                                  varchar2(12)
SQL> --  trace_stkt_trace_type                              varchar2(2)
SQL> --  trace_duplct_sls_item_no                           varchar2(12)
SQL> --  sls_item_id                                        varchar2(2)
SQL> --  price_cd                                           varchar2(3)
SQL> --  orgnsm_id                                          varchar2(4)
...
55367930|NULL|053841401491|NULL|S663_ORACLE|S663_MOBIB_CONTRACT|VALIDATION|2016-07-13 12:19:15|NULL|2016-07-13 12:19:15|NULL|NULL|NULL|053841401491|NULL|NULL|NULL|NULL|NULL
55367941|NULL|034668628035|NULL|S663_ORACLE|S663_MOBIB_CONTRACT|VALIDATION|2016-07-13 12:19:38|NULL|2016-07-13 12:19:38|NULL|NULL|NULL|034668628035|NULL|NULL|NULL|NULL|NULL
55367936|NULL|830106147938|NULL|S663_ORACLE|S663_MOBIB_CONTRACT|VALIDATION|2016-07-13 12:19:20|NULL|2016-07-13 12:19:20|NULL|NULL|NULL|830106147938|NULL|NULL|NULL|NULL|NULL
55367944|NULL|023847996432|NULL|S663_ORACLE|S663_MOBIB_CONTRACT|VALIDATION|2016-07-13 12:19:42|NULL|2016-07-13 12:19:42|NULL|NULL|NULL|023847996432|NULL|NULL|NULL|NULL|NULL
55367954|NULL|018630332783|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:49|2016-07-13 12:20:49|2016-07-13 12:20:49|54043200587890717|NULL|018600318142|018630332783|NV|NULL|NULL|NULL|NULL
55367948|NULL|043468970819|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:11|2016-07-13 12:20:11|2016-07-13 12:20:11|54043200587890712|NULL|043401286852|043468970819|NV|NULL|NULL|NULL|NULL
55367937|NULL|014846072793|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:19:29|2016-07-13 12:19:29|2016-07-13 12:19:29|54043200587890709|NULL|014800765487|014846072793|NV|NULL|NULL|NULL|NULL
55367950|NULL|043780532290|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:25|2016-07-13 12:20:25|2016-07-13 12:20:25|54043200587890714|NULL|043701175616|043780532290|NV|NULL|NULL|NULL|NULL
55367952|NULL|043780532391|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:38|2016-07-13 12:20:38|2016-07-13 12:20:38|54043200587890716|NULL|043701175715|043780532391|NV|NULL|NULL|NULL|NULL
55367955|019501019065|NULL|NULL|SBN_DB|SEASN_TKT|2016-07-13 12:20:51|2016-07-13 12:20:51|2016-07-13 12:20:51|21110672253124613|8|NULL|NULL|NULL|NULL|NULL|NULL|NULL
55367956|NULL|043780532492|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:54|2016-07-13 12:20:54|2016-07-13 12:20:54|54043200587890718|NULL|043701175517|043780532492|NV|NULL|NULL|NULL|NULL
55367951|NULL|013980878869|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:20:30|2016-07-13 12:20:30|2016-07-13 12:20:30|54043200587890715|NULL|013903979802|013980878869|NV|NULL|NULL|NULL|NULL
55367934|NULL|017912294024|NULL|SBN_DB|SEASN_TKT_TRACE|2016-07-13 12:19:19|2016-07-13 12:19:19|2016-07-13 12:19:19|54043200587890702|NULL|017902168065|017912294024|NV|NULL|NULL|NULL|NULL
Total count: 13

PL/SQL procedure successfully completed.
</pre>

<p>
<b>CPTRDB_OCI_DETAILS_CENTRAL_GO.COM</b><br>
  Calls CPTRDB_OCI_DETAILS_CENTRAL.COM
</p>

<p>
  Submit CPT$RDB:CPTRDB_OCI_DETAILS_CENTRAL.COM in batch with hardcoded
  parameters.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_OCI_DETAILS_CENTRAL_GO.COM
</pre>

<p>
<b>CPTRDB_OCI_DETAILS_CENTRAL.COM</b><br>
  Called from CPTRDB_OCI_DETAILS_CENTRAL_GO.COM<br>
  Calls stored procedure S304_P_JCCLML_DETAILS_CENTRAL
</p>

<p>
  This template code illustrates the call of a stored procedure with
  parameters within a Oracle RDBMS database, using the Oracle OpenVMS client,
  from a OpenVMS batch job.<br>
  
  List individual rows of a table for the central acc_db,
  inserted/updated on a specific day, transmitted via the JCC Logminer Loader,
  for later comparison with their local sources.
</p>
  
<pre>
Parameters: P1, acct_unit_id,   char(5),   14001
            P2, table_name,     char(31),  cash_sess
            P3, column_name,    char(31),  enc_aut_bos
            P4, reference_date, date ansi, 2009-05-12
  
P4 is the TRANSACTION_START_TIME day of the transmitted row.
</pre>

<p>
Output sample:
</p>

<pre>
SQL> exec s304_p_jcclml_details_central('92023','DOSSIER','PRICE',date '2016-07-13');
01 acct_unit_id|
02 table_name|
03 column_name|
04 reference_date|
92023|DOSSIER|PRICE|2016-07-13|
01 dossier_no|
02 type_trans|
03 dossier_no_seq|
04 cash_desk_no|
05 cash_ses_no|
06 price|
07 time_stamp|
08 transaction_start_time|
09 transaction_commit_time|
10 transmission_date_time|
11 originating_dbkey|
0062004880|55|2|W05|71278|0.00|#|2016-07-11 14:38:36|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174854172678|
0062004880|56|1|W05|71278|0.00|#|2016-07-11 11:37:09|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174854172679|
0063002831|63|1|V63|60812|0.00|#|2016-07-11 08:55:36|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606118923|
0063002832|62|1|V63|60812|0.00|#|2016-07-11 08:58:12|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606249994|
0063002833|55|1|V63|60812|0.00|#|2016-07-11 09:56:44|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606184448|
0063002834|62|1|V63|60812|0.00|#|2016-07-11 10:02:39|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606249995|
0063002835|58|1000|V63|60812|0.00|#|2016-07-13 00:44:42|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177173088043008|
0063002835|62|2|V63|60812|0.00|#|2016-07-11 13:10:46|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606118924|
0063002836|63|1|V63|60812|0.00|#|2016-07-11 14:17:47|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174605987850|
0063002836|63|2|V63|60812|0.00|#|2016-07-11 14:17:47|2016-07-13 00:58:38|2016-07-13 00:59:17|2016-07-13 01:02:52|26177174606053378|
...
2843000258|62|4|FX4|258|0.00|#|2016-07-11 11:04:35|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:55|26177174758096905|
2843000258|62|5|FX4|258|0.00|#|2016-07-11 12:09:38|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:55|26177174757769218|
2843000258|62|6|FX4|258|0.00|#|2016-07-11 16:11:34|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:55|26177174757376002|
2843000258|62|7|FX4|258|0.00|#|2016-07-11 18:18:44|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:55|26177174757441547|
2845000257|62|1|FX6|257|0.00|#|2016-07-11 13:13:33|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:55|26177174757179400|
2846000258|62|1|FX7|258|0.00|#|2016-07-11 08:38:42|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:56|26177175987945476|
2846000258|62|2|FX7|258|0.00|#|2016-07-11 11:48:35|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:56|26177175986634761|
2846000258|62|3|FX7|258|0.00|#|2016-07-11 12:51:33|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:56|26177175986307075|
2846000258|62|4|FX7|258|0.00|#|2016-07-11 15:19:37|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:56|26177175985979395|
2846000258|62|5|FX7|258|0.00|#|2016-07-11 18:39:37|2016-07-13 01:55:18|2016-07-13 01:55:55|2016-07-13 01:55:56|26177175987552268|
Total number of rows: 17175
Total amount: 262911.15

PL/SQL procedure successfully completed.
</pre>

<p>
<b>CPTRDB_OCI_DETAILS_CENTRAL.SQL</b><br>
  Called from CPTRDB_OCI_DETAILS_CENTRAL.COM
</p>

<p>
  PL/SQL source of stored procedure S304_P_JCCLML_DETAILS_CENTRAL.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54 -- Create, Manage And Test OCI And SQL/Services Protocol Services
</font>
</h3>

<b>CPTRDB_PREPARE_DATABASE.COM</b><br><br>

<b>CPTRDB_SHOW_SQLSRV_SUMMARY.COM</b><br>
<b>CPTRDB_SHOW_SQLSRV_SUMMARY_BATCH.COM</b><br><br>

<b>CPTRDB_SHOW_SQLSRV_FULL.COM</b><br>
<b>CPTRDB_SHOW_SQLSRV_FULL_ONE.COM</b><br>
<b>CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM</b><br><br>

<b>CPTRDB_CREATE_SQLSRV.COM</b><br>
<b>CPTRDB_CREATE_SQLSRV_BATCH.COM</b><br>
<b>CPTRDB_START_SQLSRV.COM</b><br>
<b>CPTRDB_START_SQLSRV_BATCH.COM</b><br>
<b>CPTRDB_SHUTDOWN_SQLSRV.COM</b><br>
<b>CPTRDB_SHUTDOWN_SQLSRV_BATCH.COM</b><br>
<b>CPTRDB_ALTER_SQLSRV.COM</b><br>
<b>CPTRDB_ALTER_SQLSRV_BATCH.COM</b><br>
<b>CPTRDB_DROP_SQLSRV.COM</b><br>
<b>CPTRDB_DROP_SQLSRV_BATCH.COM</b><br><br>

<b>CPTRDB_CONFIGURATION.REF</b><br><br>

<b>CPTRDB_OCI_SERVICE.SQS</b><br>
<b>CPTRDB_SQLSRV_SERVICE.SQS</b><br><br>

<b>CPTRDB_CONNECT_OCI_L15S29.COM</b><br>
<b>CPTRDB_SQLSRV_SQL.COM</b><br>
<b>CPTRDB_SQLSRV_C.C</b><br>
<b>CPTRDB_SQLSRV_BUILD.COM</b><br>
<b>CPTRDB_SQLSRV_C.OBJ</b><br>
<b>CPTRDB_SQLSRV_C.EXE</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_PREPARE_DATABASE.COM</b><br>
  Prepare a database for OCI protocol services and mimic a
  Oracle RDBMS database.
</p>
  
  Parameters: Adapt the parameter block<br>

<pre>
$!------------------------
$ dbroot   = "CPTRDB_DB_1"
$ username = "{username}"
$ password = "{password}"
$!------------------------
</pre>

  OCI protocol services require:<br>

<pre>
.Prepare of the database,    ** Requires exclusive access **
.Create additional functions
.Create additional users
</pre>

<p>
  The procedure provides these three execution steps.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54.1 -- Show Services Summary
</font>
</h3>

<p>
<b>CPTRDB_SHOW_SQLSRV_SUMMARY.COM</b><br>
  Calls CPTRDB_SHOW_SQLSRV_SUMMARY_BATCH.COM per node
</p>

<p>
  Interactive list all SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_SUMMARY
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_SUMMARY|L15S28|73|
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_SUMMARY|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_SQLSRV_SUMMARY
! 2 Execution node
! 3 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_SHOW_SQLSRV_SUMMARY
</pre>

<p>
  The intermediate log and output files are cleaned by both SUMMARY procedures.
</p>
  
  Output sample:<br>

<pre>
CPTRDB - SQL/Services Services
From Node L15S29
At 30-SEP-2015 12:17:38.16
--------------------------------------------------------------------------------
 
-- 1 --
 
--------------
On Node L15S28
--------------
                                           C l i e n t s       E x e c u t o r s
Name                            State   PerExec   Max Active   Min   Max Running
C170DB4YPTO                     INACTIVE      1    12      0     0    12      0
GENERIC                         RUNNING       1    10      0     0    10      0
OCI_SAMPLE                      RUNNING       1    10      0     0    10      0
RMU_SERVICE                     RUNNING       1   100      0     0   100      0
SQLSRV_MANAGE                   RUNNING     100     0      1     0     0      0
Total number of services: 5
 
-- 2 --
 
--------------
On Node L15S29
--------------
                                           C l i e n t s       E x e c u t o r s
Name                            State   PerExec   Max Active   Min   Max Running
C170DB4YPTO                     INACTIVE      1    12      0     0    12      0
CPTRDB_OCI_SERVICE              RUNNING       1     4      0     1     4      1
CPTRDB_SQLSRV_SERVICE           RUNNING       1     4      0     1     4      1
GENERIC                         RUNNING       1    10      0     0    10      0
OCI_SAMPLE                      RUNNING       1    10      0     0    10      0
RMU_SERVICE                     RUNNING       1   100      0     0   100      0
SQLSRV_MANAGE                   RUNNING     100     0      1     0     0      0
Total number of services: 7
</pre> 

<p>
<b>CPTRDB_SHOW_SQLSRV_SUMMARY_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_SQLSRV_SUMMARY.COM per node
</p>

<p> 
List all SQL/Services services on one node sorted by name.
</p>

<pre>
Parameters: P1, output file, SHOW_SQLSRV_SUMMARY.TMP_{filecnt}
            P2, sqlsrv version, char(2), [72|73]
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54.2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54.2 -- Show Services Full
</font>
</h3>

<p>
<b>CPTRDB_SHOW_SQLSRV_FULL.COM</b><br>
  Calls CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM per service/node
</p>

<p>
  List SQL/Services services on a series of nodes in full detail,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_FULL 
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_FULL|CPTRDB_SQLSRV_SERVICE|L15S29|73|
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_FULL|CPTRDB_OCI_SERVICE|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_SQLSRV_FULL
! 2 Service name
! 3 Execution node
! 4 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_SHOW_SQLSRV_FULL
</pre>

<p>
  The intermediate log and output files are cleaned by both FULL procedures.
</p>

  Output sample:<br>

<pre>
CPTRDB - SQL/Services Services In Full Detail
From Node L15S29
At 30-SEP-2015 12:18:05.26
--------------------------------------------------------------------------------
 
-- 1 --
 
--
-- Service CPTRDB_SQLSRV_SERVICE On Node L15S29
-- At 30-SEP-2015 12:18:05.43
--
 
Connecting to server ...
Connected
Service CPTRDB_SQLSRV_SERVICE
    State:                    RUNNING
    Owner:                    rdbmon
    Owner Password:           {not specified}
    Protocol:                 SQL/Services
    Default Connect Username: {not specified}
    Default Connect Password: {not specified}
    SQL version:              7.3
    Autostart:                off
    Process init:             {not specified}
    Attach:                   ATTACH 'filename cptrdb_db_1'
    Schema:                   {not specified}
    Reuse:                    SESSION
    Database Authorization:   CONNECT USERNAME
    dbsrc file:               {not specified}
    SQL init file:            cpt$rdb:cptrdb_sqlini.sql
    Appl Transaction Usage:   SERIAL
    Idle User Timeout:        {none}
    Idle Exec Timeout:        1800 seconds
    Min Executors:            1
    Max Executors:            4
    Running Executors:        1
    Clients Per Executor:     1
    Active Clients:           0

Access to service CPTRDB_SQLSRV_SERVICE
    Granted to users:
	PUBLIC	PRIVILEGED_USER	'rdbmon'

-- 2 --
 
--
-- Service CPTRDB_OCI_SERVICE On Node L15S29
-- At 30-SEP-2015 12:18:09.17
--
 
Connecting to server ...
Connected
Service CPTRDB_OCI_SERVICE
    State:                    RUNNING
    Owner:                    rdbmon
    Owner Password:           {not specified}
    Protocol:                 OCI clients
    Default Connect Username: {not specified}
    Default Connect Password: {not specified}
    SQL version:              7.3
    Autostart:                off
    Process init:             {not specified}
    Attach:                   ATTACH 'filename cptrdb_db_1'
    Schema:                   {not specified}
    Reuse:                    SESSION
    Database Authorization:   CONNECT USERNAME
    dbsrc file:               {not specified}
    SQL init file:            cpt$rdb:cptrdb_sqlini.sql
    Appl Transaction Usage:   SERIAL
    Idle User Timeout:        {none}
    Idle Exec Timeout:        1800 seconds
    Min Executors:            1
    Max Executors:            4
    Running Executors:        1
    Clients Per Executor:     1
    Active Clients:           0

Access to service CPTRDB_OCI_SERVICE
    Granted to users:
	PUBLIC	PRIVILEGED_USER	'rdbmon'
</pre>

<p>
<b>CPTRDB_SHOW_SQLSRV_FULL_ONE.COM</b><br>
  Calls CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM
</p>

<p>
  List one SQL/Services service in full detail on the executor node
  using a hardcoded SQL/Services version, default V7.3
</p>

<pre>
Parameters: P1, service name, char(31)
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_SQLSRV_FULL_ONE {service name}
</pre>

<p>
<b>CPTRDB_SHOW_SQLSRV_FULL_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_SQLSRV_FULL[_ONE].COM per service/node
</p>

<p>
  Show one SQL/Services service on one node in full detail.
</p>
  
<pre>
Parameters: P1, service name,   char(31)
            P2, sqlsrv version, char(2), [72|73]
            P3, output file,    show_sqlsrv_full.tmp_{filecnt}
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54.3"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54.3 -- Create/Start/Shutdown/Alter/Drop Services
</font>
</h3>

<p>
<b>CPTRDB_CREATE_SQLSRV.COM</b><br>
  Calls CPTRDB_CREATE_SQLSRV_BATCH.COM per service/node
</p>

<p>
  Create SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_CREATE_SQLSRV
</p>

<pre>
CPT$RDB_NODE|CPTRDB_CREATE_SQLSRV|CPT$RDB:CPTRDB_SQLSRV_SERVICE.SQS|L15S29|73|
CPT$RDB_NODE|CPTRDB_CREATE_SQLSRV|CPT$RDB:CPTRDB_OCI_SERVICE.SQS|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_CREATE_SQLSRV
! 2 Service create script full filespec, dev:[dir]name.ext
! 3 Execution node
! 4 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_CREATE_SQLSRV
</pre>

<p>
  The unique script and logfiles<br>
  CPT$RDB_TMP:CREATE_SQLSRV_{node}_yyyymmdd.SQS_ddmmmhhmmss<br>
  CPT$RDB_LOGS:CREATE_SQLSRV_BATCH_{node}_yyyymmdd.LOG_ddmmmhhmmss<br>
  are cleaned by the procedure CPTRDB_CLEANUP_LOGS_DAILY.COM
  after eight days.
</p>

<p>
<b>CPTRDB_CREATE_SQLSRV_BATCH.COM</b><br>
  Called from CPTRDB_CREATE_SQLSRV.COM per service/node
</p>

<p>
  Create one SQL/Services service on one node.
</p>

<pre>
Parameters: P1, create script filespec,  dev:[dir]name.ext
            P2, sqlsrv version, char(2), [72|73]
</pre>

<p>
<b>CPTRDB_START_SQLSRV.COM</b><br>
  Calls CPTRDB_START_SQLSRV_BATCH.COM per service/node
</p>

<p>
  Start all SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_START_SQLSRV
</p>

<pre>
CPT$RDB_NODE|CPTRDB_START_SQLSRV|CPTRDB_SQLSRV_SERVICE|L15S29|73|
CPT$RDB_NODE|CPTRDB_START_SQLSRV|CPTRDB_OCI_SERVICE|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_START_SQLSRV
! 2 Service name
! 3 Execution node
! 4 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_START_SQLSRV
</pre>

<p>
  The unique script and logfiles<br>
  CPT$RDB_TMP:START_SQLSRV_{node}_yyyymmdd.SQS_ddmmmhhmmss<br>
  CPT$RDB_LOGS:START_SQLSRV_BATCH_{node}_yyyymmdd.LOG_ddmmmhhmmss<br>
  are cleaned by the procedure CPTRDB_CLEANUP_LOGS_DAILY.COM
  after eight days.
</p>

<p>
<b>CPTRDB_START_SQLSRV_BATCH.COM</b><br>
  Called from CPTRDB_START_SQLSRV.COM per service/node
</p>

<p>
  Start one SQL/Services service on one node.
</p>

<pre>
Parameters: P1, service name,   char(31)
            P2, sqlsrv version, char(2), [72|73]
</pre>

<p>
<b>CPTRDB_SHUTDOWN_SQLSRV.COM</b><br>
  Calls CPTRDB_SHUTDOWN_SQLSRV_BATCH.COM per service/node
</p>

<p>
  Shutdown all SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHUTDOWN_SQLSRV
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHUTDOWN_SQLSRV|CPTRDB_SQLSRV_SERVICE|L15S29|73|
CPT$RDB_NODE|CPTRDB_SHUTDOWN_SQLSRV|CPTRDB_OCI_SERVICE|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHUTDOWN_SQLSRV
! 2 Service name
! 3 Execution node
! 4 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_SHUTDOWN_SQLSRV
</pre>

<p>
  The unique script and logfiles<br>
  CPT$RDB_TMP:SHUTDOWN_SQLSRV_{node}_yyyymmdd.SQS_ddmmmhhmmss<br>
  CPT$RDB_LOGS:SHUTDOWN_SQLSRV_BATCH_{node}_yyyymmdd.LOG_ddmmmhhmmss<br>
  are cleaned by the procedure CPTRDB_CLEANUP_LOGS_DAILY.COM
  after eight days.
</p>

<p>
<b>CPTRDB_SHUTDOWN_SQLSRV_BATCH.COM</b><br>
  Called from CPTRDB_SHUTDOWN_SQLSRV.COM per service/node
</p>

<p>
  Shutdown one SQL/Services service on one node.
</p>
  
<pre>
Parameters: P1, service name,   char(31)
            P2, sqlsrv version, char(2), [72|73]
</pre>
  
<p>
<b>CPTRDB_ALTER_SQLSRV.COM</b><br>
  Calls CPTRDB_ALTER_SQLSRV_BATCH.COM per service/node
</p>

<p>
  Alter SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_ALTER_SQLSRV
</p>

<pre>
CPT$RDB_NODE|CPTRDB_ALTER_SQLSRV|CPTRDB_SQLSRV_SERVICE|L15S29|73|AUTOSTART ON|
CPT$RDB_NODE|CPTRDB_ALTER_SQLSRV|CPTRDB_OCI_SERVICE|L15S29|73|AUTOSTART ON|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_ALTER_SQLSRV
! 2 Service name
! 3 Execution node
! 4 SQL/Services version, char(2)
! 5 Alter clause
</pre>

Usage:<br>

<pre>
$ @CPTRDB_ALTER_SQLSRV
</pre>

<p>
  The unique script and logfiles<br>
  CPT$RDB_TMP:ALTER_SQLSRV_{node}_yyyymmdd.SQS_ddmmmhhmmss<br>
  CPT$RDB_LOGS:ALTER_SQLSRV_BATCH_{node}_yyyymmdd.LOG_ddmmmhhmmss<br>
  are cleaned by the procedure CPTRDB_CLEANUP_LOGS_DAILY.COM
  after eight days.
</p>

<p>
<b>CPTRDB_ALTER_SQLSRV_BATCH.COM</b><br>
  Called from CPTRDB_ALTER_SQLSRV.COM per service/node
</p>

<p>
  Alter one SQL/Services service on one node.
</p>
  
<pre>
Parameters: P1, service name,   char(31)
            P2, sqlsrv version, char(2), [72|73]
            P3, alter clause,   varchar(255)
</pre>

<p>
<b>CPTRDB_DROP_SQLSRV.COM</b><br>
  Calls CPTRDB_DROP_SQLSRV_BATCH.COM per service/node
</p>

<p>
  Drop SQL/Services services on a series of nodes,
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_DROP_SQLSRV
</p>

<pre>
CPT$RDB_NODE|CPTRDB_DROP_SQLSRV|CPTRDB_SQLSRV_SERVICE|L15S29|73|
CPT$RDB_NODE|CPTRDB_DROP_SQLSRV|CPTRDB_OCI_SERVICE|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_DROP_SQLSRV
! 2 Service name
! 3 Execution node
! 4 SQL/Services version, char(2)
</pre>

Usage:<br>

<pre>
$ @CPTRDB_DROP_SQLSRV
</pre>

<p>
  The unique script and logfiles<br>
  CPT$RDB_TMP:DROP_SQLSRV_{node}_yyyymmdd.SQS_ddmmmhhmmss<br>
  CPT$RDB_LOGS:DROP_SQLSRV_BATCH_{node}_yyyymmdd.LOG_ddmmmhhmmss<br>
  are cleaned by the procedure CPTRDB_CLEANUP_LOGS_DAILY.COM
  after eight days.
</p>

<p>
<b>CPTRDB_DROP_SQLSRV_BATCH.COM</b><br>
  Called from CPTRDB_DROP_SQLSRV.COM per service/node
</p>

<p>
  Drop one SQL/Services service on one node.
</p>
  
<pre>
Parameters: P1, service name,   char(31)
            P2, sqlsrv version, char(2), [72|73]
</pre>

<p>
<b>CPTRDB_OCI_SERVICE.SQS</b><br>
  Create the OCI protocol service CPTRDB_OCI_SERVICE
</p>

<p>
<b>CPTRDB_SQLSRV_SERVICE.SQS</b><br>
  Create the SQL/Services protocol service CPTRDB_SQLSRV_SERVICE
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54.4"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54.4 -- OCI Protocol Services Configuration Files
</font>
</h3>

<p>
The configuration files for OCI protocol services must contain the following
code snippets.
</p>

<p>
-- On the server side --
</p>

<pre>
SYS$COMMON:[SQLSRV73.SQLNET.NETWORK.ADMIN]LISTENER.ORA

####
OCI_LISTENER =
  (ADDRESS_LIST =
        (ADDRESS =
          (COMMUNITY = TCP_COM.world)
          (PROTOCOL = TCP)
          (Host = {host})
          (Port = 1527)
        )
  )
####

The OCI dispatcher must specify the same name "OCI_LISTENER" for the
SQL*Net listener as defined in LISTENER.ORA 

--
Dispatcher OCI_DISP
    State:                     RUNNING
    Autostart:                 on
    Max connects:              100 clients
    Idle User Timeout:         {none}
    Max client buffer size:    5000 bytes
    Network Ports:                                     (State)   (Protocol)
      SQL*Net listener oci_listener                    Running   OCI clients
    Log path:            SYS$MANAGER:
    Dump path:           SYS$MANAGER:
    Log File:                  SYS$SYSROOT:[SYSMGR]SQS_L15S29_OCI_DISP00D73.LOG;
    Dump File:                 SYS$SYSROOT:[SYSMGR]SQS_L15S29_OCI_DISP00D.DMP;
--
</pre>


<p>
-- On the client side --<br><br>

Using the OpenVMS Oracle client.
</p>

<p>
<b>CPTRDB_CONNECT_OCI_L15S29.COM</b><br>
  Create a DCL symbol to connect to the OCI service
</p>

<pre>
----
$ set nover
$ set process/parse_style=traditional
$ @{dev}:[ORACLE10202]orauser
$ ctrgt :== "''sqlplus' {user}/{passwd}@CPTRDB_OCI_SERVICE"
$ write sys$output "Symbol ctrgt defined as {user}/{passwd}@CPTRDB_OCI_SERVICE"
$ set nover
$ exit
----

The @{name} is the .WORLD entry name in
{dev}:[ORACLE10202.NETWORK.ADMIN]TNSNAMES.ORA

####
CPTRDB_OCI_SERVICE.WORLD =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = {host})(PORT = 1527))
    )
    (CONNECT_DATA = (SID = CPTRDB_OCI_SERVICE))
  )
####

The SID is the server service name.
</pre>

Test run:<br>

<pre>
$ @CONNECT_OCI_L15S29
Symbol ctrgt defined as {user}/{passwd}@CPTRDB_OCI_SERVICE
$ ctrgt

SQL*Plus: Release 10.2.0.2.0 - Production on Tue May 6 17:16:40 2014

Copyright (c) 1982, 2005, Oracle.  All Rights Reserved.

Connected to:
Oracle Compatible Release 10.2.0.4.0
Oracle Rdb OCI Server Release 7.3.1.1.1 - Production, Level 1.7
Oracle Rdb SQL Release 7.3.1.1.0 - Production

SQL> select rdb$file_name from rdb$database;

RDB$FILE_NAME
--------------------------------------------------------------------------------
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
</pre>

<p>
The command file RDB$NATCONN_CHECK_SETUP73.COM in SYS$COMMON:[SYSTEST.SQLSRV73]
provides a test for the OCI service setup on the executor node. The
procedure requires valid LISTENER.ORA and TNSNAMES.ORA files in the
(sub)directories specified by SYS$COMMON:[SYSMGR]SQLSRV_SQLNET73.DAT,
for the OCI service being tested. The default directory is
SYS$COMMON:[SQLSRV73.SQLNET.NETWORK.ADMIN].
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 54.5"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 54.5 -- Test A SQL/Services Protocol Service From A C Program
</font>
</h3>

<p>
<b>CPTRDB_SQLSRV_SQL.COM</b><br>
  Create tables and stored procedure to be used in the example code
  CPT$RDB:CPTRDB_SQLSRV_C.C
</p>

<p>
<b>CPTRDB_SQLSRV_C.C</b><br>
  SQL/Services example code based on 'My Oracle Support' Document Id 94363.1<br>
  Calls the database objects created in
  CPT$RDB:CPTRDB_SQLSRV_SQL.COM
</p>

<pre>
 Table:     sqlsrv_employees
 Table:     sqlsrv_insert_table
 Module:    sqlsrv_insert_module
 Procedure: sqlsrv_insert
</pre>

<p>
  Read all the rows of the SQLSRV_EMPLOYEES table and insert each EMPLOYEE_ID
  in the SQLSRV_INSERT_TABLE table using the stored procedure SQLSRV_INSERT.

  Use the SQLSRV protocol type service CPTRDB_SQLSRV_SERVICE (server class),
  pre attached to the database CPTRDB_DB_1.
</p>

<p>
<b>CPTRDB_SQLSRV_BUILD.COM</b><br>
  Build file for CPT$RDB:CPTRDB_SQLSRV_C.C
</p>

<p>
<b>CPTRDB_SQLSRV_C.OBJ</b><br>
<b>CPTRDB_SQLSRV_C.EXE</b><br>
  Object and image file of CPT$RDB:CPTRDB_SQLSRV_C.C 
</p>

Test run:<br>

<pre>
$ run CPTRDB_SQLSRV_C.EXE

 Server Node (No more than 6)  ? {node}
 Username (No more than 12)  ? {username}
 Password (No more than 32) ? {password}
 Server Class (No more than 31) ? cptrdb_sqlsrv_service
Storing data into stored procedure
Storing data into stored procedure
Storing data into stored procedure
Storing data into stored procedure
Storing data into stored procedure

$ @cptrdb_attach cptrdb_db_1
Default transaction is read only
SQL$DATABASE is CPTRDB_DB_1
$ sql
SQL> select * from sqlsrv_insert_table;
 FIELD1
 11111...............
 22222...............
 33333...............
 44444...............
 55555...............
5 rows selected
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 55"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 55 -- List And Check OCI And SQL/Services Protocol Services
</font>
</h3>

<b>CPTRDB_SHOW_SQLSRV_DAILY.COM</b><br>
<b>CPTRDB_SHOW_SQLSRV_DAILY_BATCH.COM</b><br><br>

<b>CPTRDB_SHOW_SQLSRV.REF</b> (Reference file)<br>
<b>CPTRDB_CONFIGURATION.REF</b> (Configuration file)<br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SHOW_SQLSRV.REF</b><br>
  Reference file.<br>
  The services states are aligned on the longest service name. 
</p>

<p>
<b>CPTRDB_SHOW_SQLSRV_DAILY.COM</b><br>
  Calls CPTRDB_SHOW_SQLSRV_DAILY_BATCH.COM per node
</p>

<p>
  Daily list the SQL/Services services summary on a series of nodes, 
  enumerated in the configuration file CPTRDB_CONFIGURATION.REF,
  identified by the keywords CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_DAILY
</p>

<pre>
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_DAILY|L15S28|73|
CPT$RDB_NODE|CPTRDB_SHOW_SQLSRV_DAILY|L15S29|73|
!
! 0 CPT$RDB_NODE
! 1 CPTRDB_SHOW_SQLSRV_DAILY
! 2 Execution node
! 3 SQL/Services version, char(2)
</pre>

<p>
  The output file is identical to the results of the procedure
  CPTRDB_SHOW_SQLSRV_SUMMARY.COM.

  Send a CockpitMgr event and mail if a difference is found with reference file
  CPTRDB_SHOW_SQLSRV.REF.

  The reschedule node/time and the exception mail address are retrieved
  from the configuration file, identified by the keywords  
  CPT$RDB_JOB|CPTRDB_SHOW_SQLSRV_DAILY
</p>

<pre>  
CPT$RDB_JOB|CPTRDB_SHOW_SQLSRV_DAILY|L15S29|TOMORROW +08:00|L15S36::ALLEMEERSCH|
!
! 0 CPT$RDB_JOB
! 1 CPTRDB_SHOW_SQLSRV_DAILY
! 2 Reschedule node
! 3 Reschedule time
! 4 Exception mail address
</pre>

<p>
  In order to align the service states in the temporary reference file, the
  longest service name length across the nodes, is defined in the
  configuration file as parameter to the procedure, identified by the keywords
  CPT$RDB_PARAM|CPTRDB_SHOW_SQLSRV_DAILY.
</p>

<pre>
CPT$RDB_PARAM|CPTRDB_SHOW_SQLSRV_DAILY|21|
!
! 0 CPT$RDB_PARAM
! 1 CPTRDB_SHOW_SQLSRV_DAILY
! 2 All nodes longest service name length, to align state in tmp reference file
</pre>

  Toolset CockpitMgr event:<br>

<pre>
CPTRDB_SQLSRV_Differences
CPTRDB - SQLSRV Differences {node} - ddmmmhhmmss"
</pre>

  Mail subject:<br>

<pre>
"CPTRDB - SQLSRV Diff {node} yyyymmdd"
</pre>

<p>
<b>CPTRDB_SHOW_SQLSRV_DAILY_BATCH.COM</b><br>
  Called from CPTRDB_SHOW_SQLSRV_DAILY.COM per node
</p>

<p>
  List all SQL/Services services on one node sorted by name.
</p>
  
<pre>
Parameters: P1, output file, SHOW_SQLSRV_DAILY.TMP_{filecnt}
            P2, sqlsrv version, char(2), [72|73]
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 56"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 56 -- Implement Row Cache
</font>
</h3>

<b>CPTRDB_ADD_CACHE.COM</b><br>
<b>CPTRDB_POPULATE_CACHE.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
This chapter implements a tutorial, demonstration and test row cache
environment. A row cache is created for each sorted index storage area
of the test database.
</p>

Row caching requires the database settings:<br>

<pre>
NUMBER OF CLUSTER NODES 1
AIJ journaling enabled
FAST COMMIT enabled
ROW CACHE enabled
Row CACHE SLOTS reserved
</pre>

<p>
Based on the read_only/read_write nature and frequency of data access path 
patterns and data volume distributions, the database administrator will have 
to decide which logical and/or storage areas are candidate database objects 
to be cached and make a number of design choices for the row cache 
implementation.

The effectiveness of the caches will have to be monitored runtime, using
the series of specific cache screens within RMU/Show Statistics, such as:
</p>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-130 Perf. Monitor 20-OCT-2015 16:40:00.85
Rate: 3.00 Seconds              Row Cache Status         Elapsed: 32 04:23:52.27
Page: 1 of 1      DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1       Mode: Online

                         For Cache: CACHE_INDEX_AREA_1
Statistic.Name Stat.Value Percent                                      MRES

Total slots:         512  100.0% Slot Length: 1988  Hash slots: 512
Slots full:            4    0.8% Use:          0   0.8%
Slots empty:         508   99.2% Rsv:          0   0.0%
Marked Slots:          0    0.0% Hot:          0   0.0% Cold:          0   0.0%
Clean Slots:         512  100.0% Hot:          0   0.0% Cold:        512 100.0%
Used Space:            7k   0.8% Wstd:         0k  0.0% Free:      1009k  99.2%
Hash Que Lengths:  Empty:508 1:4        2:0        3:0        4+:0
Cursor position:   9 of 512 wrapped 0 times
Cache latched:     No
Cache is full:     No            Cache modified:    No   Snapshot is full: No
Checkpoints: 3587 Last: 20-OCT-2015 16:38:19.26 AIJ Location: 7279:6
Cache Recovery:    7279:6
Snap Slots:          128  100.0% Ful:          0   0.0% Rcl:          0   0.0%
Snap Cursor:  0 of 128 (slot 512) wrapped 0 times

...

Node: L15S29 (1/1/1)   Oracle Rdb V7.3-130 Perf. Monitor 20-OCT-2015 16:41:21.04
Rate: 3.00 Seconds       Row Cache (CACHE_INDEX_AREA_1   Elapsed: 32 04:25:12.46
Page: 1 of 1      DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1       Mode: Online

statistic........... rate.per.second............. total....... average......
name................ max..... cur..... avg....... count....... per.trans....
latch requests              0        0        0.0            1           0.0
 retried                    0        0        0.0            0           0.0
cache searches              0        0        0.0           16           0.0
 found in workset           0        0        0.0            8           0.0
 found in cache             0        0        0.0            4           0.0
 found too big              0        0        0.0            0           0.0
insert cache                0        0        0.0            4           0.0
 row too big                0        0        0.0            0           0.0
 cache full                 0        0        0.0            0           0.0
 collision                  0        0        0.0            0           0.0
skipped dirty slot          0        0        0.0            0           0.0
skipped inuse slot          0        0        0.0            0           0.0
hash misses                 0        0        0.0            0           0.0
cache unmark                0        0        0.0            0           0.0
snapshot search             0        0        0.0            0           0.0
 snap found cache           0        0        0.0            0           0.0
</pre>

<p>
The logical RDM$BIND_RCS_INITIAL_MAP_ALL_CACHES (if set) determines if all
defined row caches are created on database open or on first access
of the cache.

The logical RDM$BIND_RCACHE_INSERT_ENABLED allows to determine on a
per process basis if rows/index nodes are inserted into the cache.
Sequential scans never load data into a cache.

The actual settings for the template caches created here are listed below. 
</p>

From RMU/Dump/Header:<br>

<pre>
- Row Cache RUJ buffers section size is 14,708,736 bytes (15MB)

Row Caches...
  - Active row cache count is 3
  - Reserved row cache count is 8
  - Checkpoint information
      Time interval is 900 seconds
      Default source is updated rows
      Default target is backing file
      Default backing file directory is "DISK$DATA_29:[CPT$RDB_CACHES]"
      RUJ Global Buffers are enabled
      RCS sweep time interval is 300 seconds

Row cache "CACHE_INDEX_AREA_1"
    Cache ID number is 1
    Allocation...
      - Row slot count is 512
        - Snapshot slot count is 128
        - Snapshots in cache enabled
      - Maximum row size allowed in cache is 1988 bytes
      - Working set count is 10
      - Maximum slot reservation count is 16
      - Row replacement is enabled
    Sweeping...
      - Sweep row count is 32
      - Maximum batch I/O count is 3000
    Checkpointing...
      - Source is updated rows
      - Target is backing file
      - Last checkpoint is 1571:25
      - Checkpoint sequence is 0
    Files...
      - Default cache file directory is "DISK$DATA_29:[CPT$RDB_CACHES]"
      - Cache file was last created in directory "DISK$DATA_29:[CPT$RDB_CACHES]"
      - File allocation is 12000 blocks
      - File extension is 12000 blocks
    Hashing...
      - Hash value for logical area DBIDs is 31
      - Hash value for page numbers is 7
    Shared Memory...
      - Shared memory will be mapped resident
      - Global Section Name is "RDM73RDSA2903FE00D4000000000001"
      - Shared memory section requirement is 1,318,912 bytes (2MB)
</pre>  

From SQL> SHOW CACHE:<br>

<pre>
-- Logical area / Storage area cache

CACHE_INDEX_AREA_1
   Cache Size:            512 rows
   Row Length:            1988 bytes
   Row Replacement:       Enabled
   Shared Memory:         Process Resident
   Large Memory:          Disabled
   Window Count:          100
   Working Set Count:     10
   Location:              DISK$DATA_29:[CPT$RDB_CACHES]
   Reserved Rows:         16
   Sweep Rows:            32
   Allocation:            12000 blocks
   Extent:                12000 blocks
   Row cache: checkpoint updated rows to backing file
   Snapshot in Cache:     Enabled
   Snapshot Cache Size:   128 rows
</pre>

<p>
<b>CPTRDB_ADD_CACHE.COM</b><br>
  Create a row cache for each sorted index storage area<br>
  INDEX_AREA_1<br>
  INDEX_AREA_2<br>
  INDEX_AREA_3<br>
  of the test database CPTRDB_DB_1
</p>

<p>
  The database must be closed to run this procedure.
</p>

  The procedure can be executed in 3 seperate steps:<br>

<pre>
. Adapt the database parameters
. Create/Alter the row caches 
. Assign the caches to the storage areas
</pre>

<p>
<b>CPTRDB_POPULATE_CACHE.COM</b><br>
  Fill the row caches by reading all nodes of index TABLE_PARTI_IDX.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 57"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 57 -- Implement Hot Standby
</font>
</h3>

<b>CPTRDB_CREATE_MASTR_DB.COM</b><br>
<b>CPTRDB_CREATE_MASTR_DB_TABLES.COM</b><br>
<b>CPTRDB_CREATE_MASTR_DB_AIJ.COM</b><br>
<b>CPTRDB_MASTR_DB_INSERT.COM</b><br><br>

<b>CPTRDB_RESTORE_OPTIONS.COM</b><br>
<b>CPTRDB_STDBY_DB_L15S29_20150113.OPT</b><br>
<b>CPTRDB_STDBY_DB_L15S29_20150113.AIJ_OPT</b><br>
<b>CPTRDB_RESTORE_DATABASE.COM</b><br>
<b>CPTRDB_STDBY_DB_ALTER.COM</b><br><br>

<b>CPTRDB_REPLICATE_AFTER_CONFIG.COM</b><br>
<b>CPTRDB_REPLICATE_AFTER_START.COM</b><br>
<b>CPTRDB_REPLICATE_AFTER_STOP.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The procedures and actions listed in this chapter, executed in sequence, 
provide a tutorial demonstration and test hot standby environment. 
</p>

<p>
<b>CPTRDB_CREATE_MASTR_DB.COM</b><br>
  Create the physical hot standby master database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------
$ dev  = "DISK$DATA_29:"
$ dbid = "CPTRDB_MASTR_DB"
$!------------------------
</pre>

<p>
<b>CPTRDB_CREATE_MASTR_DB_TABLES.COM</b><br>
  Create a table named MASTR_TABLE and load procedure in the master database 
  to test hot standby replication.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------
$ define sql$database cptrdb_mastr_db
$!-----------------------------------
</pre>

<p>
<b>CPTRDB_CREATE_MASTR_DB_AIJ.COM</b><br>
  Enable AIJ, fast commit and continuous logmining for the master database.
  Perform a initial offline database backup.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!------------------------------
$ dbid =       "CPTRDB_MASTR_DB"
$ define dbroot cptrdb_mastr_db
$!------------------------------
</pre>

<p>
Add the master database to the configuration file CPTRDB_CONFIGURATION.REF 
to participate in the normal database and AIJ journal backup operations. 
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_BACKUP_DB|CPTRDB_MASTR_DB|7.3|L15S29|
CPT$RDB_DATABASE|CPTRDB_BACKUP_AIJ|CPTRDB_MASTR_DB|7.3|L15S29|
</pre>

Run normal operations on the master database.<br>

<p>
<b>CPTRDB_MASTR_DB_INSERT.COM</b><br>
  Insert some data into the master database using the stored procedure
  LOAD_MASTR_TABLE.
</p>

<pre>
Parameters: P1, start count, integer
            P2, end   count, integer
            P3, string,    , char(10)

Usage:
$ @CPTRDB_MASTR_DB_INSERT {integer} {integer} {string varchar(10)}
</pre>

<hr>
The procedure for an existing master database starts from here.<br>
<hr>

<p>
<b>CPTRDB_RESTORE_OPTIONS.COM</b><br>
  Create the standby restore options files in CPT$RDB_DATA: and adapt the 
  physical file locations.
</p>

<pre>
Usage:
$ @CPTRDB_RESTORE_OPTIONS [{dbid_backup}|CPTRDB_MASTR_DB] -
                          [{dbid_restore}|CPTRDB_STDBY_DB]

The kit contains the template options files:
CPTRDB_STDBY_DB_L15S29_20150113.AIJ_OPT
CPTRDB_STDBY_DB_L15S29_20150113.OPT

Adapt the filespecs and copy them to CPT$RDB_DATA:
</pre>

<p>
 Create a quiet point AIJ backup of the master database by renaming today's
 AIJ backup files in CPT$RDB_AIJ_BCK to a [.RENAME] subdirectory and run 
 CPTRDB_BACKUP_AIJ_ALL .
</p>

<p>
 Stop AIJ backups for the master database by commenting out it's entry in the
 configuration file.
</p>

<pre>
!! CPT$RDB_DATABASE|CPTRDB_BACKUP_AIJ|CPTRDB_MASTR_DB|7.3|L15S29|
</pre>

<p>
 Create a quiet point database backup of the master database by renaming today's
 database backup files in CPT$RDB_DB_BCK to a [.RENAME] subdirectory and run 
 CPTRDB_BACKUP_DB_ALL .
</p>

<p>
<b>CPTRDB_RESTORE_DATABASE.COM</b><br>
  Restore the master database backup as standby database. 
</p>

  Parameters: Adapt the parameter block:<br>

<pre>
$! -- Restore the standby database
$!------------------------------------------------------------------------------
$!$ dev_restore  = "DISK$DATA_29:"
$!$ dbid_restore = "CPTRDB_STDBY_DB"
$!$ nodeid_opt   = "L15S29"
$!$ yyyymmdd_opt = "20150113"
$!$ rbf_file     = "CPT$RDB_DB_BCK:CPTRDB_MASTR_DB_L15S29_20150622_1305.RBF;1"
$!------------------------------------------------------------------------------
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_RESTORE_DATABASE
</pre>

<p>
Open the standby database with row cache disabled, do not touch it.
</p>

  Usage:<br>

<pre>
$ RMU/OPEN/ROW_CACHE=DISABLED {cptrdb_stdby_db}
</pre>

<p>
<b>CPTRDB_REPLICATE_AFTER_CONFIG.COM</b><br>
  Configure the master and standby database.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------------------------------
$ mastr_db_id = "DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB"
$ stdby_db_id = "DISK$DATA_29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB"
$!-----------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_REPLICATE_AFTER_START.COM</b><br>
  Start the replication between master and stanby, always first on the standby.
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------------------------------
$ mastr_db_id = "DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB"
$ stdby_db_id = "DISK$DATA_29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB"
$!-----------------------------------------------------------------
</pre>

<p>
 Reenable AIJ backups for the master database by reactivating the entry
 in the configuration file.
</p>

<pre>
CPT$RDB_DATABASE|CPTRDB_BACKUP_AIJ|CPTRDB_MASTR_DB|7.3|L15S29|
</pre>

<p>
 Rename the renamed AIJ and database backup files to their original 
 directories CPT$RDB_AIJ_BCK and CPT$RDB_DB_BCK.
</p>

<p>
 Do some updates on the master database to test the running replication.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_MASTR_DB_INSERT {integer} {integer} {string varchar(10)}
</pre>

<p>
Check the replicated data on the standby database in read only.
</p>

  Usage:<br>

<pre>
$ @SYS$SHARE:RDB$SETVER [7.3|7.2]
$ @CPTRDB_ATTACH cptrdb_stdby_db
$ SQL := $SQL$
$ SQL
$ SQL> select * from mastr_table;
       commit;
</pre>

<p>
<b>CPTRDB_REPLICATE_AFTER_STOP.COM</b><br>
  Stop the replication, always first on the master. 
</p>

  Parameters: Adapt the parameter block.<br>

<pre>
$!-----------------------------------------------------------------
$ mastr_db_id = "DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB"
$ stdby_db_id = "DISK$DATA_29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB"
$!-----------------------------------------------------------------
</pre>

<p>
<b>CPTRDB_STDBY_DB_ALTER.COM</b><br>
  Reconfigure the standby database to production parameters before using
  it as master database on failover, in case the standby was restored with
  different database settings.
</p>

  Parameters: Adapt the parameter block and database settings.<br>

<pre>
$!-----------------------------------------------------------------
$ mastr_db_id = "DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB"
$ stdby_db_id = "DISK$DATA_29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB"
$!-----------------------------------------------------------------
</pre>

<p>
 Note that you cannot simply stop the replication, reconfigure and restart
 in the reverse direction without going thru the backup/restore phase.

 This results in the LRS bugcheckdump (Rdb V7.3-120):
</p>

<pre>
***** Exception at 000000008037A910 : RDMLRS73\PIO$BIND + 000006A0
%COSI-F-BUGCHECK, internal consistency failure
Saved PC = 00000000800F90A0 : RDMLRS73\ELF$TFRADR + 000023A0
</pre>

<p>
 A series of RMU/Show Statistics screens allow to monitor the hot standby
 activity, such as
</p>

<pre>
Node: L15S29 (1/1/1)   Oracle Rdb V7.3-130 Perf. Monitor 21-OCT-2015 12:57:39.08
Rate: 1.00 Second            Hot Standby Statistics      Elapsed: 33 00:40:32.01
Page: 1 of 1  DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1   Mode: Online

State:Active      UserSync: Cold Current.Msg: 1222    Cl Mstr.AIJ: 2806:2
LagTime: 00:00:00 AutoSync: Cold Stalled.Msg: none     1 Stby.AIJ: 2806:2
Stby.DB: L15S29::DSA29:[CPTRDB_STDBY_DB]CPTRDB_STDBY_DB.RDB;1
statistic.........      rate.per.second............. total....... average......
name..............      max..... cur..... avg....... count....... per.trans....
AIJ network send               1        0        0.0        41605          77.4
AIJ network recv               1        0        0.0        41271          76.8
Net msg processed              0        0        0.0            0           0.0
 data                          0        0        0.0          997           1.8
 control                       1        0        0.0        40608          75.6
 checkpoints                   1        0        0.0        24118          44.9
Stall time x1000               0        0        0.0        83858         156.2
blocks shipped                 1        0        0.0        41616          77.4
 received                      1        0        0.0        41271          76.8
Stalled MSN found              0        0        0.0            0           0.0
Sync mode change               0        0        0.0            0           0.0
Network Reconnect              0        0        0.0            0           0.0
Free Network Xmit              0        0        0.0            1           0.0

...

Node: L15S29 (1/1/1)   Oracle Rdb V7.3-130 Perf. Monitor 21-OCT-2015 12:58:43.27
Rate: 1.00 Second       Synchronization Mode Statistic   Elapsed: 33 00:41:36.20
Page: 1 of 1  DISK$DATA_29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1   Mode: Online

statistic.........      rate.per.second............. total....... average......
name..............      max..... cur..... avg....... count....... per.trans....

transactions                   0        0        0.0          537           1.0

Cold sync send                 0        0        0.0          334           0.6
Warm sync send                 0        0        0.0            0           0.0
Hot sync send                  0        0        0.0            0           0.0
Commit sync send               1        0        0.0        41273          76.8

Cold stall x1000               0        0        0.0           14           0.0
Warm stall x1000               0        0        0.0            0           0.0
Hot stall x1000                0        0        0.0            0           0.0
Commit stall x1000             0        0        0.0        83844         156.1

Startup/Shutdown               0        0        0.0            1           0.0
Unexpected Failure             0        0        0.0            0           0.0
</pre>

<p>
The (re)start of the replication may fail with the messages below if the AIJ
sequence number that is current on the standby database has already been backed
up on the master database.
</p>

<pre>
(From the monitor logfile)
(SYS$SYSROOT:[SYSEXE]RDMMON73.LOG)

24-JAN-2017 10:15:44.11 - Received AIJ Log Catch-Up Server process termination from 2F606ABA:1
  - database name "DSA29:[CPTRDB_MASTR_DB]CPTRDB_MASTR_DB.RDB;1" [_DSA29] (769,35902,0)
  - process failed
    %RDMS-F-HOTSEQBCK, cannot find AIJ journal required to start replication
  - sending AIJ Log Catch-Up Server start reply to 2F605E62:0
    - %RDMS-F-CANTSTARTLCS, error starting AIJ Log Catch-Up Server process
    - -RDMS-F-HOTSEQBCK, cannot find AIJ journal required to start replication
  - LCS inactivated
</pre>

<p>
In this case, stop the AIJ backups on the master database, and recover the 
standby database with the AIJ backup files of the master database, starting
with the sequence number that is current on the standby database.
</p>

<p>
Usage:
</p>

<pre>
$ @CPTRDB_SHOW_AIJ_BCK_ONE cptrdb_mastr_db
(Creates CPT$RDB_DATA:AIJ_BCK_CPTRDB_MASTR_DB_L15S29_20170124.LIS_24JAN125506;1)

DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_1007_7372.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_1208_7373.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_1408_7374.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_1608_7375.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_1808_7376.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_2009_7377.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170123_2209_7378.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170124_0009_7379.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170124_0610_7380.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170124_0810_7381.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170124_1010_7382.AIJ_BCK;1
DISK$DATA_29:[CPT$RDB_AIJ_BCK]CPTRDB_MASTR_L15S29_20170124_1210_7383.AIJ_BCK;1

Adapt CPTRDB_RECOVER_DATABASE.COM

$!------------------------------------------------------------------------------
$ mailto1      = "L15S36::ALLEMEERSCH"
$ dbid_backup  = "CPTRDB_MASTR_DB"
$ dbid_restore = "CPTRDB_STDBY_DB"
$! -- AIJ backup files list in CPT$RDB_DATA:
$ nodeid       = "L15S29"
$ yyyymmdd     = "20170124"
$ ddmmmhhmmss  = "24JAN125506"
$!------------------------------------------------------------------------------

$ RMU/Close CPTRDB_STDBY_DB
$ @CPTRDB_SUBMIT {node} CPTRDB_RECOVER_DATABASE

$ RMU/Open CPTRDB_STDBY_DB
$ CPTRDB_REPLICATE_AFTER_START

[The start of the replication will execute a AIJ backup of the master and
standby database.]

Reactivate AIJ backups on the master database.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58 -- Database Lock Trees
</font>
</h3>

<b>CPTRDB_LOCK_MANAGER.TXT</b><br>
<b>CPTRDB_LCK_SHOW_ACTIVE.COM</b><br><br>

<b>$ MONITOR LOCK</b><br>
<b>$ MONITOR DLOCK</b><br>
<b>$ MASTERLOCK/DATABASE</b><br><br>

<b>SYSGEN </b><br>
<b>.LOCKDIRWT </b><br>
<b>.LOCKRMWT </b><br>
<b>.PE1</b><br>
<b>.DEADLOCK_WAIT</b><br>
<b>RDMS$BIND_DEADLOCK_WAIT</b><br><br>

<b>Rdb Database Lock Resource Name</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_LOCK_MANAGER.TXT</b><br>
  Introduces system management of the OpenVMS Distributed Lock Manager.
  Contains an extract of the manual 'HP OpenVMS Cluster Systems', OpenVMS V8.4,
  Part Id BA554-90021
</p>

  This text is highly recommended reading as introduction to this chapter.<br>

<p>
Unless partitioned locktrees are enabled, all clusterwide OpenVMS distributed
lock manager locks for one database are created in one lock tree structure, 
below the single top level 'database lock'. The resource name structure of the
'database lock' as well as lock remastering in a OpenVMS cluster are discussed
in this chapter.
With partitioned locktrees enabled, each storage area has a (smaller) separate
individual lock tree, that can be remastered in a cluster to the node
where this storage area is most accessed. (In case multiple applications
are directed towards specific storage areas and specific nodes).
</p>

<p>
<b>CPTRDB_LCK_SHOW_ACTIVE.COM</b><br>
  List the active Rdb database lock trees and their masternode on the executor
  node using
</p>

<pre>
$ ANALYZE/SYSTEM
SDA> LCK SHOW ACTIVE
</pre>

<p>
  The procedure filters the output for Rdb database resource names. 
</p>

  Usage:<br>

<pre>
$ @CPTRDB_LCK_SHOW_ACTIVE
</pre>

  Output sample:<br>

<pre>
                       Total     Local
RSB Address            Locks     Locks   SubRSB     Act   Node     Resource Name
FFFFFFFE.33F46E40      81805     11417      196   20248   L15S50   Ý...D....DATA_21     .......   
                                                          DISK$DATA_21:[BDG_DB]BDG_DB.RDB;1
FFFFFFFE.339B7C00     118051    118051      851   17069   L15S59   Ý...D....DATA_21     .......   
                                                          DISK$DATA_21:[SSP_DB_PROD]SSP_DB.RDB;1
FFFFFFFE.33E1A6C0     134283    134283      420    2308   L15S58   Ý...D....DATA_23     .......   
                                                          DISK$DATA_23:[SBN_DB]SABIN_TT.RDB;1
FFFFFFFE.339CB0C0      57377     57377      202      14   L15S58   Ý...D....DATA_25     .2.....   
                                                          DISK$DATA_25:[C170_DB]C170_DB.RDB;1
FFFFFFFE.33FA46C0        427       427      395       7   L15S59   Ý...D....DATA_22     .3.....   
                                                          DISK$DATA_22:[SSP_DB_CMP]SSP_DB.RDB;1
                       Total     Local
RSB Address            Locks     Locks   SubRSB     Act   Node     Resource Name
FFFFFFFE.33F4CBC0      15677     15677      245       2   L15S59   Ý...D....DATA_25     ...!...   
                                                          DISK$DATA_25:[CLIO_DB]CLIO_DB.RDB;1
FFFFFFFE.33FB8080        151       151      120       1   L15S59   Ý...D....DATA_24     .F.....   
                                                          DISK$DATA_24:[TRACE_DB]TRACE_DB.RDB;1
FFFFFFFE.33F8CF80        151       151      120       1   L15S59   Ý...D....DATA_23     .......   
                                                          DISK$DATA_23:[GPS_DB]GPS_DB.RDB;1
FFFFFFFE.33D8FD40        151       151      120       1   L15S58   Ý...D....DATA_21     .¡.....   
                                                          DISK$DATA_21:[EXP_DB]EXPLOITATION_DB.RDB;1
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.1"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.1 -- $ MONITOR [D]LOCK
</font>
</h3>

<p>
  The DCL commands MONITOR [D]LOCK/INTERVAL=1 provide a dynamic overview of
  local and incoming/outgoing lock activity on the executor node.
  The number of locks and resources handled are essential information to
  determine appropriate values for the OpenVMS SYSGEN parameters LOCKIDTBL
  and RESHASHTBL, which have a recommended value of four times the number
  of resources handled across the cluster.
</p>

Output samples:<br>

<pre>
                            OpenVMS Monitor Utility
                           LOCK MANAGEMENT STATISTICS
                                 on node L15S50
                             7-APR-2016 16:42:09.75

                                       CUR        AVE        MIN        MAX

    New ENQ Rate                    283.66     570.33     159.00    1443.33
    Converted ENQ Rate              319.66     882.06     319.66    1697.00

    DEQ Rate                        237.66     351.93     103.00     994.33
    Blocking AST Rate                71.66     136.59      63.33     217.66

    ENQs Forced To Wait Rate         20.33      65.23      20.33     109.66
    ENQs Not Queued Rate             46.33     180.69      46.33     328.33

    Deadlock Search Rate              0.00       0.00       0.00       0.00
    Deadlock Find Rate                0.00       0.00       0.00       0.00

    Total Locks                 1215164.00 1214566.80 1213896.00 1215164.00
    Total Resources              737248.00  737249.00  737173.00  737287.00

                            OpenVMS Monitor Utility
                     DISTRIBUTED LOCK MANAGEMENT STATISTICS
                                 on node L15S50
                             7-APR-2016 16:41:15.55

                                       CUR        AVE        MIN        MAX

    New ENQ Rate       (Local)      120.00      91.26       5.33     273.33
                    (Incoming)      306.33     252.33     171.00     326.66
                    (Outgoing)      618.66     268.33      48.00     618.66
    Converted ENQ Rate (Local)      314.33     160.86      59.33     314.33
                    (Incoming)      490.66     373.53     169.00     490.66
                    (Outgoing)      797.33     357.00     167.33     797.33
    DEQ Rate           (Local)       91.00      79.26       5.00     256.66
                    (Incoming)      248.66     219.19      89.33     377.33
                    (Outgoing)      351.33     154.66      28.00     351.33
    Blocking AST Rate  (Local)       37.00      19.66       6.00      37.00
                    (Incoming)       44.66      31.26      11.66      44.66
                    (Outgoing)       97.33      75.86      31.33      97.33
    Dir Functn Rate (Incoming)       15.33      49.46      15.33      74.33
                    (Outgoing)       14.00      21.06       0.00      88.00
    Deadlock Message Rate             0.00       0.00       0.00       0.00
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.2"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.2 -- $ MASTERLOCK/DATABASE
</font>
</h3>

<p>
  As of CockpitMgr V7.9-019 the CockpitMgr DCL command MASTERLOCK/DATABASE={dbid} 
  lists the node where the database lock tree is mastered for a given database.
  The command also establishes two DCL symbols CPT$MASTERLOCK_FILE and
  CPT$MASTERLOCK_NODE. The {node} symbol can be used in DCL command files
  to determine the optimal node where to submit a job that accesses this
  database, and assure that (only) local locks are handled. The performance
  improvement impact of local versus remote locks in a cluster can be 
  very substantial.  
</p>

  Usage:<br>

<pre>
$ set command cpt$system:masterlock
$ masterlock/database=cptrdb_db_1
DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1 - Master on L15S29
$ show symbol cpt$masterlock*
  CPT$MASTERLOCK_FILE = "DISK$DATA_29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1"
  CPT$MASTERLOCK_NODE = "L15S29"
</pre>

<a href="#Chapter 1">To Top</a><br>

<p>
  The OpenVMS SYSGEN parameters LOCKDIRWT, LOCKRMWT and PE1 determine the 
  lock remaster behavior in a cluster. The LOCKDIRWT and (as of OpenVMS V8.3)
  LOCKRMWT values set a propability weight for the node to become a directory
  or master node, compared to other nodes. As of OpenVMS V5.2 the LOCKDIRWT
  parameter was overloaded with these two meanings. 
</p>

<a name="Chapter 58.3"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.3 -- LOCKDIRWT
</font>
</h3>

<p>
  LOCKDIRWT (Lock Directory Weight) sets the relative amount of lock directory
  work the node should perform.<br>

  At the very first lock request for a resource tree on a specific node, a 
  directory lookup is executed to determine the master node. This is
  basically a hashing of the resource name into a lock directory vector 
  that is build based on the LOCKDIRWT value of all nodes. 
  A node with a LOCKDIRWT value of 0, is not eligible to act as a directory
  node. The master node CSID (cluster system id) is stored in the resource 
  block RSB. The lock activity counters per resource tree are also stored
  in the resource block.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.4"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.4 -- LOCKRMWT
</font>
</h3>

<p>
  (Courtesy Keith Parris, HP Corp., 'The Lock Manager And Performance', presentation 
   at the OpenVMS Boot Camp, september 2011)
</p>

<pre>
  LOCKRMWT (Lock Remaster Weight) sets the relative priority of the node to
  master shared resource trees:

  .Value can be from 0 to 10
   0 means node never wants to be resource master
   10 means node always wants to be resource master
   Values between 1 and 9 indicate a relative bias toward being resource master

  .Default value is 5
  .Difference between values on different nodes influences remastering activity
  .Parameter is dynamic

  .If a node with LOCKRMWT of 0-9 receives a lock request from a node with a 
   LOCKRMWT of 10, the tree will be marked for remastering to the node with a 
   value of 10

  .If a node with LOCKRMWT of 0 receives a lock request from a node with any 
   higher value, the tree will be marked for remastering

  .If a node with LOCKRMWT of 1-9 receives a lock request from another node with
   LOCKRMWT of 1-9, it computes the difference

   Difference will be in the range of +8 to -8

   Calculation on this difference results in a bias based on relative 
   percentages of lock activity (not fixed rates)

  --------------------------------------
  Local Activity:   1000
                    Minimum activity to
                    trigger remastering:
  Local-Remote      Remote   Percent
  Weight Difference Activity Additional
  8                 3000     200%
  7                 2500     150%
  6                 2000     100%
  5                 1750     75%
  4                 1500     50%
  3                 1375     38%
  2                 1250     25%
  1                 1187     19%
  0                 1125     13%
  -1                1093     9%
  -2                1062     6%
  -3                1000     0%
  -4                875      -13%
  -5                812      -19%
  -6                750      -25%
  -7                625      -38%
  -8                500      -50%
  --------------------------------------

  .Examples:

  -If a node with LOCKRMWT of 9 receives a lock request from a node 
  with a value of 1 ((Local-Remote difference of +8), then the node with 
  a value of 1 must be generating at least 3 times as many (200% 
  more) lock requests for the resource tree to be marked for 
  remastering

  -If a node with LOCKRMWT of 1 receives a lock request from another 
  node with LOCKRMWT of 9 (Local-Remote difference of -8), then if 
  the node with LOCKRMWT of 9 is generating at least half (50%) as 
  many lock requests as the node with LOCKRMWT of 1 the resource 
  tree will be marked for remastering

  -All nodes have a default LOCKRMWT value of 5:
  A node will have to have at least 13% more lock requests than the 
  current resource master before lock tree will be marked for remastering
  This introduces some hysteresis, to prevent thrashing
  This algorithm automatically scales with increasing lock rates over time

  .Mixed Version Clusters:

  8.3 nodes must interact properly with pre-8.3 nodes

  In dealing with a pre-8.3 node, an 8.3 node must 
  basically follow the old rules regarding LOCKDIRWT:

  -An 8.3 node will remaster a lock tree to a pre V8.3 node if the 
  pre-8.3 node has a higher LOCKDIRWT

  -If LOCKDIRWT values are equal, then when an 8.3 node 
  receives a lock request from a pre-8.3 node, the new computed 
  activity threshold is used on the 8.3 node for the remastering 
  decision

  -There are some cases that require special rules:

  Endless Remastering ?

   ---> Node A V8.3  --->  Node B V8.3
   |    LOCKDIRWT: 2       LOCKDIRWT: 0
   |    LOCKRMWT:  0       LOCKRMWT: 10
   |                       <Resource>
   |                       |
   |                       |
   ---  Node C V7.3-2 <--- | <== ** Do not remaster **
        LOCKDIRWT: 1

  Never remaster to a pre-8.3 node if an interested node has a higher LOCKDIRWT
</pre>

<p>
  (End courtesy Keith Parris)
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.5"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.5 -- PE1
</font>
</h3>

<p>
  The PE1 value sets the maximum size of a lock tree that can be remastered. 
  A PE1 value of -1 effectively disables lock remastering away from the node
  but does not prevent remastering to the node.
  If lock remastering is disabled (on all nodes), assure that the very first
  RMU/Open of a database in the cluster is executed on the node where you want
  the database master lock tree to reside.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.6"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.6 -- DEADLOCK_WAIT
</font>
</h3>

<p>
  DEADLOCK_WAIT defines the number of seconds that a lock request
  must wait before the system initiates a deadlock search on behalf
  of that lock. Setting DEADLOCK_WAIT to zero disables deadlock
  checking. Setting DEADLOCK_WAIT to a value greater than zero
  and less than the default setting provides faster detection of
  deadlocks but requires more CPU usage.<br>

  On today's modern Itanium systems, the SYSGEN default DEADLOCK_WAIT value
  of 10 seconds is no longer appropriate and the minimum value of 1 is 
  recommended. On a per process basis, a DEADLOCK_WAIT value smaller
  than 1 second can be set via a programmatic interface using the system
  service $SET_PROCESS_PROPERTIESW and the property code PPROP$C_DEADLOCK_WAIT
  in 100 nano seconds units.
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.7"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.7 -- RDMS$BIND_DEADLOCK_WAIT
</font>
</h3>

As of Rdb V7.3-200:<br>

<pre>
  OpenVMS allows the system manager to establish a DEADLOCK_WAIT by
  setting this system parameter as small as 1 second. OpenVMS will
  establish a default value of 10 seconds. More recent releases
  of OpenVMS allow applications to establish a process specific
  DEADLOCK_WAIT smaller than 1 second using the system service
  SYS$SET_PROCESS_PROPERTIESW.

  This release of Oracle Rdb provides an interface to this system
  service for Rdb applications that wish to make use of sub-second
  DEADLOCK_WAIT times. The logical name RDMS$BIND_DEADLOCK_WAIT can
  be defined to a numeric value that specifies the deadlock wait
  time in 100 nanosecond units. The smallest value is 100000 (which
  is 10 milliseconds) and the largest value is 10000000 (which is 1
  second). If the value specified for the logical name is outside
  this range it will be ignored and the application will default to
  the setting of the system parameter DEADLOCK_WAIT.

  This logical name can be defined as a process, group, job or
  system wide logical name. Rdb only translates this logical name
  on the first database connection. Any effects of this logical
  name are removed when the image which attached to the database
  exits.

  Please note that the smaller the deadlock wait setting the more
  often the OpenVMS lock manager will initiate a deadlock search.
  The use of the logical name for Rdb is only recommended for
  high-end transaction processing systems which have the database
  load and sufficiently powerful CPU systems to require such fine
  tuning.
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 58.8"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 58.8 -- Rdb Database Lock Resource Name
</font>
</h3>

  The Rdb database lock resource name is constructed as follows.<br>

<pre>
Consider:
  
Database root file:

Directory DISK$DATA_29:[CPTRDB_DB_1]
CPTRDB_DB_1.RDB;1             File ID:  (1022,212,0)
  
$ Rmu/Show locks/resource_type=database <dbroot>

--------------------------------------------------------------------------------
Resource Name: local database (00DD) .DATA_29     .þ.Ô.....
Granted Lock Count: 8,     Parent Lock Count: 2,
Number of Sub-Resources: 3,         Lock Access Mode: Executive,
Resource Type: Global,     Lock Value Block: 0

          -Master Node Info-  --Lock Mode Information--     -Remote Node Info-
ProcessID Lock ID   SystemID  Requested Granted   Queue     Lock ID   SystemID
2DE00ACF  0501C4BB  0001006F            NL        GRANT     0501C4BB  0001006F
...
--------------------------------------------------------------------------------

$ Analyze/System
SDA> show cluster

Address   Node    CSID      ExpVotes Votes   State     Status
-------   ----    ----      -------- -----   -----     ------
88574040  L15S28  0001006E      3      1     open    member,qf_noaccess
8820A740  L15S29  0001006F      3      1     local   member,qf_same,qf_noaccess
88590040  L15S27  00010058      3      1     open    member,qf_noaccess

$ Analyze/System
SDA> show lock [{Lock ID}|0501C4BB]

Lock Database
-------------

Lock id:  0501C4BB            PID:    000202CF   Flags: NOQUEUE SYNCSTS SYSTEM
Par. id:  00000000            SUBLCKs: 0
LKB:      FFFFFFFF.78600080   BLKAST: 00000000
Priority:     0000

Granted at    NL   00000000-FFFFFFFF

RSB:               FFFFFFFF.73035AC0
Resource:          00000044 000000DD  Ý...D...  Status: VALBLKR VALBLKW
 Length   30       39325F41 54414402  .DATA_29
 Exec. mode        03FE0020 20202020       .þ.
 System            00000001 000000D4  Ô.......

Local copy

$ WRITE SYS$OUTPUT F$GETDVI("DISK$DATA_29","DEVLOCKNAM")

000000202020202039325F4154414402
00000020 20202020 39325F41 54414402

The resource name is composed of:

====
Longword 000000DD Constant

Longword 00000044 Local or cluster database
      or 00000069

Next 14 bytes of item DVI$_DEVLOCKNAM of SYS$GETDVI
         54414402
         39325F41
         20202020
             0020

Next 6 bytes FILID of root file
From FIDDEF in SYS$SHARE:SYS$STARLET_C.TLB

             03FE unsigned short int fid$w_num; 1022
             00D4 unsigned short int fid$w_seq;  212
             0000 unsigned short int fid$w_rvn;    0

             0001 ??? (length 30)
             0000 filler
====
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 59"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 59 -- Apply Complex Logic To Generate SQL Or Data
</font>
</h3>

<b>CPTRDB_LIST_ALL.COM</b><br>
<b>CPTRDB_CLIO_CLNTS_LIST_ALL.COM</b><br>
<b>CPTRDB_INS_UPD_DEL_GEN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
The procedures in this chapter are templates to illustrate the use of the sql
TRACE command to unload data into (multiple) output files, or generate sql 
statements, and apply complex logic that cannot be expressed in a single view 
or sql statement.<br>

Generate and execute dummy sql update statements is also a great way to
resend data across the JCC Logminer Loader, that correspond to complex
conditions, and boils down to a private data pump function. 
</p>

<p>
<b>CPTRDB_LIST_ALL.COM</b><br>
  Unload rows from a table applying complex selection criteria
  and allow multiple output files, using sql TRACE.
</p>
  
<p>
  This template procedure unloads the RDB$RELATIONS table and
  allows to create two seperate lists for system and user tables, using a
  prefix and the SEARCH command. The output file has a loadable format
  and a minimal data volume, can be sorted still listing the column names
  upfront, and provides two formats for vms dates.
</p>

<p>
  The tracing of the LIST OF BYTE VARYING columns dbkeys is incorrect.
</p>

  Output sample:<br>

<pre>
 00 [**USER\**SYSTEM]#
 01 rdb$relation_name#
 02 rdb$type_id#
 03 rdb$relation_id#
 04 rdb$storage_id#
 05 rdb$system_flag#
 06 rdb$dbkey_length#
 07 rdb$max_version#
 08 rdb$cardinality#
 09 rdb$flags#
 10 rdb$view_blr#
 11 rdb$description#
 12 rdb$view_source#
 13 rdb$access_control#
 14 rdb$extension_parameters#
 15 rdb$cdd_name#
 16 rdbvms$security_audit#
 17 rdbvms$security_alarm#
 18 rdb$security_class#
 19 rdbvms$security_audit2#
 20 rdbvms$security_alarm2#
 21 rdb$created#
 22 rdb$last_altered#
 23 rdb$row_cluster_factor#
 24 rdb$relation_creator#
**SYSTEM|DBA_MVIEWS|0|146|12|1|8|1|0|131072|NULL|NULL|NULL|0:65536:156|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|DUAL|0|132|0|1|8|1|0|132608|NULL|NULL|NULL|0:65536:26|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**USER|ENCRYPT_TABLE|0|939|31|0|8|1|1|0|NULL|NULL|NULL|0:65536:117|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2015-06-24 12:45:51.09|2015-06-24 12:45:51.09|0.0000000|RDBMON#
**SYSTEM|GLOBAL_NAME|0|136|0|1|8|1|0|132608|NULL|NULL|NULL|0:65536:27|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**USER|JCCLML$HEARTBEAT|0|45|65|0|8|1|1|0|NULL|NULL|NULL|0:0:594|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-08 16:57:05.01|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**USER|LISTTAB|0|44|0|0|8|1|3|0|NULL|NULL|NULL|0:65536:591|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:50:41.35|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|ORA_COMM_TRANS|0|148|14|1|8|1|0|131072|NULL|NULL|NULL|0:0:220|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|ORA_DBMS_OUTPUT|0|157|0|1|8|1|0|132608|NULL|NULL|NULL|0:65536:1359|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|ORA_OBJECTS|0|131|3|1|8|1|233|131072|NULL|NULL|NULL|0:0:0|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|ORA_SESSION|0|133|0|1|8|1|0|132608|NULL|NULL|NULL|0:65536:26|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|ORA_VALID_PROGRAMS|0|149|16|1|8|1|0|131072|NULL|NULL|NULL|0:0:221|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|PRODUCT_PROFILE|0|152|19|1|8|1|0|131072|NULL|NULL|NULL|0:65536:1319|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|PSTUBTBL|0|137|0|1|8|1|0|132608|NULL|NULL|NULL|0:65536:27|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2014-04-29 16:04:37.14|2014-04-29 16:04:37.14|0.0000000|RDBMON#
**SYSTEM|RDB$CACHES|0|32|0|1|8|1|0|16386|NULL|NULL|NULL|0:65536:211|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.60|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$CHARACTER_SETS|0|39|0|1|8|1|0|16386|NULL|NULL|NULL|0:65536:211|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.60|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$COLLATIONS|0|16|95|1|8|1|0|10|NULL|NULL|NULL|0:65536:206|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.22|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$CONSTRAINTS|0|8|89|1|8|1|14|10|NULL|NULL|NULL|0:65536:206|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.22|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$CONSTRAINT_RELATIONS|0|9|90|1|8|1|19|10|NULL|NULL|NULL|0:65536:206|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.22|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$DATABASE|0|7|88|1|8|1|1|10|NULL|NULL|NULL|0:65536:206|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.22|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$DATABASE_JOURNAL|0|33|0|1|8|1|0|16386|NULL|NULL|NULL|0:65536:211|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.60|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$DATABASE_ROOT|0|34|0|1|8|1|0|16386|NULL|NULL|NULL|0:65536:211|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.60|2013-12-03 16:06:47.87|0.0000000|RDBMON#
**SYSTEM|RDB$DATABASE_USERS|0|35|0|1|8|1|0|16386|NULL|NULL|NULL|0:65536:211|NULL|NULL|0|0|RDB$SECURITY_CLASS|0|0|2013-10-04 15:34:25.60|2013-12-03 16:06:47.87|0.0000000|RDBMON#
......
</pre>

<p>
<b>CPTRDB_CLIO_CLNTS_LIST_ALL.COM</b><br>
  Unload the clio_clnts table and generate normalized first_name and
  last_name strings in a loadable format using the TRANSLATE function.
  All non letter characters are filtered out as well as a series
  of trash prefixes.
</p>

<p>
<b>CPTRDB_INS_UPD_DEL_GEN.COM</b><br>
  Generate a DCL/SQL procedure to execute a INSERT or UPDATE or DELETE
  statement according to specific conditions.
</p>
  
<p>
  This template procedure creates a INSERT or UPDATE or DELETE statement on
  the test database, if the first integer column is a multiple
  of 11 or 13 or 17 . The insert is done into a scratch table
  named TABLE_TRACE created by this 'generate' procedure.
  Deleted rows are also recorded in this table.
  
  The generated procedure can be executed right away with no modifications
  required. All updates are traced in the final run logfile.

  The commit step can be easily modified to assure proper performance.
</p>

  The two generated procedures in CPT$RDB: are named<br>

<pre>
GEN456_INS_UPD_DEL_{dbid}.COM[_ddmmmhhmmss]
</pre>

  To run use:<br>

<pre>
$ @CPTRDB_SUBMIT {node} GEN456_INS_UPD_DEL_{dbid}

The char(7) prefix 'GEN456_' is stripped from the logfile name.

Enjoy the single quotes.
</pre>

  Generated procedure sample:<br>

<pre>
$ set nover
$!
$ set proc/priv=all
$ set proc/prio=4
$ set proc/parse_style=traditional
$ set output_rate=00:00:05
$!
$ say := write sys$output
$!
$ set proc/name="CPTRDB RUN"
$ show process
$ say " "
$!
$ @sys$share:rdb$setver 7.3
$ say " "
$!
$ define sql$database -
  DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1
$ sql := $sql$
$ sql

set flags 'trace, noprefix'

set transaction read write;

-- 1
insert into table_trace values (
297,
'azertyuiop',
-297,
'INS');
begin
trace '**INS', ',', '297',          ',', 'azertyuiop', ',', '-297',         '#';
end;
-- 2
update table_parti set
col2 = 'qsdfghjklm',
col3 = 9999
where col1 = 299;
begin
trace '**UPD', ',', '299',          ',', 'qsdfghjklm', ',', '9999',         ',', 'qsdfghjklm', ',', '9999',         '#';
end;
-- 3
insert into table_trace values (
319,
'azertyuiop',
-319,
'INS');
begin
trace '**INS', ',', '319',          ',', 'azertyuiop', ',', '-319',         '#';
end;
-- 4
update table_parti set
col2 = 'qsdfghjklm',
col3 = 9999
where col1 = 325;
begin
trace '**UPD', ',', '325',          ',', 'qsdfghjklm', ',', '9999',         ',', 'qsdfghjklm', ',', '9999',         '#';
end;
-- 5
insert into table_trace values (
341,
'azertyuiop',
-341,
'INS');
begin
trace '**INS', ',', '341',          ',', 'azertyuiop', ',', '-341',         '#';
end;
commit;
set transaction read write;
-- 6
update table_parti set
col2 = 'qsdfghjklm',
col3 = 9999
where col1 = 351;
begin
trace '**UPD', ',', '351',          ',', 'qsdfghjklm', ',', '9999',         ',', 'qsdfghjklm', ',', '9999',         '#';
end;

...

-- 54
insert into table_trace values (
979,
'azertyuiop',
-979,
'INS');
begin
trace '**INS', ',', '979',          ',', 'azertyuiop', ',', '-979',         '#';
end;
commit;

$ set nover
$ exit
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 60"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 60 -- Basic SQL Functionality From A External Procedure Or Subprogram
</font>
</h3>

<b>CPTRDB_EXTERN_PROC_SQLMOD.SQLMOD</b><br>
<b>CPTRDB_EXTERN_PROC_C.C</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN.C</b><br><br>

<b>CPTRDB_EXTERN_PROC_BUILD.COM</b><br><br>

<b>CPTRDB_EXTERN_PROC_SQLMOD.OBJ</b><br>
<b>CPTRDB_EXTERN_PROC_C.H</b><br>
<b>CPTRDB_EXTERN_PROC_C.OBJ</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN.OBJ</b><br><br>

<b>CPTRDB_EXTERN_PROC_MAIN.EXE</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN_RUN.COM</b><br><br>

<b>CPTRDB_EXTERN_PROC_SHR.EXE</b><br>
<b>CPTRDB_EXTERN_PROC_SQL.COM</b><br>
<b>CPTRDB_EXTERN_PROC_SQL_RUN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
These template source files provide basic sql functionality from a external
procedure or subprogram using the TABLE_PARTI table of database CPTRDB_DB_1.
The returned sql code and message are displayed. In case of SELECT the
selected columns are listed. The procedures assume column COL1 to be unique.
Transactions are handled within the procedure. All parameters are passed
as strings and casted to the appropriate datatype within the queries.
</p>

<p>
<b>CPTRDB_EXTERN_PROC_SQLMOD.SQLMOD</b><br>
<b>CPTRDB_EXTERN_PROC_C.C</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN.C</b><br>
Source files
</p>

<p>
<b>CPTRDB_EXTERN_PROC_BUILD.COM</b><br>
Build file
</p>

<p>
<b>CPTRDB_EXTERN_PROC_SQLMOD.OBJ</b><br>
<b>CPTRDB_EXTERN_PROC_C.H</b><br>
<b>CPTRDB_EXTERN_PROC_C.OBJ</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN.OBJ</b><br>
Object and C prototypes files
</p>

<p>
<b>CPTRDB_EXTERN_PROC_MAIN.EXE</b><br>
<b>CPTRDB_EXTERN_PROC_MAIN_RUN.COM</b><br>
Main program image and run files
</p>

  Usage:<br>

<pre>
$ @CPTRDB_EXTERN_PROC_MAIN_RUN [INSERT|SELECT|UPDATE|DELETE] {col1} [{col2}|{col3}]
</pre>

<p>
<b>CPTRDB_EXTERN_PROC_SHR.EXE</b><br>
<b>CPTRDB_EXTERN_PROC_SQL.COM</b><br>
<b>CPTRDB_EXTERN_PROC_SQL_RUN.COM</b><br>
External procedure shareable image, sql create procedure and run files
</p>

  Usage:<br>

<pre>
$ @CPTRDB_EXTERN_PROC_SQL_RUN [INSERT|SELECT|UPDATE|DELETE] {col1} [{col2}|{col3}]
</pre>

Output sample:<br>

<pre>
$ @CPTRDB_EXTERN_PROC_SQL_RUN insert 101 bimbam -101
0
%SYSTEM-S-NORMAL, normal successful completion

$ @CPTRDB_EXTERN_PROC_SQL_RUN select 101
0
%SYSTEM-S-NORMAL, normal successful completion
SELECTED: 101          BIMBAM     -101

$ @CPTRDB_EXTERN_PROC_SQL_RUN update 101 boem -901
0
%SYSTEM-S-NORMAL, normal successful completion

$ @CPTRDB_EXTERN_PROC_SQL_RUN select 101
0
%SYSTEM-S-NORMAL, normal successful completion
SELECTED: 101          BOEM       -901

$ @CPTRDB_EXTERN_PROC_SQL_RUN insert 101 bimbam -101
-1001
%RDB-E-INTEG_FAIL, violation of constraint TABLE_PARTI_PK caused operation to
fail..-RDB-F-ON_DB, on database DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1

$ @CPTRDB_EXTERN_PROC_SQL_RUN delete 101
0
%SYSTEM-S-NORMAL, normal successful completion

$ @CPTRDB_EXTERN_PROC_SQL_RUN delete 101
100
%RDB-E-STREAM_EOF, attempt to fetch past end of record stream
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 61"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 61 -- Bulk Delete From A C Program
</font>
</h3>

<b>CPTRDB_BULK_DELETE_GO.COM</b><br>
<b>CPTRDB_BULK_DELETE.COM</b><br><br>

<b>CPTRDB_BULK_DELETE_SQLMOD.SQLMOD</b><br>
<b>CPTRDB_BULK_DELETE_C.H</b><br>
<b>CPTRDB_BULK_DELETE_SUB_C.C</b><br>
<b>CPTRDB_BULK_DELETE_C.C</b><br>
<b>CPTRDB_BULK_DELETE_BUILD.COM</b><br><br>

<b>CPTRDB_BULK_DELETE_SQLMOD.OBJ</b><br>
<b>CPTRDB_BULK_DELETE_SUB_C.OBJ</b><br>
<b>CPTRDB_BULK_DELETE_C.OBJ</b><br>
<b>CPTRDB_BULK_DELETE_C.EXE</b><br><br>

<b>CPTRDB_BULK_DELETE_SQL.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
These template procedures provide a framework to develop a purge of big
volumes of data from the database in a rapid, efficient, manageable,
controlable and safe way. The code can be run in simulation mode, 
with no actual deletes and trace the candidate rows data. 
To adapt to another environment, only table/column names and selection logic 
have to be modified.
</p>

<p>
<b>CPTRDB_BULK_DELETE_GO.COM</b><br>
  Calls CPTRDB_BULK_DELETE.COM<br>
  Interactive submit CPTRDB_BULK_DELETE.COM in batch with all required
  hardcoded parameters.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_BULK_DELETE_GO.COM
</pre>

<p>
<b>CPTRDB_BULK_DELETE.COM</b><br>
  Purge tables table_parti and table_place of database cptrdb_db_1
  for table_parti col1 values between two integers.
  Write candidate keys in a first phase to a intermediate todo file.
  Trace the candidate rows data.<br>
  
  Runs CPT$RDB:CPTRDB_BULK_DELETE_C.EXE<br>
  
  Called from CPT$RDB:CPTRDB_BULK_DELETE_GO.COM
</p>
  
  Parameters:<br>

<pre>
P1, from_col1,    integer,   min col1 value of table_parti
P2, to_col1,      integer,   max col1 value of table_parti
P3, indic_simul,  char(1),   Y/N, run without delete
P4, indic_trace,  char(1),   Y/N, trace candidate/deleted rows
P5, max_rows,     integer,   max number of table_parti rows to be deleted
P6, display_step, integer,   display timestamp every n business transactions
P7, dummy,        date ansi, dummy parameter to test check_date_ansi()
</pre>
  
<p>
  System, exec mode logical CPTRDB_BULK_DELETE_RUN must be defined
  as "YES" to start and continue to run. Checked on each iteration.
  A runtime change of the logical provides a clean stop of the procedure
  delete phase.
</p>
  
  Creates two files in CPT$RDB_DATA:<br>

<pre>
BULK_DELETE_{dbid}_{node}_yyyymmdd.TODO_ddmmmhhmmss
BULK_DELETE_{dbid}_{node}_yyyymmdd.UNL_ddmmmhhmmss
</pre>

<p>
  Can be rescheduled at any interval.<br>

  The unused parameter P7 illustrates the handling of a date ansi parameter. 
</p>

<p>
<b>CPTRDB_BULK_DELETE_SQLMOD.SQLMOD</b><br>
  Sqlmod source containing all database access.
</p>

<p>
<b>CPTRDB_BULK_DELETE_C.H</b><br>
  Generated C prototypes source for all procedures in
  CPTRDB_BULK_DELETE_SQLMOD.SQLMOD 
</p>

<p>
<b>CPTRDB_BULK_DELETE_SUB_C.C</b><br>
  Subprogram C source containing all actual deletes grouped per business
  transaction. Deadlock and lock conflict conditions are rolledback/ignored
  and returned as ok. 
</p>

<p>
<b>CPTRDB_BULK_DELETE_C.C</b><br>
  Main program C source. All parameters and the runtime required logical
  are checked for their validity. 
</p>

<p>
<b>CPTRDB_BULK_DELETE_BUILD.COM</b><br>
  Application compile and link file. The C sources are pure C and can be
  compiled on another system with Rdb installed, together with the C 
  prototypes file.
</p>

<p>
<b>CPTRDB_BULK_DELETE_SQLMOD.OBJ</b><br>
<b>CPTRDB_BULK_DELETE_SUB_C.OBJ</b><br>
<b>CPTRDB_BULK_DELETE_C.OBJ</b><br>
  Itanium format object files of the SQLMOD and C sources.
</p>

<p>
<b>CPTRDB_BULK_DELETE_C.EXE</b><br>
  Itanium format image file of the application.
</p>

<p>
Output sample:
</p>

<pre>
Purge TABLE_PARTI/TABLE_PLACE
-----------------------------

On node: LOCAL:.L15S29                                               
At     :  7-JUL-2016 15:44:06.50

For Database: 
DSA29:[CPTRDB_DB_1]CPTRDB_DB_1.RDB;1                                            

P1, From COL1:        300
P2, To COL1:          399
P3, Indic simulation: N
P4, Indic trace:      Y
P5, Max rows:         38
P6, Display step:     5
P7, Dummy date ansi:  2015-02-28

At  7-JUL-2016 15:44:06.97
Number of candidate TABLE_PARTI rows to be deleted: 38
Number of range     TABLE_PARTI rows to be deleted: 46

 7-JUL-2016 15:44:07.09 Deleted: 5
 7-JUL-2016 15:44:07.11 Deleted: 10
 7-JUL-2016 15:44:07.11 Deleted: 15
 7-JUL-2016 15:44:07.12 Deleted: 20
 7-JUL-2016 15:44:07.15 Deleted: 25
 7-JUL-2016 15:44:07.15 Deleted: 30
 7-JUL-2016 15:44:07.16 Deleted: 35

 7-JUL-2016 15:44:07.21 Total Deleted: 38
 7-JUL-2016 15:44:07.21 Stop on max rows reached

Todo File:
CPT$RDB_DATA:BULK_DELETE_CPTRDB_DB_1_L15S29_20160707.TODO_07JUL154406
Trace File:
CPT$RDB_DATA:BULK_DELETE_CPTRDB_DB_1_L15S29_20160707.UNL_07JUL154406
 
Candidate count: 38         
Range count:     46         
Delete count:    38         
 
--  7-JUL-2016 15:44:07.24 Submit for next day --
 
Job CPTRDB_BULK_DELETE (queue CPT$RDB_BATCH_L15S29, entry 376) holding until  8-JUL-2016 05:00
Logfile CPT$RDB_LOGS:BULK_DELETE_CPTRDB_DB_1_L15S29_20160708.LOG_08JUL050000
</pre>

<p>
<b>CPTRDB_BULK_DELETE_SQL.COM</b><br>
  Functional equivalent, straightforward, fire and forget, bulk delete 
  using a hold cursor. This template procedure can easily be adapted for 
  any table and selection.
</p>

<p>
Using RMU/UNLOAD/DELETE of a appropriate view, with suitable transaction
type and commit step is also an alternative. 
</p>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 62"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 62 -- Using Dynamic SQL
</font>
</h3>

<b>CPTRDB_SQL_DYNAMIC_BUILD.COM</b><br><br>

<b>CPTRDB_SQL_DYNAMIC_SQLMOD.OBJ</b><br>
<b>CPTRDB_SQL_DYNAMIC_SQLMOD.SQLMOD</b><br><br>

<b>CPTRDB_SQL_DYNAMIC_C.C</b><br>
<b>CPTRDB_SQL_DYNAMIC_C.H</b><br>
<b>CPTRDB_SQL_DYNAMIC_C.OBJ</b><br><br>

<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.C</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.EXE</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.OBJ</b><br><br>

<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.C</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.EXE</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.OBJ</b><br>

<p>
This chapter provides a build and run environment for the SQL_DYNAMIC*.* 
example code in the SQL$SAMPLE: directory (Rdb V7.3).
</p>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_SQL_DYNAMIC_BUILD.COM</b><br>
  Build file for<br>
  CPTRDB_SQL_DYNAMIC_DRIVER_I.EXE<br>
  CPTRDB_SQL_DYNAMIC_DRIVER_M.EXE
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_SQLMOD.SQLMOD</b><br>
  Copy of SQL$SAMPLE:SQL_DYNAMIC_C.SQLMOD
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_C.H</b><br>
  Generated C prototypes file for CPTRDB_SQL_DYNAMIC_SQLMOD.SQLMOD 
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_C.C</b><br>
  Copy of SQL$SAMPLE:SQL_DYNAMIC.C
</p>

<p>
  Contains the central routine<br> 
  int sql_dynamic (psql_stmt, input_sqlda, output_sqlda, stmt_id, is_select)
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.C</b><br>
  Copy of SQL$SAMPLE:SQL_DYNAMIC_DRIVER_I.C
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.C</b><br>
  Copy of SQL$SAMPLE:SQL_DYNAMIC_DRIVER_M.C<br>
  The SQL statements are adapted to TABLE_PARTI of database CPTRDB_DB_1.
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_SQLMOD.OBJ</b><br>
<b>CPTRDB_SQL_DYNAMIC_C.OBJ</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.OBJ</b><br>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.OBJ</b><br>
  Object files
</p>

<p>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_I.EXE</b><br>
  Image file
</p>

Run output sample (blank lines removed):<br>

<pre>
$ @cptrdb_attach cptrdb_db_1
Default transaction is read only
SQL$DATABASE is CPTRDB_DB_1

$ run CPTRDB_SQL_DYNAMIC_DRIVER_I.EXE
This program processes valid SQL statements using Dynamic SQL.
Enter the SQL statement to process, terminating your
statement with a semicolon {;} {{Enter} or {Ctrl/Z} to exit}:
DynamicSQL>

DynamicSQL> select * from table parti where col1 = ?;
The SQL statement to be executed dynamically is:
 select * from table parti where col1 = ?;
DSQL-E-PREPARE, Error -1041 encountered in PREPARE
Error message:
%SQL-F-RELNOTDEF, Table TABLE is not defined in database or schema
Error returned from sql_dynamic()

DynamicSQL> select * from table_parti where col1 = ?;
The SQL statement to be executed dynamically is:
 select * from table_parti where col1 = ?;
** There are 3 output parameters
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: 1
No records found.

DynamicSQL> insert into table_parti values (?, ?, ?);
The SQL statement to be executed dynamically is:
 insert into table_parti values (?, ?, ?);
** There are 3 input parameters
Enter value for parameter: COL1
 Integer: 1
Enter value for parameter: COL2
(Maximum length is 10)qsdfghjklm
Enter value for parameter: COL3
 Integer: -1

DynamicSQL> commit;
The SQL statement to be executed dynamically is:
 commit;

DynamicSQL> select * from table_parti where col1 = ?;
The SQL statement to be executed dynamically is:
 select * from table_parti where col1 = ?;
** There are 3 output parameters
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: 1
----------------------------------------
Field COL1: 1
Field COL2: qsdfghjklm
Field COL3: -1
No more records found.

DynamicSQL> update table_parti set col2 = ?, col3 = ? where col1 = ?;
The SQL statement to be executed dynamically is:
 update table_parti set col2 = ?, col3 = ? where col1 = ?;
** There are 3 input parameters
Enter value for parameter: COL2
(Maximum length is 10)azertyuiop
Enter value for parameter: COL3
 Integer: -99
Enter value for parameter: COL1
 Integer: 1

DynamicSQL> commit;
The SQL statement to be executed dynamically is:
 commit;

DynamicSQL> select * from table_parti where col1 = ?;
The SQL statement to be executed dynamically is:
 select * from table_parti where col1 = ?;
** There are 3 output parameters
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: 1
----------------------------------------
Field COL1: 1
Field COL2: azertyuiop
Field COL3: -99

DynamicSQL> delete from table_parti where col1 = ?;
The SQL statement to be executed dynamically is:
 delete from table_parti where col1 = ?;
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: 1

DynamicSQL> select * from table_parti where col1 = ?;
The SQL statement to be executed dynamically is:
 select * from table_parti where col1 = ?;
** There are 3 output parameters
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: 1
No records found.
</pre>

<p>
<b>CPTRDB_SQL_DYNAMIC_DRIVER_M.EXE</b><br>
  Image file
</p>

Run output sample (blank lines removed):<br>

<pre>
$ @cptrdb_attach cptrdb_db_1
Default transaction is read only
SQL$DATABASE is CPTRDB_DB_1

$ run CPTRDB_SQL_DYNAMIC_DRIVER_M.EXE

Program running to demonstrate multiply prepared SQL statements
------------------------------------------------------------------
* Executing INSERT...{CTRL/C} to exit
insert into table_parti (col1, col2, col3) values (?,?,?)** There are 3 input
parameters
Enter value for parameter: COL1
 Integer: -1
Enter value for parameter: COL2
(Maximum length is 10)aaaaa
Enter value for parameter: COL3
 Integer: 1
------------------------------------------------------------------
* Executing SELECT...{CTRL/C} to exit
select col1, col2, col3 from table_parti where col1 = ?** There are 3 output
parameters
** There is 1 input parameter
Enter value for parameter: COL1
 Integer: -1
----------------------------------------
Field COL1: -1
Field COL2: aaaaa
Field COL3: 1
No more records found.
------------------------------------------------------------------
* Executing UPDATE...{CTRL/C} to exit
update table_parti set col2 = ?, col3 = ? where col1 = ?** There are 3 input
parameters
Enter value for parameter: COL2
(Maximum length is 10)bbbbb
Enter value for parameter: COL3
 Integer: 11
Enter value for parameter: COL1
 Integer:-1
------------------------------------------------------------------
* Executing COMMIT...
------------------------------------------------------------------
* Re-executing INSERT...{CTRL/C} to exit
insert into table_parti (col1, col2, col3) values (?,?,?)
Enter value for parameter: COL1
 Integer:
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 63"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 63 -- Using Oracle Trace For Rdb
</font>
</h3>

<b>CPTRDB_EPC_DEMO.COM</b><br>
<b>CPTRDB_EPC_DEMO_SELECTION.OPT</b><br><br>

<b>CPTRDB_BLR_TO_SQL_CONVERT.COM</b><br>
<b>CPTRDB_BLR_TO_SQL_PARAMS.TXT</b><br>
<b>CPTRDB_EPC_BLR_CONVERTER.EXE</b><br>
<b>RDBX_GLOBALS.CUSTOM</b><br>
<b>RDBX_VMS_GLOBALS.INI</b><br><br>

<b>CPTRDB_BLR_TO_SQL_LIST.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_EPC_DEMO.COM</b><br>
  Proof of concept procedure for basic operations of Oracle Trace For Rdb,
  based on My Oracle Support Document Id 368373.1
</p>

<p>
  The procedure (re)creates the database EPC_DEMO_DB.RDB, the selection 
  EPC_DEMO_SELECTION, the collection EPC_DEMO_COLLECTION, the data file
  EPC_DEMO.DAT, and the formatted database EPC_DEMO_FORMAT_DB.RDB
</p>

  Usage:<br>

<pre>
$ @CPTRDB_EPC_DEMO
</pre>

  All output files are (re)created in CPT$RDB_DATA:<br>

<pre>
EPC_DEMO.DAT;1
EPC_DEMO_DB.RDB;1
EPC_DEMO_DB.SNP;1
EPC_DEMO_FORMAT_DB.RDB;1
EPC_DEMO_FORMAT_DB.SNP;1
</pre>

<p>
<b>CPTRDB_EPC_DEMO_SELECTION.OPT</b><br>
  Options file for the selection EPC_DEMO_SELECTION, (re)created in 
  CPTRDB_EPC_DEMO.COM
</p>

<p>
<b>CPTRDB_BLR_TO_SQL_CONVERT.COM</b><br>
  Standalone convert BLR source into SQL statements within a formatted database
  of Oracle Trace For Rdb.
</p>
  
  Based on EPC$EXAMPLES:EPC_BLR_TO_SQL_CONVERTER.COM<br>

<p>
  All required files are included in the toolset kit. The Oracle Trace For Rdb
  product does not need to be installed on the executor node. Only a
  formatted database is expected.
</p>
  
  Parameters: Adapt the formatted database name EPC$FORMAT_DB<br>

<pre>
$!---------------------------------------------------
$ define epc$format_db 'datdir'epc_demo_format_db.rdb
$!---------------------------------------------------
</pre>
  
<p>
  The conversion runtime parameters are documented in
  CPT$RDB:CPTRDB_BLR_TO_SQL_PARAMS.TXT
</p>

<p>
<b>CPTRDB_BLR_TO_SQL_PARAMS.TXT</b><br>
  Documents the runtime parameters of CPT$RDB:CPTRDB_EPC_BLR_CONVERTER.EXE
</p>

<p>
<b>RDBX_GLOBALS.CUSTOM</b><br>
<b>RDBX_VMS_GLOBALS.INI</b><br>
  Required parameter files to run CPT$RDB:CPTRDB_EPC_BLR_CONVERTER.EXE
</p>

<p>
  These two files do not adhere to the toolset naming standard of source
  files names starting with 'CPTRDB_' or 'JCCLML_'.
</p>

<p>
<b>CPTRDB_EPC_BLR_CONVERTER.EXE</b><br>
  Copy of EPC_BLR_CONVERTER.EXE from the Oracle Trace For Rdb kit.
</p>

<p>
<b>CPTRDB_BLR_TO_SQL_LIST.COM</b><br>
  List the SQL statements converted from their BLR source within a formatted
  database of Oracle Trace for Rdb.
</p>
  
<p>
  Split the SQL statements in max char(132) lines.<br>
  Remove the linefeed LF X'0A' characters from the SQL statements, due to the 
  edit string T(60) in the formatted database.
</p>
  
  Parameters: Adapt the formatted database name EPC$FORMAT_DB<br>

<pre>
$!---------------------------------------------------
$ define epc$format_db 'datdir'epc_demo_format_db.rdb
$!---------------------------------------------------
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_BLR_TO_SQL_LIST
</pre>

  Each output SQL statement is preceded by a header line containing:<br>

<pre>
sql_id
timestamp_start
node_name
username
process_name
image_name
</pre>

<p>
  The sql_id is repeated as prefix to each SQL statement line.
</p>

  Output sample:<br>

<pre>
  1|2016-03-11 14:30:48.89|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  1|SELECT C1.RDB$DBKEY_LENGTH, C1.RDB$RELATION_ID, C1.RDB$VIEW_BLR,  C1.RDB$SYSTEM_FLAG, C1.RDB$FLAGS FROM RDB$RELATIONS C1 WHERE (
  1|C1.RDB$RELATION_NAME = :PARAMETER)

  2|2016-03-11 14:30:48.89|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  2|BEGIN FOR :VARIABLE AS EACH ROW OF CURSOR CURS_01 FOR SELECT C1.RDB$FIELD_NAME, C1.RDB$FIELD_POSITION, C1.RDB$FIELD_ID,  C1.RDB$
  2|QUERY_HEADER, C1.RDB$EDIT_STRING, C1.RDB$QUERY_NAME,  C1.RDB$DEFAULT_VALUE FROM RDB$RELATION_FIELDS C1 WHERE (C1.RDB$RELATION_NA
  2|ME = :PARAMETER) ORDER BY C1.RDB$FIELD_POSITION ASC DO SELECT C1.RDB$FIELD_SOURCE, C1.RDB$FIELD_SOURCE FROM RDB$RELATION_FIELDS
  2|C1 WHERE CURRENT OF CURS_01; END FOR; END

  3|2016-03-11 14:30:48.90|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  3|SELECT C1.RDB$QUERY_HEADER, C1.RDB$EDIT_STRING, C1.RDB$FIELD_TYPE,  C1.RDB$FIELD_LENGTH, C1.RDB$FIELD_SCALE, C1.RDB$COMPUTED_BLR
  3|,  C1.RDB$SEGMENT_LENGTH, C1.RDB$FIELD_SUB_TYPE, C1.RDB$QUERY_NAME,  C1.RDB$DEFAULT_VALUE FROM RDB$FIELDS C1 WHERE (C1.RDB$FIELD
  3|_NAME = :PARAMETER)

  4|2016-03-11 14:30:48.90|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  4|SELECT C1.RDB$QUERY_HEADER, C1.RDB$EDIT_STRING, C1.RDB$FIELD_TYPE,  C1.RDB$FIELD_LENGTH, C1.RDB$FIELD_SCALE, C1.RDB$COMPUTED_BLR
  4|,  C1.RDB$SEGMENT_LENGTH, C1.RDB$FIELD_SUB_TYPE, C1.RDB$QUERY_NAME,  C1.RDB$DEFAULT_VALUE FROM RDB$FIELDS C1 WHERE (C1.RDB$FIELD
  4|_NAME = :PARAMETER)

  5|2016-03-11 14:30:48.90|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  5|SELECT C1.RDB$QUERY_HEADER, C1.RDB$EDIT_STRING, C1.RDB$FIELD_TYPE,  C1.RDB$FIELD_LENGTH, C1.RDB$FIELD_SCALE, C1.RDB$COMPUTED_BLR
  5|,  C1.RDB$SEGMENT_LENGTH, C1.RDB$FIELD_SUB_TYPE, C1.RDB$QUERY_NAME,  C1.RDB$DEFAULT_VALUE FROM RDB$FIELDS C1 WHERE (C1.RDB$FIELD
  5|_NAME = :PARAMETER)

  6|2016-03-11 14:30:48.91|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  6|INSERT INTO T (V1, V2, V3) VALUES (:PARAMETER, :PARAMETER, :PARAMETER)

  7|2016-03-11 14:30:48.92|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  7|INSERT INTO T (V1, V2, V3) VALUES (:PARAMETER, :PARAMETER, :PARAMETER)

  8|2016-03-11 14:30:48.93|L15S28|RDBMON|FTA274:|DSA1:[SYS0.SYSCOMMON.][SYSEXE]SQL$73.EXE
  8|SELECT C1.V1, C1.V2, C1.V3 FROM T C1 WHERE (C1.V1 <= :PARAMETER)
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 64"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 64 -- Miscellaneous Utilities
</font>
</h3>

<b>CPTRDB_COPY_FILES_NODES.COM</b><br><br>

<b>CPTRDB_FIND.COM</b><br>
<b>CPTRDB_FIND_CLUSTER.COM</b><br>
<b>CPTRDB_FIND_CLUSTER_BATCH.COM</b><br><br>

<b>CPTRDB_SALES_PER_MINUTE.COM</b><br><br>

<b>CPTRDB_SEARCH_STATUS_CODE.COM</b><br><br>

<b>CPTRDB_SHOW_CLUSTER_CR_WAIT.COM</b><br>
<b>CPTRDB_SHOW_CLUSTER_CR_WAIT.INI</b><br><br>

<b>CPTRDB_X11_KEEP_ALIVE_BATCH.COM</b><br>
<b>CPTRDB_X11_KEEP_ALIVE.COM</b><br>
<b>CPTRDB_X11_KEEP_ALIVE_ALL.COM</b><br><br>

<b>CPTRDB_CVT_FROM_HEX.COM</b><br>
<b>CPTRDB_CVT_FROM_HEX_BUILD.COM</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.C</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.EXE</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_BIGINT.OBJ</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_INT.C</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_INT.EXE</b><br>
<b>CPTRDB_CVT_FROM_HEX_SIGNED_INT.OBJ</b><br>
<b>CPTRDB_CVT_FROM_HEX_TIMESTAMP.C</b><br>
<b>CPTRDB_CVT_FROM_HEX_TIMESTAMP.EXE</b><br>
<b>CPTRDB_CVT_FROM_HEX_TIMESTAMP.OBJ</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.C</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.EXE</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_BIGINT.OBJ</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.C</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.EXE</b><br>
<b>CPTRDB_CVT_FROM_HEX_UNSIGNED_INT.OBJ</b><br><br>

<b>CPTRDB_CVT_TO_HEX.COM</b><br>
<b>CPTRDB_CVT_TO_HEX_BUILD.COM</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.C</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.EXE</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_BIGINT.OBJ</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_INT.C</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_INT.EXE</b><br>
<b>CPTRDB_CVT_TO_HEX_SIGNED_INT.OBJ</b><br>
<b>CPTRDB_CVT_TO_HEX_TIMESTAMP.C</b><br>
<b>CPTRDB_CVT_TO_HEX_TIMESTAMP.EXE</b><br>
<b>CPTRDB_CVT_TO_HEX_TIMESTAMP.OBJ</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.C</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.EXE</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.OBJ</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_INT.C</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_INT.EXE</b><br>
<b>CPTRDB_CVT_TO_HEX_UNSIGNED_INT.OBJ</b><br><br>

<b>CPTRDB_CALENDAR_GEN.COM</b><br>

<h4><font face="helvetica, arial, sans-serif" color="#330099">
Procedures Usage
</font>
</h4>

<p>
<b>CPTRDB_COPY_FILES_NODES.COM</b><br>
  Copy one or more files to some directory on a series of hardcoded remote 
  nodes.
</p>
  
<pre>
Parameters: P1, (wildcard) filename(s)
            P2, remote username, rdbmon
            P3, remote password, secret
</pre>

<p>
  This procedure can assist in the deployment of (some part of) the toolset on 
  other nodes.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_COPY_FILES_NODES {filespec} {username} {password}
</pre>

<p>
<b>CPTRDB_FIND.COM</b><br>
  Search for a string on the executor node.
  Creates no output file.
</p>

  Usage:<br>

<pre>
$ FIND :== @CPT$RDB:CPTRDB_FIND
$ FIND {string}
</pre>

<b>CPTRDB_FIND_CLUSTER.COM</b> (Calls per node)<br>
<b>CPTRDB_FIND_CLUSTER_BATCH.COM</b><br>

<p>
  Search for a string on a hardcoded list of (all) cluster nodes.
  Creates an output file in CPT$RDB_LISTS:
</p>

  Usage:<br>

<pre>
$ @CPTRDB_FIND_CLUSTER {string}
</pre>

<p>
<b>CPTRDB_SALES_PER_MINUTE.COM</b><br>
  List sales counts per minute in a .CSV file for a given time period, for
  three groups of sales types, with hardcoded parameters.
</p>
  
<pre>
Parameters, P1, timestamp1, timestamp, "2009-12-21 08:45:00"
            P2, timestamp2, timestamp, "2009-12-21 09:15:00"
            P3, sales date, date ansi,  2009-12-21"
</pre>

<p>
  This template code illustrates how to list three data items on a timeline in 
  a .CSV file, that can be used as input to a graphical representation tool.
</p>

<p>
  The individual sales type char(2) to sales group char(1) mapping is:
</p>

<pre>
case :t1.sls_item_id
  when '01' then 'T'
  when '02' then 'T'
  when '14' then 'T'
  when '05' then 'V'
  when '31' then 'V'
  when '32' then 'V'
  when '36' then 'V'
  when '71' then 'V'
  else 'O'
end,
</pre>

<p>
  Output sample:
</p>

<pre>
(Time period)
2016-07-11 09:00:00
2016-07-11 11:00:00
2016-07-11

(Counts per char(2) individual sales type)
09:00|01|  94
09:00|02|   3
09:00|05|   3
09:00|06|   1
09:00|40|   1
09:00|99|   2
09:00|L1|   1

09:01|01| 100
09:01|02|   9
09:01|05|   4
09:01|41|   2

09:02|01| 118
09:02|02|  21
09:02|05|   3
09:02|14|   1
09:02|31|   1
09:02|32|   1
09:02|41|   2
09:02|99|   4
...
(Counts sum per sales group T, V and O)
09:00|97|3|5
09:01|109|4|2
09:02|140|5|6
...
</pre>

<p>
<b>CPTRDB_SEARCH_STATUS_CODE.COM</b><br>
  Search for the translation of a $STATUS return status across all message files
  available on the executor node.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SEARCH_STATUS_CODE [integer|%Xnnnnnnnn]
</pre>

  Output sample:<br>

<pre>
$ @CPTRDB_SEARCH_STATUS_CODE %X12C89918
SYS$COMMON:[SYSMSG]RMUMSG72.EXE;11
%RMU-W-USERCORRUPT, This database has been corrupted by bypassing the recovery
process
SYS$COMMON:[SYSMSG]RMUMSG73.EXE;3
%RMU-W-USERCORRUPT, This database has been corrupted by bypassing the recovery
process
Total number of message files searched:    72
Total number of status translations found: 2
Output CPT$RDB_LISTS:STATUS_X12C89918_L15S29_20150730.LIS_30JUL151910
</pre>

<p>
<b>CPTRDB_SHOW_CLUSTER_CR_WAIT.COM</b><br>
<b>CPTRDB_SHOW_CLUSTER_CR_WAIT.INI</b><br>
  Continuous display cluster communication credit waits.
</p>

<pre>
Executes:
$ SHOW CLUSTER/CONTINUOUS/INTERVAL=1

For the items in CPTRDB_SHOW_CLUSTER_CR_WAIT.INI
add loc_proc
add cr_wait
set cr_wait/width=10
</pre>

  Usage:<br>

<pre>
$ @CPTRDB_SHOW_CLUSTER_CR_WAIT
</pre>

Output sample:<br>

<pre>
View of Cluster from system ID 12934  node: L15S50          10-JAN-2019 11:39:54
+-----------------------+---------+------------------+----------+
|        SYSTEMS        | MEMBERS |    CONNECTIONS   | COUNTERS |
+--------+--------------+---------+------------------+----------+
|  NODE  |   SOFTWARE   |  STATUS |   LOC_PROC_NAME  | CR_WAITS |
+--------+--------------+---------+------------------+----------+
| L15S50 | VMS V8.4     | MEMBER  | SCS$DIRECTORY    |          |
|        |              |         | MSCP$TAPE        |          |
|        |              |         | MSCP$DISK        |          |
|        |              |         | VMS$SDA_AXP      |          |
|        |              |         | VMS$VAXcluster   |          |
|        |              |         | SCA$TRANSPORT    |          |
| L15S53 | VMS V8.4     | MEMBER  | VMS$DISK_CL_DRVR |        0 |
|        |              |         | MSCP$DISK        |        0 |
|        |              |         | VMS$VAXcluster   |    11029 |
|        |              |         | SCA$TRANSPORT    |        7 |
| L15S52 | VMS V8.4     | MEMBER  | MSCP$DISK        |        0 |
|        |              |         | VMS$DISK_CL_DRVR |        0 |
|        |              |         | SCA$TRANSPORT    |        5 |
|        |              |         | VMS$VAXcluster   |     1262 |
| L15S59 | VMS V8.4     | MEMBER  | SCA$TRANSPORT    |     4753 |
|        |              |         | VMS$DISK_CL_DRVR |        0 |
|        |              |         | MSCP$DISK        |       36 |
|        |              |         | VMS$VAXcluster   |    63184 |
| L15S58 | VMS V8.4     | MEMBER  | SCA$TRANSPORT    |       57 |
|        |              |         | VMS$DISK_CL_DRVR |        0 |
|        |              |         | MSCP$DISK        |        0 |
|        |              |         | VMS$VAXcluster   |    20178 |
| L15S51 | VMS V8.4     | MEMBER  | SCA$TRANSPORT    |       85 |
|        |              |         | VMS$DISK_CL_DRVR |        0 |
|        |              |         | MSCP$DISK        |        0 |
|        |              |         | VMS$VAXcluster   |    60779 |
| L15S54 | VMS V8.4     | MEMBER  | SCA$TRANSPORT    |        0 |
|        |              |         | VMS$DISK_CL_DRVR |        0 |
|        |              |         | MSCP$DISK        |        0 |
|        |              |         | VMS$VAXcluster   |        0 |
+--------+--------------+---------+------------------+----------+
</pre>

<p>
<b>CPTRDB_X11_KEEP_ALIVE_BATCH.COM</b><br>
  Called from CPTRDB_X11_KEEP_ALIVE[_ALL].COM
</p>

<p>
  Send a reply to Rdb monitor users on one node, to prevent firewall timeout
  for eXcursion X11 terminal sessions.

  The default list of site specific users is
  (RDBMON,JDBCMON,SRVMON,JCCMON)
</p>

<p>
<b>CPTRDB_X11_KEEP_ALIVE.COM</b><br>
  Calls CPTRDB_X11_KEEP_ALIVE_BATCH.COM
</p>

<p>
  Interactive (test) send a reply to Rdb monitor users on a series of hardcoded 
  cluster nodes, to prevent firewall timeout for eXcursion X11 terminal 
  sessions.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_X11_KEEP_ALIVE
</pre>

<p>
<b>CPTRDB_X11_KEEP_ALIVE_ALL.COM</b><br>
  Calls CPTRDB_X11_KEEP_ALIVE_BATCH.COM
</p>

<p>
  Automated send of a reply to Rdb monitor users on a series of hardcoded 
  cluster nodes, to prevent firewall timeout for eXcursion X11 terminal 
  sessions, in a continuous way every 30 minutes.
</p>

  Usage:<br>

<pre>
$ @CPTRDB_SUBMIT {node} CPTRDB_X11_KEEP_ALIVE_ALL

Logfiles older than two hours are cleaned.
</pre>

  Output sample:<br>

<pre>
Reply received on L15S29 from user RDBMON at L15S29 Batch   15:42:12
30-JUL-2015 15:42:12.67 - X11 KEEP ALIVE
</pre>

<p>
<b>CPTRDB_CVT_TO_HEX.COM</b><br>
  Convert a varchar(2000) character, varchar(12) (un)signed integer,
  char(23) date vms timestamp or varchar(20) (un)signed bigint ascii string
  to a varchar(2000), char(8) or char(16) hexadecimal string.
</p>
  
<pre>
Parameters: P1, [CHAR|[UN]SIGNED_[BIG]INT|TIMESTAMP], input datatype
            P2, input string,
                CHAR varchar(2000), INT varchar(12), TIMESTAMP char(23),
                BIGINT varchar(20)
</pre>
  
<p>
  INT, TIMESTAMP and BIGINT output hexadecimal strings are left padded with 
  zero's upto char(8) or char(16).
</p>

<p>
  Calls CPTRDB_CVT_TO_HEX_[[UN]SIGNED_[BIG]INT|TIMESTAMP].EXE as foreign
  command for datatypes INT, TIMESTAMP and BIGINT.
</p>
  
<p>
  Leading and trailing spaces %X'20' are ignored for datatype CHAR, using
  the SQL function RAWTOHEX.
</p>
  
<p>
  Usage for datatype TIMESTAMP: do not embed the timestamp string in quotes.
</p>
  
<pre>
$ @CPTRDB_CVT_TO_HEX timestamp 21-APR-2017 15:47:08.00 ! No quotes
Char: 21-APR-2017 15:47:08.00
Hex:  00B19E3EFEEEA600
</pre>
  
<p>
  The use of the system service SYS$BINTIM implies that missing elements of
  the timestamp string default to the current date and time, and thus 
  yield varying hexadecimal strings.
</p>

<p>
  Due to the lack of support by LIB$CVT_DX_DX for a unsigned quadword
  descriptor, the CPTRDB_CVT_TO_HEX_UNSIGNED_BIGINT.C code is implmented using
  the C RTL routine STRTOUQ, which implies that the error handling is different
  from the standard OpenVMS RTL routines SYS$, LIB$ and OTS$ which are used
  in the other CPTRDB_CVT_[TO|FROM]_HEX*.C code snippets.<br>
  This code also exports the DCL symbol HEX_UNSIGNED_BIGINT.
</p>

<p>
<b>CPTRDB_CVT_FROM_HEX.COM</b><br>
  Convert a varchar(2000), char(8) or char(16) hexadecimal string to a
  varchar(2000) character, varchar(12) (un)signed integer, char(23)
  date vms timestamp or char(20) (un)signed bigint ascii string.
</p>
  
<pre>
Parameters: P1, [CHAR|[UN]SIGNED_[BIG]INT|TIMESTAMP], input datatype
            P2, input hexadecimal string,
                CHAR varchar(2000), INT char(8), TIMESTAMP char(16),
                BIGINT char(16)
</pre>
  
<p>
  INT, TIMESTAMP and BIGINT input hexadecimal strings are left padded with 
  zero's upto char(8) or char(16).
</p>
  
<p>
  Calls CPTRDB_CVT_FROM_HEX_[[UN]SIGNED_[BIG]INT|TIMESTAMP].EXE as foreign
  command for datatypes INT, TIMESTAMP and BIGINT.
</p>

<p>
  The datatype TIMESTAMP allows to interprete the filespecs of emergency live
  AIJ files, which contain a timestamp in hex.
</p>

<pre>
$!$ rmu/set after_journal /drop=(name=EMERGENCY_00B0E18B9B88BB0A) ACC_DB_B01S15
$!
$ @CPTRDB_CVT_FROM_HEX timestamp 00B0E18B9B88BB0A
Hex:  00B0E18B9B88BB0A
Char: 24-AUG-2016 12:29:22.72
</pre>

<p>
Usage:
</p>

<pre>
-- char --

$ @CPTRDB_CVT_TO_HEX char abc123
414243313233

$ @CPTRDB_CVT_FROM_HEX char 414243313233
ABC123

$ @CPTRDB_CVT_TO_HEX char "all bananas are sold out today"
616C6C2062616E616E61732061726520736F6C64206F757420746F646179

$ @CPTRDB_CVT_FROM_HEX char -
_$ 616C6C2062616E616E61732061726520736F6C64206F757420746F646179
all bananas are sold out today

-- signed_int --

$ @CPTRDB_CVT_TO_HEX signed_int 333
Char: 333
Int:  333
Hex:  0000014D

$ @CPTRDB_CVT_FROM_HEX signed_int 0000014D
Hex: 0000014D
Int: 333

$ @CPTRDB_CVT_FROM_HEX signed_int 14d
Hex: 0000014D
Int: 333

$ @CPTRDB_CVT_TO_HEX signed_int -333
Char: -333
Int:  -333
Hex:  FFFFFEB3

$ @CPTRDB_CVT_FROM_HEX signed_int FFFFFEB3
Hex: FFFFFEB3
Int: -333

$ @CPTRDB_CVT_FROM_HEX signed_int 7fffffff
Hex: 7FFFFFFF
Int: 2147483647

$ @CPTRDB_CVT_TO_HEX signed_int 2147483647
Char: 2147483647
Int:  2147483647
Hex:  7FFFFFFF

$ @CPTRDB_CVT_FROM_HEX signed_int ffffffff
Hex: FFFFFFFF
Int: -1

$ @CPTRDB_CVT_TO_HEX signed_int -1
Char: -1
Int:  -1
Hex:  FFFFFFFF

$ @CPTRDB_CVT_FROM_HEX signed_int 80000000
Hex: 80000000
Int: -2147483648

$ @CPTRDB_CVT_TO_HEX signed_int -2147483648
Char: -2147483648
Int:  -2147483648
Hex:  80000000

-- unsigned_int --

$ @CPTRDB_CVT_FROM_HEX unsigned_int ffffffff
Hex: FFFFFFFF
Int: 4294967295

$ @CPTRDB_CVT_TO_HEX unsigned_int 4294967295
Char: 4294967295
Int:  4294967295
Hex:  FFFFFFFF

-- timestamp --

$ sh time
  24-MAY-2017 15:22:58

$ @CPTRDB_CVT_TO_HEX timestamp 24-MAY-2017 15:22:58.00
Char: 24-MAY-2017 15:22:58.00
Hex:  00B1B82A164BF500

$ @CPTRDB_CVT_FROM_HEX timestamp 00B1B82A164BF500
Hex:  00B1B82A164BF500
Char: 24-MAY-2017 15:22:58.00

$ sh time
  14-JUN-2017 12:38:15

$ @CPTRDB_CVT_TO_HEX timestamp 14-JUN-2017
Char: 14-JUN-2017
Hex:  00B1C8939D561C00

$ @CPTRDB_CVT_FROM_HEX timestamp 00B1C8939D561C00
Hex:  00B1C8939D561C00
Char: 14-JUN-2017 12:38:40.32

$ @CPTRDB_CVT_TO_HEX timestamp 31-dec-9999 23:59:59.99
Char: 31-DEC-9999 23:59:59.99
Hex:  23A73DE7486B7960

$ @CPTRDB_CVT_from_HEX timestamp 23A73DE7486B7960
Hex:  23A73DE7486B7960
Char: 31-DEC-9999 23:59:59.99

-- signed_bigint --

$ @CPTRDB_CVT_TO_HEX signed_bigint 1789
Char: 1789
Int:  1789
Hex:  00000000000006FD

$ @CPTRDB_CVT_FROM_HEX signed_bigint 00000000000006FD
Hex:    00000000000006FD
Bigint: 1789

$ @CPTRDB_CVT_FROM_HEX signed_bigint 6FD
Hex:    00000000000006FD
Bigint: 1789

$ @CPTRDB_CVT_TO_HEX signed_bigint -1789
Char: -1789
Int:  -1789
Hex:  FFFFFFFFFFFFF903

$ @CPTRDB_CVT_FROM_HEX signed_bigint FFFFFFFFFFFFF903
Hex:    FFFFFFFFFFFFF903
Bigint: -1789

$ @CPTRDB_CVT_FROM_HEX signed_bigint 7fffffffffffffff
Hex:    7FFFFFFFFFFFFFFF
Bigint: 9223372036854775807

$ @CPTRDB_CVT_TO_HEX signed_bigint 9223372036854775807
Char: 9223372036854775807
Int:  9223372036854775807
Hex:  7FFFFFFFFFFFFFFF

$ @CPTRDB_CVT_FROM_HEX signed_bigint 8000000000000000
Hex:    8000000000000000
Bigint: -9223372036854775808

$ @CPTRDB_CVT_TO_HEX signed_bigint -9223372036854775808
Char: -9223372036854775808
Int:  -9223372036854775808
Hex:  8000000000000000

$ @CPTRDB_CVT_FROM_HEX signed_bigint ffffffffffffffff
Hex:    FFFFFFFFFFFFFFFF
Bigint: -1

$ @CPTRDB_CVT_TO_HEX signed_bigint -1
Char: -1
Int:  -1
Hex:  FFFFFFFFFFFFFFFF

-- unsigned_bigint --

$ @CPTRDB_CVT_FROM_HEX unsigned_bigint ffffffffffffffff
Hex:    FFFFFFFFFFFFFFFF
Bigint: 18446744073709551615

$ @CPTRDB_CVT_TO_HEX unsigned_bigint 18446744073709551615
Translated upto: {}
***** Warning, __UINT64_MAX Reached or integer overflow
Max:     18446744073709551615
Char:    18446744073709551615
Decimal: 18446744073709551615
Hex:     FFFFFFFFFFFFFFFF

$ @CPTRDB_CVT_TO_HEX unsigned_bigint 18446744073709551616
Translated upto: {6}
***** Warning, __UINT64_MAX Reached or integer overflow
Max:     18446744073709551615
Char:    18446744073709551616
Decimal: 18446744073709551615
Hex:     FFFFFFFFFFFFFFFF

$ @CPTRDB_CVT_TO_HEX unsigned_bigint g
***** Error, Unrecognised character(s): {G                   }

$ @CPTRDB_CVT_TO_HEX unsigned_bigint 128boem
Translated upto: {BOEM             }
Char:    128BOEM
Decimal: 128
Hex:     0000000000000080

$ @CPTRDB_CVT_FROM_HEX unsigned_bigint 80
Hex:    0000000000000080
Bigint: 128
</pre>

<p>
<b>CPTRDB_CALENDAR_GEN.COM</b><br>
  Generate a calendar file between two dates.
</p>
  
<pre>
Parameters: P1,   from date, date ansi, yyyy-mm-dd
            [P2], to date,   date ansi, yyyy-mm-dd
</pre>

<p>
  The output file lists:
</p>

<pre>
Date
Julian Date
Week Number
Week Day
</pre>

<p>
  Usage:
</p>

<pre>
$ @CPTRDB_CALENDAR_GEN {date ansi} [{date ansi}]
</pre>

<p>
  Output sample:
</p>

<pre>
@CPTRDB_CALENDAR_GEN 2019-05-01 2019-05-31
Output CPT$RDB_LISTS:CALENDAR_L15S29_20190501.LIS_06MAY162747

--
-- Generated By CPTRDB On Node L15S29 At 2019-05-06 16:27:47
-- Dates Between 2019-05-01 And 2019-05-31
--
2019-05-01|121|18|Wed|...
2019-05-02|122|18|Thu|...
2019-05-03|123|18|Fri|...
-------------------------
2019-05-04|124|18|Sat|...
2019-05-05|125|18|Sun|...
-------------------------
2019-05-06|126|19|Mon|...
2019-05-07|127|19|Tue|...
2019-05-08|128|19|Wed|...
2019-05-09|129|19|Thu|...
2019-05-10|130|19|Fri|...
-------------------------
2019-05-11|131|19|Sat|...
2019-05-12|132|19|Sun|...
-------------------------
2019-05-13|133|20|Mon|...
2019-05-14|134|20|Tue|...
2019-05-15|135|20|Wed|...
2019-05-16|136|20|Thu|...
2019-05-17|137|20|Fri|...
-------------------------
2019-05-18|138|20|Sat|...
2019-05-19|139|20|Sun|...
-------------------------
2019-05-20|140|21|Mon|...
2019-05-21|141|21|Tue|...
2019-05-22|142|21|Wed|...
2019-05-23|143|21|Thu|...
2019-05-24|144|21|Fri|...
-------------------------
2019-05-25|145|21|Sat|...
2019-05-26|146|21|Sun|...
-------------------------
2019-05-27|147|22|Mon|...
2019-05-28|148|22|Tue|...
2019-05-29|149|22|Wed|...
2019-05-30|150|22|Thu|...
2019-05-31|151|22|Fri|...
-------------------------
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 65"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 65 -- Database And Output Files Formats
</font>
</h3>

<p>
This chapter lists the database, daily and weekly log and output files handled
in a full featured toolset environment, for reference purposes.<br>
Refer to the procedure CPTRDB_SUBMIT.COM in 
<a href="#Chapter 14">§ -- 14 -- Minimum Setup Requirements</a>
for more information on the filespecs naming conventions.
</p>

-- In CPT$RDB Daily --

<pre>
BATCH_ENTRIES_DAILY.DIFF
BATCH_ENTRIES_DAILY.TMP_REF
SHOW_ENTRIES_DAILY.DIFF
SHOW_ENTRIES_DAILY.TMP_REF
</pre>

-- In CPT$RDB_LOGS Daily --

<pre>
BACKUP_AIJ_ALL_L15S29_20150407.LOG_07APR001415
BACKUP_AIJ_ALL_L15S29_20150407.LOG_07APR004420
BACKUP_AIJ_ALL_L15S29_20150407.LOG_07APR011422
...

BACKUP_AIJ_CPTRDB_DB_1_L15S29_20150407.LOG_07APR001415
BACKUP_AIJ_CPTRDB_DB_1_L15S29_20150407.LOG_07APR004420
BACKUP_AIJ_CPTRDB_DB_1_L15S29_20150407.LOG_07APR011422
...

BACKUP_AIJ_CPTRDB_MASTR_L15S29_20150407.LOG_07APR001418
BACKUP_AIJ_CPTRDB_MASTR_L15S29_20150407.LOG_07APR004421
BACKUP_AIJ_CPTRDB_MASTR_L15S29_20150407.LOG_07APR011423
...

BACKUP_DB_ALL_L15S29_20150407.LOG_07APR003500
BACKUP_DB_CPTRDB_DB_1_L15S29_20150407.LOG_07APR003500
BACKUP_DB_CPTRDB_MASTR__L15S29_20150407.LOG_07APR003619

BATCH_ENTRIES_DAILY_L15S29_20150407.LOG_07APR081500

CLEANUP_JDBC_LOGS_ALL_L15S29_20150407.LOG_07APR050000
CLEANUP_JDBC_LOGS_L15S28_20150407.LOG_07APR050000
CLEANUP_JDBC_LOGS_L15S29_20150407.LOG_07APR050001

CLEANUP_LOGS_DAILY_L15S29_20150407.LOG_07APR083000

DDLCK_CNTS_ALL_L15S29_20150407.LOG_07APR043000
DDLCK_CNTS_CPTRDB_DB_1_L15S29_20150406.LOG_07APR043000

SHOW_AIJ_BCK_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_AIJ_BCK_NOEXP_DAY_L15S29_20171206.LOG_06DEC080000
SHOW_AIJ_LIVE_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_BUGCHECK_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_DBS_OPEN_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_DB_BCK_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_ENTRIES_DAILY_L15S29_20180307.LOG_07MAR082000
SHOW_EXTENTS_DAILY_L15S29_20150407.LOG_07APR080000

SHOW_JDBC_LOGS_DAILY_L15S29_20150407.LOG_07APR080000
SHOW_JDBC_PROCESS_DAILY_L15S29_20150407.LOG_07APR080000

SHOW_SQLSRV_DAILY_L15S29_20150407.LOG_07APR080000

SHOW_STATS_DAILY_L15S29_20150407.LOG_07APR080000

SHOW_STAT_DATA_CPTRDB_1_L15S29_20190115.LOG_15JAN000200;1
SHOW_STAT_LOGS_CPTRDB_1_L15S29_20190115.LOG_15JAN000200;1

SRVTRC_CLIENTS_ALL_L15S29_20160922.LOG_22SEP040000
SRVTRC_CLIENTS_TS1702_L15S28_20160921.LOG_22SEP040000
SRVTRC_CLIENTS_TS1702_L15S29_20160921.LOG_22SEP040013
SRVTRC_CLIENTS_TS1703_L15S28_20160921.LOG_22SEP040001
SRVTRC_CLIENTS_TS1703_L15S29_20160921.LOG_22SEP040014
SRVTRC_CLIENTS_TS1704_L15S28_20160921.LOG_22SEP040004
SRVTRC_CLIENTS_TS1704_L15S29_20160921.LOG_22SEP040016
SRVTRC_CLIENTS_TS1705_L15S28_20160921.LOG_22SEP040006
SRVTRC_CLIENTS_TS1705_L15S29_20160921.LOG_22SEP040018

STALL_CNTS_ALL_L15S29_20150407.LOG_07APR044500
STALL_CNTS_CPTRDB_DB_1_L15S29_20150406.LOG_07APR044500

STALL_RW_CNTS_ALL_L15S29_20160511.LOG_11MAY050000
STALL_RW_CNTS_CPTRDB_DB_1_L15S29_201605.LOG_11MAY050000

STALL_RW_TIMES_ALL_L15S29_20160511.LOG_11MAY051000
STALL_RW_TIMES_CPTRDB_DB_1_L15S29_20160.LOG_11MAY051000

STALL_TIMES_ALL_L15S29_20150407.LOG_07APR050000
STALL_TIMES_CPTRDB_DB_1_L15S29_20150406.LOG_07APR050000
</pre>

-- In CPT$RDB_LISTS Daily --

<pre>
BATCH_ENTRIES_DAILY_L15S29_20150407.LIS_07APR081501

LML_DUMP_CHECKPOINT_CON.DIFF;2261
LML_DUMP_CHECKPOINT_CON.TMP_REF;2261
LML_DUMP_CHECKPOINT_CON_L15S29_20190115.LIS_15JAN132542;1
LML_DUMP_CHECKPOINT_CON_L15S29_20190115.LIS_15JAN135543;1
...

LML_SHOW_AERCP_CONT.DIFF
LML_SHOW_AERCP_CONT.TMP_REF
LML_SHOW_AERCP_CONT_L15S29_20150407.LIS_07APR090721
LML_SHOW_AERCP_CONT_L15S29_20150407.LIS_07APR093722
...

LML_SHOW_HEARTBEAT_CONT.DIFF
LML_SHOW_HEARTBEAT_CONT.TMP_REF
LML_SHOW_HEARTBEAT_CONT_L15S29_20150407.LIS_07APR090727
LML_SHOW_HEARTBEAT_CONT_L15S29_20150407.LIS_07APR093728
...

LML_SHOW_PROCESS_DAILY.DIFF
LML_SHOW_PROCESS_DAILY.TMP_REF
LML_SHOW_PROCESS_DAILY_L15S29_20150407.LIS_07APR080001

LML_SHOW_STATS_DAILY.DIFF
LML_SHOW_STATS_DAILY.TMP_REF
LML_SHOW_STATS_DAILY_L15S29_20150407.LIS_07APR081000

SHOW_AIJ_BCK_DAILY.DIFF
SHOW_AIJ_BCK_DAILY.TMP_REF
SHOW_AIJ_BCK_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_AIJ_BCK_NOEXP_DAY_L15S29_20171206.LIS_06DEC080001
SHOW_AIJ_LIVE_DAILY_L15S29_20150407.LIS_07APR080001
SHOW_BUGCHECK_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_DBS_OPEN_DAILY.DIFF
SHOW_DBS_OPEN_DAILY.TMP_REF
SHOW_DBS_OPEN_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_DB_BCK_DAILY.DIFF
SHOW_DB_BCK_DAILY.TMP_REF
SHOW_DB_BCK_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_ENTRIES_DAILY_L15S29_20180307.DIFF_07MAR082000
SHOW_ENTRIES_DAILY_L15S29_20180307.LIS_07MAR082000

SHOW_EXTENTS_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_JDBC_LOGS_DAILY.DIFF
SHOW_JDBC_LOGS_DAILY.TMP_REF
SHOW_JDBC_LOGS_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_JDBC_PROCESS_DAILY.DIFF
SHOW_JDBC_PROCESS_DAILY.TMP_REF
SHOW_JDBC_PROCESS_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_SQLSRV_DAILY.DIFF
SHOW_SQLSRV_DAILY.TMP_REF
SHOW_SQLSRV_DAILY_L15S29_20150407.LIS_07APR080001

SHOW_STATS_DAILY.DIFF
SHOW_STATS_DAILY.TMP_REF
SHOW_STATS_DAILY_L15S29_20150407.LIS_07APR080001
</pre>

-- In CPT$RDB_DB_BCK Daily --

<pre>
CPTRDB_DB_1_L15S29_20150407_0035.RBF
CPTRDB_MASTR_DB_L15S29_20150407_0036.RBF
</pre>

-- In CPT$RDB_AIJ_BCK Daily --

<pre>
CPTRDB_DB_1_L15S29_20150407_0014_5311.AIJ_BCK
CPTRDB_DB_1_L15S29_20150407_0614_5312.AIJ_BCK
CPTRDB_DB_1_L15S29_20150407_0814_5313.AIJ_BCK
...

CPTRDB_MASTR_L15S29_20150407_0014_827.AIJ_BCK
CPTRDB_MASTR_L15S29_20150407_0614_828.AIJ_BCK
CPTRDB_MASTR_L15S29_20150407_0814_829.AIJ_BCK
...
</pre>

-- In CPT$RDB_STALL Daily --

<pre>
CPTRDB_DB_1_DEADLOCK_L15S29_20150407.LOG_07APR000202
CPTRDB_DB_1_OPCOM_L15S29_20150407.LOG_07APR000202
CPTRDB_DB_1_STALL_L15S29_20150407.LOG_07APR000202
CPTRDB_DB_1_TIMEOUT_L15S29_20150407.LOG_07APR000202
</pre>

-- In CPT$RDB_PERFT4 Daily --

<pre>
CPTRDB_DB_1_DATA_L15S29_20150406.CSV_06APR235800
CPTRDB_DB_1_DATA_L15S29_20150406.UNL_06APR000201
CPTRDB_DB_1_DATA_L15S29_20150407.UNL_07APR000202
</pre>

-- In CPT$RDB_STALL_CNTS Daily --

<pre>
DDLCK_CNTS_CPTRDB_DB_1_L15S29_20150406.LIS_07APR043000
STALL_CNTS_CPTRDB_DB_1_L15S29_20150406.LIS_07APR044500
STALL_RW_CNTS_CPTRDB_DB_1_L15S29_201605.LIS_11MAY050000
STALL_RW_TIMES_CPTRDB_DB_1_L15S29_20160.LIS_11MAY051000
STALL_TIMES_CPTRDB_DB_1_L15S29_20150406.LIS_07APR050000
</pre>

-- In CPT$RDB_SIZE Daily --

<pre>
CPTRDB_DB_1.SIZE
CPTRDB_DB_1_L15S29_20190115.DIFF_15JAN080002
</pre>

-- In DISK$USERS:[ORACLE.RDB$PROCS] Daily --

<pre>
RESTART_JDBC_ALL_L15S28_20150423.LOG_23APR0016
</pre>

-- In DISK$USERS:[JDBCMON] Daily --

<pre>
RESTART_JDBC_L15S28_20150423.LOG_23APR001600
RESTART_JDBC_L15S29_20150423.LOG_23APR001637
</pre>

-- In CPT$RDB_JDBC_LOGDIR Daily --

<pre>
POOLOUT_TSP1701_L15S29_20150407.LOG_07APR001642
SRVERR_TS1702_L15S29_20150407.LOG_07APR001650
SRVERR_TS1703_L15S29_20150407.LOG_07APR001652
SRVERR_TS1704_L15S29_20150407.LOG_07APR001647
SRVERR_TS1705_L15S29_20150407.LOG_07APR001645
SRVLOG_TS1702_L15S29_20150407.LOG_07APR001650
SRVLOG_TS1703_L15S29_20150407.LOG_07APR001652
SRVLOG_TS1704_L15S29_20150407.LOG_07APR001647
SRVLOG_TS1705_L15S29_20150407.LOG_07APR001645
SRVOUT_TS1702_L15S29_20150407.LOG_07APR001650
SRVOUT_TS1703_L15S29_20150407.LOG_07APR001652
SRVOUT_TS1704_L15S29_20150407.LOG_07APR001647
SRVOUT_TS1705_L15S29_20150407.LOG_07APR001645
</pre>

-- In CPT$RDB_JDBC_TRCDIR Daily --

<pre>
SRVTRC_TS1702_L15S29_20150407.LOG_07APR001650
SRVTRC_TS1703_L15S29_20150407.LOG_07APR001652
SRVTRC_TS1704_L15S29_20150407.LOG_07APR001647
SRVTRC_TS1705_L15S29_20150407.LOG_07APR001645
</pre>

-- In CPT$RDB_JDBC_TRCDIRDONE Daily --

<pre>
SRVTRC_TS1702_L15S29_20150406.LOG_06APR001649
SRVTRC_TS1703_L15S29_20150406.LOG_06APR001651
SRVTRC_TS1704_L15S29_20150406.LOG_06APR001646
SRVTRC_TS1705_L15S29_20150406.LOG_06APR001644
</pre>

-- In CPT$RDB_JDBC_THINDIR Daily --

<pre>
SRVTRC_CLIENTS_TS1702_L15S28_20160921.LIS_22SEP040000
SRVTRC_CLIENTS_TS1702_L15S29_20160921.LIS_22SEP040014
SRVTRC_CLIENTS_TS1703_L15S28_20160921.LIS_22SEP040002
SRVTRC_CLIENTS_TS1703_L15S29_20160921.LIS_22SEP040015
SRVTRC_CLIENTS_TS1704_L15S28_20160921.LIS_22SEP040004
SRVTRC_CLIENTS_TS1704_L15S29_20160921.LIS_22SEP040017
SRVTRC_CLIENTS_TS1705_L15S28_20160921.LIS_22SEP040006
SRVTRC_CLIENTS_TS1705_L15S29_20160921.LIS_22SEP040019
</pre>

-- In CPT$RDB_JCCLML_LOGS Daily --

<pre>
DTL_L15S29_CPTRDB_LML_20150406_0002.LOG
DTL_L15S29_CPTRDB_LML_20150407_0002.LOG
JCC_RUN_CLM-CPTRDB_LML.LOG
JCC_RUN_CLM-CPTRDB_LML_L15S29_20150406.LOG_06APR000202
JCC_RUN_LML-CPTRDB_LML.LOG
JCC_RUN_LML-CPTRDB_LML_L15S29_20150406.LOG_06APR000202
</pre>

-- In CPT$RDB_JCCLML_MGR Daily --

<pre>
LML_DUMP_CHECKPOINT_CON_L15S29_20190115.LOG_15JAN132542;1
LML_DUMP_CHECKPOINT_CON_L15S29_20190115.LOG_15JAN135543;1
...

LML_REOPEN_CPTRDB_LML_L15S29_20150407.LOG_07APR000201
LML_REOPEN_LOGS_ALL_L15S29_20150407.LOG_07APR000200

LML_SHOW_AERCP_CONT_L15S29_20150407.LOG_07APR110725
LML_SHOW_AERCP_CONT_L15S29_20150407.LOG_07APR113725
...

LML_SHOW_HEARTBEAT_CONT_L15S29_20150407.LOG_07APR110730
LML_SHOW_HEARTBEAT_CONT_L15S29_20150407.LOG_07APR113730
...

LML_SHOW_PROCESS_DAILY_L15S29_20150407.LOG_07APR080000
LML_SHOW_STATS_DAILY_L15S29_20150407.LOG_07APR081000
</pre>

-- In CPT$RDB_JCCLML_MGR Active --

<pre>
JCC_RUN_CTL-CPTRDB_LML.LOG
JCC_RUN_DTL-CPTRDB_LML_L15S29_20150212.LOG_12FEB104822
</pre>

-- In CPT$RDB_SRV_LOGS --

<pre>
CPTRDB_DB_1_PREPROD_ALS_2FE2FF2D.LOG
CPTRDB_DB_1_PREPROD_RCS_2FE2FF2C.LOG
CPTRDB_MASTR_DB_PREPROD_ABS_2FE3058D.LOG
CPTRDB_MASTR_DB_PREPROD_ABS_2FE30792.LOG
CPTRDB_MASTR_DB_PREPROD_ABS_2FE31719.LOG
CPTRDB_MASTR_DB_PREPROD_ALS_2FE30334.LOG
CPTRDB_MASTR_DB_PREPROD_LCS_2FE30718.LOG
CPTRDB_STDBY_DB_PREPROD_ALS_2FE2FF35.LOG
CPTRDB_STDBY_DB_PREPROD_DBR_2FE3050E.LOG
CPTRDB_STDBY_DB_PREPROD_LRS_2FE2F50D.LOG
</pre>

-- In CPT$RDB_LOGS Weekly --

<pre>
ANA_DBS_CPTRDB_DB_1_L15S29_20161003.LOG_03OCT040000
ANA_DBS_WEEKLY_L15S29_20161003.LOG_03OCT040000

COLLECT_CPTRDB_DB_1_L15S29_20161004.LOG_04OCT154008
COLLECT_STAT_WEEKLY_L15S29_20161004.LOG_04OCT154008

TRNC_CPTRDB_DB_1_L15S29_20161003.LOG_03OCT033000
TRNC_SNAPS_ALL_L15S29_20161003.LOG_03OCT033000
TRNC_STOP_CPTRDB_DB_1_L15S29_20161003.LOG_03OCT033000
</pre>

-- In CPT$RDB_ANA Weekly --

<pre>
CPTRDB_DB_1_AIJ_OPT_L15S29_20161003.LIS_03OCT040000
CPTRDB_DB_1_ANA_L15S29_20161003.LIS_03OCT040000
CPTRDB_DB_1_ANA_L15S29_20161003.UNL_03OCT040000
CPTRDB_DB_1_COLL_L15S29_20161004.LIS_04OCT154009
CPTRDB_DB_1_HDR_L15S29_20161003.LIS_03OCT040000
CPTRDB_DB_1_OPT_L15S29_20161003.LIS_03OCT040000
</pre>

-- In CPT$RDB_ANA_DB_BCK Weekly --

<pre>
ANA_CPTRDB_DB_1_L15S29_20161003_0400.RBF
</pre>

-- In [CPTRDB_DB_1] --

<pre>
CPTRDB_DB_1.RDB  
DATA_AREA_11.RDA 
DATA_AREA_11.SNP 
DATA_AREA_12.RDA 
DATA_AREA_12.SNP 
DATA_AREA_21.RDA 
DATA_AREA_21.SNP 
DATA_AREA_22.RDA 
DATA_AREA_22.SNP 
DATA_AREA_31.RDA 
DATA_AREA_31.SNP 
DATA_AREA_32.RDA 
DATA_AREA_32.SNP 
DEFAULT_AREA.RDA 
DEFAULT_AREA.SNP 
INDEX_AREA_1.RDA 
INDEX_AREA_1.SNP 
INDEX_AREA_2.RDA 
INDEX_AREA_2.SNP 
INDEX_AREA_3.RDA 
INDEX_AREA_3.SNP 
LISTS_AREA.RDA   
LISTS_AREA.SNP   
MIXED_AREA_1.RDA 
MIXED_AREA_1.SNP 
MIXED_AREA_2.RDA 
MIXED_AREA_2.SNP 
MIXED_AREA_3.RDA 
MIXED_AREA_3.SNP 
RDB_SYSTEM.RDA   
RDB_SYSTEM.SNP   
STALL_CNTS_AREA.RDA
STALL_CNTS_AREA.SNP
</pre>

-- In [CPTRDB_DB_2] --

<pre>
CPTRDB_DB_2.RDB  
DATA_AREA_11.RDA 
DATA_AREA_11.SNP 
DATA_AREA_12.RDA 
DATA_AREA_12.SNP 
DATA_AREA_21.RDA 
DATA_AREA_21.SNP 
DATA_AREA_22.RDA 
DATA_AREA_22.SNP 
DATA_AREA_31.RDA 
DATA_AREA_31.SNP 
DATA_AREA_32.RDA 
DATA_AREA_32.SNP 
DEFAULT_AREA.RDA 
DEFAULT_AREA.SNP 
INDEX_AREA_1.RDA 
INDEX_AREA_1.SNP 
INDEX_AREA_2.RDA 
INDEX_AREA_2.SNP 
INDEX_AREA_3.RDA 
INDEX_AREA_3.SNP 
LISTS_AREA.RDA   
LISTS_AREA.SNP   
MIXED_AREA_1.RDA 
MIXED_AREA_1.SNP 
MIXED_AREA_2.RDA 
MIXED_AREA_2.SNP 
MIXED_AREA_3.RDA 
MIXED_AREA_3.SNP 
RDB_SYSTEM.RDA   
RDB_SYSTEM.SNP   
</pre>

-- In [CPTRDB_MASTR_DB] --

<pre>
CPTRDB_MASTR_DB.RDB
DATA_AREA.RDA    
DATA_AREA.SNP    
DEFAULT_AREA.RDA 
DEFAULT_AREA.SNP 
INDEX_AREA.RDA   
INDEX_AREA.SNP   
LISTS_AREA.RDA   
LISTS_AREA.SNP   
RDB_SYSTEM.RDA   
RDB_SYSTEM.SNP   
</pre>

-- In [CPTRDB_STDBY_DB] --

<pre>
CPTRDB_STDBY_DB.RDB
DATA_AREA.RDA
DATA_AREA.SNP
DEFAULT_AREA.RDA
DEFAULT_AREA.SNP
INDEX_AREA.RDA
INDEX_AREA.SNP
LISTS_AREA.RDA
LISTS_AREA.SNP
RDB_SYSTEM.RDA
RDB_SYSTEM.SNP
</pre>

-- In [ANA_CPTRDB_DB_1] --

<pre>
ANA_CPTRDB_DB_1.RDB
DEFAULT_AREA.RDA
DEFAULT_AREA.SNP
RDB_SYSTEM.RDA
RDB_SYSTEM.SNP
RMU_ANA_DATA_1.RDA
RMU_ANA_DATA_1.SNP
RMU_ANA_INDEXES_1.RDA
RMU_ANA_INDEXES_1.SNP
</pre>

-- In [JCCLML_FILTER_DIR] --

<pre>
JCCLML_FILTER_DB.RDB
RDB_SYSTEM.RDA
RDB_SYSTEM.SNP
</pre>

-- In CPT$RDB_AIJ:[CPTRDB_DB_1] --

<pre>
CPTRDB_DB_1_JRNL_1.AIJ
CPTRDB_DB_1_JRNL_2.AIJ
CPTRDB_DB_1_JRNL_3.AIJ
</pre>

-- In CPT$RDB_AIJ:[CPTRDB_MASTR_DB] --

<pre>
CPTRDB_MASTR_DB_JRNL_1.AIJ
CPTRDB_MASTR_DB_JRNL_2.AIJ
CPTRDB_MASTR_DB_JRNL_3.AIJ
</pre>

-- In CPT$RDB_AIJ:[CPTRDB_STDBY_DB] --

<pre>
CPTRDB_STDBY_DB_JRNL_1.AIJ
CPTRDB_STDBY_DB_JRNL_2.AIJ
CPTRDB_STDBY_DB_JRNL_3.AIJ
</pre>

-- In CPT$RDB_CACHES --

<pre>
CACHE_INDEX_AREA_1_1_0.RDC_E9I859K8NO0000D80VU
CACHE_INDEX_AREA_1_1_1.RDC_E9I859K8NO0000D80VU
CACHE_INDEX_AREA_2_2_0.RDC_E9I859K8NO0000D80VU
CACHE_INDEX_AREA_2_2_1.RDC_E9I859K8NO0000D80VU
CACHE_INDEX_AREA_3_3_0.RDC_E9I859K8NO0000D80VU
CACHE_INDEX_AREA_3_3_1.RDC_E9I859K8NO0000D80VU
</pre>

<a href="#Chapter 1">To Top</a><br>

<a name="Chapter 66"></a>
<h3><font face="helvetica, arial, sans-serif" color="#330099">
§ -- 66 -- End CPTRDB Users Guide
</font>
</h3>

</body>
</html>
